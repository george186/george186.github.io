<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>寒假练习1</title>
      <link href="test4/undefined-undefined.html"/>
      <url>test4/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>寒假到了，菜鸡练习时间到了。争取每天至少buuctf一道题，并且加上sql注入的学习。<br>因为太长没练手了，所以先来一道代码审计题。</p><h1 id="HCTF-2018-WarmUP1"><a href="#HCTF-2018-WarmUP1" class="headerlink" title="[HCTF 2018]WarmUP1"></a>[HCTF 2018]WarmUP1</h1><p>打开题目发现只有一个大滑稽。<br>于是查看源码<br><img src="https://s3.ax1x.com/2021/01/15/s0MjeJ.md.png" alt="s0MjeJ.md.png"><br>发现&lt; !–source.php– &gt;这个php文件，于是再在网址中打开就可以发现真正的源码（截图没有截全）<br><img src="https://s3.ax1x.com/2021/01/15/s0QJTs.md.png" alt="s0QJTs.md.png"><br>观察可以发现还有一个hint.php文件，于是在网址打开它看一下。<br><img src="https://s3.ax1x.com/2021/01/15/s0QX1f.md.png" alt="s0QX1f.md.png"><br>可以知道flag被放在ffffllllaaaagggg目录中，又因为下面的代码中有include（）这个包含函数，并且要上传file这个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0lI2V.md.png" alt="s0lI2V.md.png"><br>这就要求我们要满足 checkFile(&amp;$page)函数，然后再构造payload，使用../进行跳转到ffffllllaaaagggg目录，就可以得到flag。<br>那么接下来就是对这个函数进行研究。  </p><blockquote><p>if (! isset($page) || !is_string($page))</p></blockquote><p>由这串代码可以看出page为变量，同时是一个字符串。<br>随后这个程序定义了两个字符串为白名单（$whitelist）也就是可以通过的字符串。分别为  </p><blockquote><p>source.php和hint.php</p></blockquote><p>也就是说我们的上传的变量<strong>page</strong>经过变换后要是上面二者之一才能通过checkFile(&amp;$page)函数。  </p><hr><p>先看第一个判断  </p><pre><code>            if (in_array($page, $whitelist)) &#123;                return true;            &#125;</code></pre><p>可以看出这个是直接将page和白名单进行比较，虽然我们直接输入那两个字符串就可以通过，但是这样没有办法用../来跳转目录，所以第一个是没办法绕过的。  </p><hr><p>再来看第二个。  </p><pre><code>            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;  </code></pre><p>这个里面的新函数有substr()和strpos()。  </p><blockquote><p>mb _ substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。<br>其中该函数有三个参数</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/15/s0YVjx.md.png" alt="s0YVjx.md.png"><br>而mb_strpos()函数作用如下  </p><blockquote><p>查找 “php” 在字符串中第一次出现的位置：</p></blockquote><p>他也有三个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0Yox1.md.png" alt="s0Yox1.md.png"><br>将这两个函数联系起来可以发现输入的page字符串最后被截取到“？”这个位置，如我们输入以下字符串  </p><blockquote><p>file=source.php?/../ffffllllaaaagggg</p></blockquote><p>那么再经过变换后得到的结果是source.php。正好可以符合白名单。<br>那么接下来就是进行目录穿越了。我们可以构造以下payload。  </p><blockquote><p>?file=source.php?/../../../../ffffllllaaaagggg</p></blockquote><p>注意../数量要够，否则没法到flag那个目录。<br><img src="https://s3.ax1x.com/2021/01/15/s0aUQs.md.png" alt="s0aUQs.md.png">  </p><hr><p>再看第三个判断。  </p><pre><code>            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;  </code></pre><p>可以看出它多了一个urldecode()函数。也就是将url编码解码，因为当我们输入url后上传时，会自动解码一次。所以说如果我们将“？”连续url编码两次，那么在经过urldecode()函数后就又变成了？这样也可以绕过白名单，所以构造以下payload。  </p><blockquote><p>?file=hint.php%253f/../../../../../ffffllllaaaagggg</p></blockquote><p>同样得到flag。  </p>]]></content>
      
      
      <categories>
          
          <category> test4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第二周练习ssrf1</title>
      <link href="test3/undefined-undefined.html"/>
      <url>test3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周第三道题目可以说是一波三折。  </p><h1 id="SSRF1"><a href="#SSRF1" class="headerlink" title="SSRF1"></a>SSRF1</h1><p>打开题目看到这样的代码<br><img src="https://s3.ax1x.com/2020/12/06/DO4JXQ.md.png" alt="DO4JXQ.md.png"><br>因为题目是SSRF，所以第一时间先去了解了SSRF的相关知识（详细的以后再写一篇博客）<br>简单来说如图<br><img src="https://s3.ax1x.com/2020/12/06/DO5SgS.md.png" alt="DO5SgS.md.png"><br>代码的第一个正则匹配就是对url的验证，它要求url里必须有<strong>dotnet.com</strong>这一字符串才能进行接下来的代码，也就是说才能访问内部系统。（dotnet.com也就相当于内网网址） </p><p>又因为代码最后给出解释flag在“/flag”里，这是一个目录，所以很容易就想到使用file://伪协议来读取网站下的文件，但是可以看到第二个正则匹配过滤掉了所有的php伪协议，并且不能使用大小写绕过，只给出了一个file _get _contents()函数，所以明显要从这个函数下手。  </p><p>但是从菜鸟教程得到的file _get _contents()函数的解释却很少，<br><img src="https://s3.ax1x.com/2020/12/06/DO5H2T.md.png" alt="DO5H2T.md.png"><br>对绕过这个正则函数好像没有什么用，于是又去网上搜索关于file _get _contents()函数的用法，但是搜到的最多只有它和伪协议php://input来搭配使用，依然没办法绕过这个正则函数。  </p><p>正当我正发愁时，终于发现了file _get _contents()函数的另一个用法</p><blockquote><p>当PHP的 file _get _contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞</p></blockquote><p>ohhhhhhhhhhhhh!!!<br>也就是说如果我们构造一个不存在的伪协议头的话，这个伪协议头就会成为一个目录的名称（如<strong>0://dotnet.com</strong>就会被当成目录），这样的话就相当于我们访问了这个网站的这个目录，我们只需不断向上跳转到根目录就能得到flag的文件，于是我构造了以下payload  </p><blockquote><p>?url=0://dotnet.com/../../../../../flag</p></blockquote><p>注意向上跳转的次数一定要够，否则就跳不到根目录。<br>最后就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/06/DOI4yD.md.png" alt="DOI4yD.md.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题其实总体来说并没有考到对ssrf的绕过方式（刚开始我以为是要绕过正则匹配到内网），这道题重点是在file _get _contents()函数，如何利用这个函数来绕过对伪协议的过滤，进行目录穿越。如果不知道这个函数还有这种用法，估计会卡死在伪协议的过滤上。</p>]]></content>
      
      
      <categories>
          
          <category> test3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周习题1</title>
      <link href="test2/undefined-undefined.html"/>
      <url>test2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了平台上更新的两道题，现在写一下做题思路。  </p><h1 id="php伪协议1"><a href="#php伪协议1" class="headerlink" title="php伪协议1"></a>php伪协议1</h1><p>打开题目，得到以下代码<br><img src="https://s3.ax1x.com/2020/12/03/DHp5Cj.md.png" alt="DHp5Cj.md.png"><br>由include()函数可以知道这是一道文件包含题，可以使用php伪协议来做，但是发现源代码里有一个正则函数，过滤了所有php伪协议相关的字符串。那么是不是就不能用伪协议了呢？并不是这样的。<br>再仔细观察这个函数的语法，发现它并没有区分要匹配的字符串的大小写（语法是/i）。也就是说如果我们传入Php这样的字符串的时候是不会被过滤掉的。而get传入并不区分大小写。所以有大写的伪协议同样有效。于是我们便可以利用大小写来绕过这个函数。  </p><hr><p><strong>关于正则表达式的详细语法</strong><br><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式语法</a>  </p><hr><p>我构造的payload如下  </p><blockquote><p>?file=Php://filter/read=convert.Base64-encode/resource=flag</p></blockquote><p>从而得到base64编码过的flag文件<br><img src="https://s3.ax1x.com/2020/12/03/DHPiND.md.png" alt="DHPiND.md.png"><br>再解码就可以得到flag<br>随后又尝试了data://等协议，但是没有效果，不知道原因是什么。  </p><h1 id="php伪协议2"><a href="#php伪协议2" class="headerlink" title="php伪协议2"></a>php伪协议2</h1><p>打开题目，代码如下<br><img src="https://s3.ax1x.com/2020/12/03/DHPQUS.md.png" alt="DHPQUS.md.png"><br>这道题和上一道很像，但是匹配加上了不区分大小写这一条件，利用大小写绕过就不能再用了，这时又注意到一个新函数str_replace()，关于这个函数我在另一篇博客讲过了<br><a href="https://george186.github.io/test1/undefined-undefined.html">关于str_replace()函数</a><br>简单来说，就是它会搜索字符串里的<strong>troye</strong>这个字符串然后将其删除，这正好为我们提供了一个绕过方法，如果我们传入以下字符  </p><blockquote><p>phtroyep://filter/……..</p></blockquote><p>那么它不仅可以绕过第一个正则匹配，而且最终会变成以下字符串  </p><blockquote><p>php://filter/……..</p></blockquote><p>这样既绕过了正则函数，又使最后传入的是伪协议，从而达到读取flag的目的。于是我们构造以下payload  </p><blockquote><p>?file=ptroyehp://filter/read=convert.btroyease64-encode/resource=flag</p></blockquote><p>便可以得到base64编码过的flag，再解码就可以了。<br><img src="https://s3.ax1x.com/2020/12/03/DHi3dK.md.png" alt="DHi3dK.md.png">  </p><hr><p>这两道题是将正则函数绕过和php伪协议放在一起考了，比起单单只用伪协议要难一些。以后的ctf中应该都是这种多个方面在一起考查，所以不能只会一个方面的东西，知识面要广。</p>]]></content>
      
      
      <categories>
          
          <category> test2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界练习---伪协议</title>
      <link href="test1/undefined-undefined.html"/>
      <url>test1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了一道关于伪协议的题，较本周的另两道简单，算是巩固一下关于伪协议的知识<br>打开地址得到以下源代码<br><img src="https://s3.ax1x.com/2020/12/02/DoJ5WR.md.png" alt="DoJ5WR.md.png"><br>有include()函数，可以知道是一道文件包含漏洞题，可以使用php伪协议来解决。（关于文件包含漏洞问题之后再进行总结）<br>再看到有这样一个函数  </p><blockquote><p>str_replace(“php://“, “”, $page);</p></blockquote><p>于是了解一下这个函数<br><img src="https://s3.ax1x.com/2020/12/02/DotOGd.md.png" alt="DotOGd.md.png"><br>可以知道，该函数会匹配get传参的字符串中的php://这个字符串，并将其替换成空格，等于过滤了这个字符串。所以我们不能直接使用php://协议。但是可以使用其他协议，我使用了data://协议。<br>该协议可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>因此我们可以先构造payload来读取文件目录  </p><blockquote><p>?page=data://text/plain,<?php system('ls');?></p></blockquote><p>得到文件目录<br><img src="https://s3.ax1x.com/2020/12/02/DoNtL6.md.png" alt="DoNtL6.md.png"><br>可以知道包含flag的文件，接着使用命令执行函数读出该文件内容就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/02/DoNDWd.md.png" alt="DoNDWd.md.png">  </p><hr><p>当然这道题还有别的解法,str_replace()函数默认情况下识别是分大小写的，所以我们可以通过大小写绕过这个函数，当我们知道包含flag的文件名后，利用大小写可以构造以下payload来绕过  </p><blockquote><p>?page=Php://filter/read=convert.base64-encode/resource=fl4gisisish3r3.php</p></blockquote><p>得到base64编码过的php文件，再解码就可以得到flag</p>]]></content>
      
      
      <categories>
          
          <category> test1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议笔记</title>
      <link href="note2/undefined-undefined.html"/>
      <url>note2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习了关于PHP的伪协议相关知识，现在做一下总结<br>先给出我学习的网址<br><a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结</a><br><a href="https://www.freebuf.com/column/148886.html">php伪协议实现命令执行的七种姿势</a><br>PHP伪协议包括file://、php://filter、php://input、zip://、compress.bzip2://、compress.zlib://、data://。下面介绍常用的几个  </p><h1 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h1><p>file://协议在双off的情况下也可以正常使用<br>allow_url_fopen ：off/on<br>allow_url_include：off/on<br>file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow _url _fopen与allow _url _include的影响。<br>使用方法<br>file:// [文件的绝对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt">http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt</a>  </p></blockquote><p>file:// [文件的相对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=./phpinfo.txt">http://127.0.0.1/include.php?file=./phpinfo.txt</a>  </p></blockquote><p>http://网络路径和文件名  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a>  </p></blockquote><h1 id="php-协议"><a href="#php-协议" class="headerlink" title="php://协议"></a>php://协议</h1><p>这个是我目前用到最多的，它包括php://filter、php://input、 php://stdin、 php://memory 和 php://temp,不需要开启allow _url _fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow _url _include。<br>其中php://filter和php://input使用较多<br><img src="https://s3.ax1x.com/2020/12/02/Do1AuF.md.png" alt="Do1AuF.md.png">  </p><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>该协议用于读取源码<br><img src="https://s3.ax1x.com/2020/12/02/Do1GHH.md.png" alt="Do1GHH.md.png"><br><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=%5B%E6%96%87%E4%BB%B6%E5%90%8D%5D%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%BA%90%E7%A0%81%EF%BC%88%E9%92%88%E5%AF%B9php%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81base64%E7%BC%96%E7%A0%81%EF%BC%89">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）</a>  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php</a></p></blockquote><h2 id="php-input-POST-DATA-执行php代码"><a href="#php-input-POST-DATA-执行php代码" class="headerlink" title="php://input+[POST DATA]执行php代码"></a>php://input+[POST DATA]执行php代码</h2><p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://input">http://127.0.0.1/cmd.php?file=php://input</a><br>[POST DATA] <?php phpinfo()?></p></blockquote><h1 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h1><p>使用条件allow _url _fopen ：on<br>allow _url _include：on<br>可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>data://text/plain，<br>data://text/plain；base64，  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain">http://127.0.0.1/cmd.php?file=data://text/plain</a>,<?php phpinfo()?></p><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</a></p></blockquote><p>关于zip://、compress.bzip2://、compress.zlib://这三个协议目前还没有遇到相关题目，以后遇到再总结更新</p>]]></content>
      
      
      <categories>
          
          <category> note2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中foreach函数笔记</title>
      <link href="note1/undefined-undefined.html"/>
      <url>note1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周做的题目中有一道变量覆盖问题，其中用到了foreach()函数，当时看到别人对这个函数的解释并没有很懂，于是自己又通过查找又了解一下这个函数用法，现在把自己的理解写出来。  </p><h1 id="foreach-函数—-关于-key的值"><a href="#foreach-函数—-关于-key的值" class="headerlink" title="foreach()函数—-关于$key的值"></a>foreach()函数—-关于$key的值</h1><p>先附上我学习这个函数的链接<br><a href="https://blog.csdn.net/qq_39388484/article/details/82839903">详解PHP中foreach的用法和实例</a><br><strong>foreach</strong>有两种语法<br>第一种：遍历给定的 数组语句 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><blockquote><p>foreach (array_expression as $value)</p></blockquote><p>第二种：同上，同时当前单元的键名也会在每次循环中被赋给变量 $key。  </p><blockquote><p>foreach (array_expression as $key =&gt; $value)</p></blockquote><p>这个函数是要和数组搭配起来使用的，下面讲解一下基本的用法  </p><h2 id="一维数组与foreach"><a href="#一维数组与foreach" class="headerlink" title="一维数组与foreach"></a>一维数组与foreach</h2><p>列出一个一维数组<br>    $a = array(‘Tom’,’Mary’,’Peter’,’Jack’);<br>用第一种方法来输出<br>    foreach ($a as $value) {<br>    echo $value.”<br/>“;<br>    }<br>最后得到的结果是Tom，Mary，Peter，Jack<br>用第二种方法来输出  </p><pre><code>foreach ($a as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value.&quot;&lt;br/&gt;&quot;;&#125;  </code></pre><p>得到的结果是<br>0,Tom<br>1,Mary<br>2,Peter<br>3,Jack<br>很明显看到多了$key这个$key的值就是序号0，1，2，3等等<br>但是在题目中有这样一串代码<br>    $$key=$$value<br>当我传入?_200=flag后，结果变成了$ _200=$flag,这时的$key值不再是序号0，1，2，3······而是变成了 _200,这是为什么呢，我在一维关联数组中找到了类似变化  </p><h2 id="一维关联数组与foreach"><a href="#一维关联数组与foreach" class="headerlink" title="一维关联数组与foreach"></a>一维关联数组与foreach</h2><p>如下<br>    $b = array(‘a’=&gt;’Tom’,’b’=&gt;’Mary’,’c’=&gt;’Peter’,’d’=&gt;’Jack’);<br>这时我们再用第一种方法输出结果和上面的相同<br>但是用第二种方式输出则发生变化  </p><pre><code>foreach ($b as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value;&#125;  </code></pre><p>最后得到的结果是：<br>a,Tom<br>b,Mary<br>c,Peter<br>d,Jack<br>很明显，这时候的key值已经变成了关联的序号，也就是a,b,c,····<br>于是我推测，当我们使用post，get方式进行传参的时候，传入的就是一维关联数组，例如上面所讲到的?_ 200=flag就相当于’_ 200’=&gt;’flag’，这样一来，得到的最后结果就变成了$ _200=$flag，$key的值也就发生了变化，最终将flag传入到了变量$ _200中。  </p><hr><p>关于foreach还能和二维数组练习，但是key的值一般不会变化，依旧是序号0，1，2·····更多相关知识还是在分享的链接里查找吧。</p>]]></content>
      
      
      <categories>
          
          <category> note1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周学习报告</title>
      <link href="note/undefined-undefined.html"/>
      <url>note/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习可以说是一路艰辛  </p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>搭建博客使用hexo+github好处多多—-<strong>前提是不报错</strong><br>分享一个搭建博客教学链接<br><a href="">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>网上一般都有有报错解决办法，但是有的还是要靠自己摸索<br>下面分享一个我遇到的最坑问题<br>当所有过程都没问题后却发现自己网上博客一片空白（本地博客）没有问题，提供以下解决办法<br><a href="https://imgchr.com/i/D607F0"><img src="https://s3.ax1x.com/2020/11/28/D607F0.md.png" alt="D607F0.md.png"></a><br>将GitHub page路径改成master，因为我上传的文件路径都是master，但是它默认的路径是main，所以出现没有报错但是网上博客一片空白的情况。<br>这个坑卡了我好几天，甚至还删了充搭了一次。。。。。。  </p><h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>这个出问题自求多福不是玄学问题吧，实在不行换主题。（说多都是泪）  </p><hr><h2 id="web学习笔记"><a href="#web学习笔记" class="headerlink" title="web学习笔记"></a>web学习笔记</h2><h3 id="命令执行函数和eval-函数"><a href="#命令执行函数和eval-函数" class="headerlink" title="命令执行函数和eval()函数"></a>命令执行函数和eval()函数</h3><p>eval()函数能将输入的字符串当作PHP代码来执行，这就很容易造成漏洞，下面是本周做的题目中的一个例子  </p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>很明显，这串代码相当于一个后门，只要你用get传参传入一串可执行的PHP代码就可以执行这串代码，注意结尾要加“；”。<br>命令执行函数常见的有以下几种<br>1、system<br>string system(string command,int &amp;return_var)</p><p>可以用来执行系统命令并将相应的执行结果输出</p><p>2、exec<br>string exec(string command,array &amp;outpub,int &amp;return_var)</p><p>command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值。</p><p>注意：exec输出的是命令执行结果的最后一行内容。如果你需要获取未经处理的全部输出数据，请使用passthru()函数。</p><p>如果想要获取命令的输出内容，请确保使用output参数。</p><p>3、passthru<br>void passthru(string command, int &amp;return_var)</p><p>command是要执行的命令，return_var存放执行命令后的状态值。</p><p>4、 shell_exec<br>string shell_exec(string command)</p><p>command是要执行的命令<br>我现在比较了解的就是system()函数，可以用的命令有很多这些命令和Linux里的命令相似  </p><blockquote><p>cat 一次显示整个文件  </p><p>tac 是将cat反过来写，所以他的功能和cat相反，cat是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来。</p><p>more  会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页<br>显示，而且还有搜寻字串的功能 。但是在网页上好像不能翻页。 </p><p>less  与 more 类似，但使用 less 可以随意浏览文件使用[pageup] [pagedown] 等按键，而 more 仅能向后移动，却不能向前移动，而且 less 在查看之前不会加载整个文件。同样网页端好像不能翻页。</p></blockquote><p>介绍完eval()和命令执行函数后可以感觉到我们可以使用这一漏洞来查看，修改web服务器里的文件。所以在题目中我构造  </p><blockquote><p>/?a=system(‘ls’);<br>和  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote></blockquote><p>便可以读出其中文件内容。  </p><h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>eval()虽然好用，但是遇上正则函数便失去作用，正则函数会过滤掉一些字符串，比如cat，tac等，这样就没有办法像一般那样直接传入函数命令，所以要绕过正则函数来上传。这里附上别人的总结<br><a href="https://blog.csdn.net/mochu7777777/article/details/104631142/">关于PHP正则匹配后代码执行的一些绕过方法</a><br>其中可以采取异或绕过，取反绕过，换行符绕过，利用正则回溯次数限制的绕过<br>这里介绍目前我能理解的两种绕过<br><strong>换行符绕过</strong><br>preg_match()函数只能匹配一行字符串，所以使用换行符%0a就可以绕过它的匹配<br><strong>url编码取反绕过</strong><br>这是取反绕过中最简单的一种绕过，该方法只适用于PHP7<br>对于想要传入的参数，先进行url编码再取反<br>例如传入构造一个phpinfo()；<br>只需要将phpinfo取反编码就行<br>如果需要执行有参数的函数，比如system(“ls”);<br>需要分别对system和ls进行取反，分别得到  </p><blockquote><p>%8C%86%8C%8B%9A%92 </p><p>%93%8C</p></blockquote><p>构建payload/?(<del>%8C%86%8C%8B%9A%92)(</del>%93%8C)；就可以绕过正则函数<br>其他的异或绕过和取反绕过以及利用回溯次数绕过需要用到脚本，等我变强了再来讨论吧hhhhh  </p><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>附上学习的链接<br><a href="https://blog.csdn.net/qq_41381461/article/details/90047616">php变量覆盖</a><br>先总结我目前遇到的两种<br><strong>extract()函数变量覆盖</strong><br><a href="https://www.runoob.com/php/func-array-extract.html">菜鸟教程关于extract的讲解</a><br>总的来说extract()函数在默认情况下，会将传入的变量的值覆盖原有的变量的值，如以下代码<br>&lt;?php  </p><blockquote><p>$id=1;<br>extract($_GET);<br>echo $id;<br>?&gt;<br>//提交：?id=123<br>//结果： 123</p></blockquote><p>所以可以将原本不知道的变量的值进行覆盖，使其成为我们传入的值，对于  </p><blockquote><p>if($liwu==$flag) {<br>        echo’flag{xxxxxxxxxxx}’;</p></blockquote><p>这类代码漏洞十分有用。<br>**$$导致的变量覆盖问题**<br>在PHP中$$表示的是一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。如以下代码<br>&lt;?php  </p><blockquote><p>$c=’hello’;<br>$$c=’world’;<br>echo $c;<br>echo $$c;<br>?&gt;</p></blockquote><p>得到的结果是helloworld，也就是说将$c作为一个变量名进行赋值，从而覆盖了原来的$c=hello。<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $value;<br>}<br>echo $a;<br>?&gt;</p></blockquote><p>如果如果get传的是?id=1，那么，经过$$key=$value之后，就会变成$id=1，覆盖掉原来的$id=5。<br>如果代码如下<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $$value;<br>}<br>echo $a;<br>?&gt;  </p></blockquote><p>那么如果get传入的是?id=flag,经过$$key = $$value之后就会变成$id=$flag，此时$flag里面的值，也就是flag已经被写入$id当中了。以上两组代码结合起来便可以实现  </p><blockquote><p>$_POST[“flag”] == $flag</p></blockquote><p>这样的要求<br>关于foreach()细节以后再另写笔记说。（因为写到这已经是凌晨一点半了。。。。。）  </p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第一周练习</title>
      <link href="test/undefined-undefined.html"/>
      <url>test/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>  第一周的web一共做了四道题，现在写下做题思路，以便日后回顾。</p><h1 id="一，basic-rec"><a href="#一，basic-rec" class="headerlink" title="一，basic rec"></a>一，basic rec</h1><p>打开题目地址，得到如下代码。<br><img src="https://s3.ax1x.com/2020/11/28/D6NtTf.md.png" alt="D6NtTf.md.png"><br>真正有用的函数只有一个</p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>于是立刻学习关于eval函数的相关用法和知识<br>这是从菜鸟教程上得知的eval()函数的用法  </p><blockquote><p>eval() 函数把字符串按照 PHP 代码来计算。<br>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p></blockquote><p>所以可以看成这个网页已经被上传了一个木马，只要我们以get请求方式上传以下形式的字符到变量a，就能将被上传的字符串按照PHP代码来执行  </p><blockquote><p>/?a=”一串PHP代码”；（结尾要有分号才能执行该代码）</p></blockquote><p>但是该上传什么样的PHP代码呢，因为我要找到flag，所以要查看该网页服务器下有flag的文件，所以选用执行系统命令函数，该函数有以下几种system()passthru()exec()shell_exec()popen()proc_open()<br>pcntl_exec()，我选用的是system()函数<br>system()函数执行有回显，会将结果输出到页面上  </p><blockquote><p>string system ( string $command [, int &amp;$return_var ])</p></blockquote><p>$command是执行的命令，[]里的可选可不选，可以执行的命令与Linux中相似，有ls，cat，tac，more，less，等其中ls是显示文件目录，cat，tac等都是查看文件内容的命令，首先我查看文件目录，于是输入以下命令  </p><blockquote><p>/?a=system(‘ls’);</p></blockquote><p>得到文件目录<br><a href="https://imgchr.com/i/D6NrXn"><img src="https://s3.ax1x.com/2020/11/28/D6NrXn.md.png" alt="D6NrXn.md.png"></a><br>知道flag在f111a9.php中，接着便读取出该文件内容  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote><p>得到flag。<br><a href="https://imgchr.com/i/D6NRtU"><img src="https://s3.ax1x.com/2020/11/28/D6NRtU.md.png" alt="D6NRtU.md.png"></a></p><h1 id="二，PHP变量覆盖"><a href="#二，PHP变量覆盖" class="headerlink" title="二，PHP变量覆盖"></a>二，PHP变量覆盖</h1><p>打开题目地址得到如下代码<br><a href="https://imgchr.com/i/D6Nhp4"><img src="https://s3.ax1x.com/2020/11/28/D6Nhp4.md.png" alt="D6Nhp4.md.png"></a>  </p><p>这道题目的重点是extrace()函数<br>extrace()将从数组中将变量导入到当前符号表，默认的是如果变量冲突，则覆盖已有的变量<br>知道这个函数后再对代码进行审计  </p><blockquote><p>$flag=’xxxxxxxx’;<br>extract($_GET); //以get传参的值会进过extract()函数<br>if(isset($liwu)) { //判断是否设立了$liwu该变量<br>    $content=trim(file_get_contents($flag)); //读取$flag的变量并将它赋给$content变量<br>    if($liwu==$content) {<br>        echo’flag{xxxxxxxxxxx}’; //如果$liwu和$content这两个变量相等就输出flag<br>    }<br>    else {<br>        echo ‘please try other operation.’;<br>    }<br>}  </p></blockquote><p>因为我不知道flag是什么，所以正常情况下不可能使$content这个变量等于$flag来得到真正的flag，所以我使用extrace()函数当传参时将$flag原来的值覆盖，这样就可以让这两个变量相等，从而得到flag。于是构造以下形式  </p><blockquote><p>/?$liwu=&amp;$flag=</p></blockquote><p>这样我们将$flag=空的值覆盖了原来的flag的值，从而使$liwu=$flag得到真正的flag。<br><a href="https://imgchr.com/i/D6NIXR"><img src="https://s3.ax1x.com/2020/11/28/D6NIXR.md.png" alt="D6NIXR.md.png"></a><br>但是不知道为什么构造/?$liwu=123&amp;$flag=123这样的不行。  </p><h1 id="三，basic-rce2"><a href="#三，basic-rce2" class="headerlink" title="三，basic rce2"></a>三，basic rce2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6Uk4S"><img src="https://s3.ax1x.com/2020/11/28/D6Uk4S.md.png" alt="D6Uk4S.md.png"></a><br>这道题目和第一题本质差别不大，都是要用到执行系统命令函数，但是可以看出多了一个preg_match()函数。这是一个正则表达式函数，这个函数可以匹配查字符串中的所要搜索的字符，从题目函数可以看出，他规定了以下字符串<br>more，less，flag，head，nl，tail，tac，cat，rm，cp，mv，*，{<br>也就是说，如果我get传参的字符串中有这些字符串就会被返回，也就是不能执行所传代码，所以说不能像第一题那样直接输入/?Rem=system(‘cat xxxx’);来查看文件，但是还是可以来查看文件目录的，（没规定ls这个字符）<br><a href="https://imgchr.com/i/D6Unun"><img src="https://s3.ax1x.com/2020/11/28/D6Unun.md.png" alt="D6Unun.md.png"></a><br>得到有flag的文件。<br>下一步便是如何绕过这个匹配，这里我选择了取反绕过（换行绕过没成功，应该是掌握的有点问题）也就是将命令 ‘cat flag index.php’取反后再进行url编码再构造/?Rem=system(~xxxxxxxxx);即可绕过关于cat flag的匹配。<br>‘cat flag index.php’取反编码如下  </p><blockquote><p>%27%9C%9E%8B%DF%99%93%9E%98%DF%96%91%9B%9A%87%D1%8F%97%8F%27</p></blockquote><p>构造payload后传参便得到flag<br><a href="https://imgchr.com/i/D6UuBq"><img src="https://s3.ax1x.com/2020/11/28/D6UuBq.md.png" alt="D6UuBq.md.png"></a>  </p><h1 id="四，PHP变量覆盖2"><a href="#四，PHP变量覆盖2" class="headerlink" title="四，PHP变量覆盖2"></a>四，PHP变量覆盖2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6UG34"><img src="https://s3.ax1x.com/2020/11/28/D6UG34.md.png" alt="D6UG34.md.png"></a><br>这次函数变成了foreach()同时多了一个$$这样的字符，而$$是这道题目的关键。<br>$$abc表示对$abc这个变量进行赋值，<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。<br>所以这道题要利用这两个foreach函数来使上传的参数flag等于$flag，进而得到flag。<br>通过代码最后一行可以知道我们要将$flag里的值赋予$_200最后才能输出flag。于是利用第一个foreach函数来构造paylod  </p><blockquote><p>/?_200=flag</p></blockquote><p>这样的结果是$$_200=$$flag,也就是将原来$_200的值覆盖成$flag里的值，也就是真正的flag。<br>接着使用第二个foreach函数来构造payload使我post传过去的flag=$flag,进而打印出$_200,于是构造以下payload  </p><blockquote><p>flag=aaaaaaaaa</p></blockquote><p>这样的结果是$$flag=aaaaaaaaa，也就是将原来$flag里的值覆盖成aaaaaaaaa，这样我们上传的参数flag一定等于$flag，而真正的flag已经被赋予$_200,最后打印出真正的flag。<br><a href="https://imgchr.com/i/D6UaHx"><img src="https://s3.ax1x.com/2020/11/28/D6UaHx.md.png" alt="D6UaHx.md.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web习题练习1</title>
      <link href="%E7%BB%83%E4%B9%A0/undefined-undefined.html"/>
      <url>%E7%BB%83%E4%B9%A0/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
